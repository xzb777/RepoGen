{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/__init__",
            "imports": [
                "from typing import Optional, Union"
            ],
            "code": "class ConstrainedLinearRegression:\n    def __init__(self, fit_intercept: bool = True, alpha: float = 0.0):\n        self.fit_intercept = fit_intercept\n        self.alpha = alpha\n        self.coef_ = None\n        self.intercept_ = 0.0\n        self.is_fitted_ = False"
        },
        {
            "key_id": 4,
            "fqn": "constrainedlr/validation.py/validate_constraint_features_all_strings_or_all_int",
            "imports": [],
            "code": "def validate_constraint_features_all_strings_or_all_int(constraints: dict) -> None:\n    if not all(isinstance(key, str) for key in constraints) and not all(isinstance(key, int) for key in constraints):\n        raise ValueError('All constraint feature names/indices must be all strings or all integers.')"
        },
        {
            "key_id": 5,
            "fqn": "constrainedlr/validation.py/get_clean_feature_names_from_pipeline",
            "imports": [],
            "code": "def get_clean_feature_names_from_pipeline(feature_names: list[str]) -> list[str]:\n    return [fn.replace(' ', '_').lower() for fn in feature_names]"
        },
        {
            "key_id": 6,
            "fqn": "constrainedlr/validation.py/validate_feature_names_in_constraints",
            "imports": [
                "from .validate_constraint_features_all_strings_or_all_int import validate_constraint_features_all_strings_or_all_int",
                "from .get_clean_feature_names_from_pipeline import get_clean_feature_names_from_pipeline"
            ],
            "code": "def validate_feature_names_in_constraints(constraints: dict, feature_names: list[str]) -> None:\n    validate_constraint_features_all_strings_or_all_int(constraints)\n    clean_feature_names = get_clean_feature_names_from_pipeline(feature_names)\n    if not all(name in clean_feature_names for name in constraints):\n        raise ValueError('All constraint feature names must be in the provided feature names.')"
        },
        {
            "key_id": 7,
            "fqn": "constrainedlr/validation.py/convert_feature_names_to_indices",
            "imports": [
                "from .get_clean_feature_names_from_pipeline import get_clean_feature_names_from_pipeline"
            ],
            "code": "def convert_feature_names_to_indices(constraints: dict, feature_names_in_: np.ndarray[str]) -> dict:\n    clean_feature_names = get_clean_feature_names_from_pipeline(list(feature_names_in_))\n    return {clean_feature_names.index(k): v for k, v in constraints.items() if k in clean_feature_names}"
        },
        {
            "key_id": 8,
            "fqn": "constrainedlr/validation.py/validate_coefficients_sign_constraints",
            "imports": [
                "from .validate_constraint_features_all_strings_or_all_int import validate_constraint_features_all_strings_or_all_int"
            ],
            "code": "def validate_coefficients_sign_constraints(coefficients_sign_constraints: Optional[dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> dict:\n    validate_constraint_features_all_strings_or_all_int(coefficients_sign_constraints)\n    if not all(v in ['positive', 'negative'] for v in coefficients_sign_constraints.values()):\n        raise ValueError('All coefficient sign constraints must be either \\'positive\\' or \\'negative\\'.')\n    return coefficients_sign_constraints"
        },
        {
            "key_id": 9,
            "fqn": "constrainedlr/validation.py/validate_intercept_sign_constraint",
            "imports": [],
            "code": "def validate_intercept_sign_constraint(intercept_sign_constraint: Union[int, str]) -> int:\n    if isinstance(intercept_sign_constraint, str):\n        if intercept_sign_constraint == 'positive':\n            return 1\n        elif intercept_sign_constraint == 'negative':\n            return -1\n        else:\n            raise ValueError('Intercept sign constraint must be either \\'positive\\' or \\'negative\\'.')\n    elif isinstance(intercept_sign_constraint, int) and intercept_sign_constraint in [-1, 1]:\n        return intercept_sign_constraint\n    else:\n        raise ValueError('Invalid type or value for intercept sign constraint.')"
        },
        {
            "key_id": 10,
            "fqn": "constrainedlr/validation.py/validate_coefficients_range_constraints",
            "imports": [
                "from .validate_constraint_features_all_strings_or_all_int import validate_constraint_features_all_strings_or_all_int",
                "from .convert_feature_names_to_indices import convert_feature_names_to_indices"
            ],
            "code": "def validate_coefficients_range_constraints(coefficients_range_constraints: Optional[dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> dict:\n    validate_constraint_features_all_strings_or_all_int(coefficients_range_constraints)\n    constraints_indices = convert_feature_names_to_indices(coefficients_range_constraints, feature_names_in_)\n    for k, v in constraints_indices.items():\n        if 'lower' in v and 'upper' in v:\n            if v['lower'] > v['upper']:\n                raise ValueError('Lower bound cannot be greater than upper bound for coefficient constraints.')\n        elif 'lower' in v:\n            if v['lower'] < 0:\n                raise ValueError('Lower bound must be non-negative.')\n        elif 'upper' in v:\n            if v['upper'] > 0:\n                raise ValueError('Upper bound must be positive.')\n    return constraints_indices"
        }
    ]
}