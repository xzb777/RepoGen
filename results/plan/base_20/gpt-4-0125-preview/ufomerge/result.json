{
    "implementation": [
        {
            "key_id": 2,
            "fqn": "ufomerge/layout.py/LayoutSubsetVisitor/__init__",
            "imports": [
                "from typing import Set"
            ],
            "code": "class LayoutSubsetVisitor:\n    def __init__(self, glyphset: Set[str]):\n        self.glyphset = glyphset\n        self.logger = logging.getLogger('ufomerge.layout')\n        self.logger.debug(f'Initialized LayoutSubsetVisitor with glyphset: {self.glyphset}')"
        },
        {
            "key_id": 25,
            "fqn": "ufomerge/layout.py/LayoutClosureVisitor/__init__",
            "imports": [
                "from typing import Dict, Set"
            ],
            "code": "class LayoutClosureVisitor:\n    def __init__(self, incoming_glyphset: Dict[str, bool], glyphset: Set[str]):\n        self.incoming_glyphset = incoming_glyphset\n        self.glyphset = glyphset\n        self.logger = logging.getLogger('ufomerge.layout')\n        self.logger.debug(f'Initialized LayoutClosureVisitor with incoming_glyphset: {self.incoming_glyphset} and glyphset: {self.glyphset}')"
        },
        {
            "key_id": 30,
            "fqn": "ufomerge/utils.py/filter_glyphs",
            "imports": [
                "from typing import Iterable, Set, List"
            ],
            "code": "def filter_glyphs(glyphs: Iterable[str], glyphset: Set[str]) -> List[str]:\n    filtered_glyphs = [glyph for glyph in glyphs if glyph in glyphset]\n    return filtered_glyphs"
        },
        {
            "key_id": 31,
            "fqn": "ufomerge/utils.py/filter_glyph_mapping",
            "imports": [
                "from typing import Mapping, Any, Dict, Set"
            ],
            "code": "def filter_glyph_mapping(glyphs: Mapping[str, Any], glyphset: Set[str]) -> Dict[str, Any]:\n    filtered_mapping = {glyph: value for glyph, value in glyphs.items() if glyph in glyphset}\n    return filtered_mapping"
        },
        {
            "key_id": 32,
            "fqn": "ufomerge/utils.py/filter_sequence",
            "imports": [
                "from typing import Iterable, Set, List, Optional, Dict"
            ],
            "code": "def filter_sequence(slots: Iterable, glyphset: Set[str], class_name_references: Optional[Dict[str, List[str]]] = None) -> List[List[str]]:\n    filtered_sequences = [[glyph for glyph in slot if glyph in glyphset] for slot in slots]\n    return filtered_sequences"
        },
        {
            "key_id": 33,
            "fqn": "ufomerge/utils.py/filter_glyph_container",
            "imports": [
                "from typing import Any, Set, Optional, Dict, List"
            ],
            "code": "def filter_glyph_container(container: Any, glyphset: Set[str], class_name_references: Optional[Dict[str, List[str]]] = None) -> Any:\n    if isinstance(container, list):\n        return [filter_glyph_container(item, glyphset, class_name_references) for item in container]\n    elif isinstance(container, dict):\n        return {key: filter_glyph_container(value, glyphset, class_name_references) for key, value in container.items()}\n    return container"
        },
        {
            "key_id": 34,
            "fqn": "ufomerge/utils.py/has_any_empty_slots",
            "imports": [
                "from typing import List"
            ],
            "code": "def has_any_empty_slots(sequence: List) -> bool:\n    return any(len(slot) == 0 for slot in sequence)"
        },
        {
            "key_id": 0,
            "fqn": "ufomerge/layout.py/_deduplicate_class_defs",
            "imports": [
                "from typing import Dict, List",
                "import fontTools.feaLib.ast as ast"
            ],
            "code": "def _deduplicate_class_defs(class_name_references: Dict[str, List[ast.GlyphClassName]]) -> List[ast.GlyphClassDefinition]:\n    unique_defs = {}\n    for class_name, references in class_name_references.items():\n        unique_defs[class_name] = ast.GlyphClassDefinition(class_name, sorted(set(ref.name for ref in references)))\n    return list(unique_defs.values())"
        },
        {
            "key_id": 1,
            "fqn": "ufomerge/layout.py/LayoutSubsetter/subset",
            "imports": [
                "import fontTools.feaLib.ast as ast",
                "from ufomerge.layout import LayoutSubsetVisitor, LayoutClosureVisitor, _ignore_pos_sub"
            ],
            "code": "class LayoutSubsetter:\n    def subset(self, fea: ast.FeatureFile):\n        visitor = LayoutSubsetVisitor(self.glyphset)\n        fea.accept(visitor)\n        closure_visitor = LayoutClosureVisitor(self.incoming_glyphset, self.glyphset)\n        fea.accept(closure_visitor)\n        _ignore_pos_sub(visitor)"
        },
        {
            "key_id": 14,
            "fqn": "ufomerge/layout.py/_ignore_pos_sub",
            "imports": [],
            "code": "def _ignore_pos_sub(visitor, st, *args, **kwargs):\n    pass  # Implementation would go here, based on visitor pattern logic"
        },
        {
            "key_id": 3,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [],
            "code": "def visit(visitor, mcd, *args, **kwargs):\n    # Assuming a visitor pattern, this function would delegate to the appropriate visitor method\n    visitor_method = getattr(visitor, 'visit_' + type(mcd).__name__, None)\n    if visitor_method:\n        return visitor_method(mcd, *args, **kwargs)"
        },
        {
            "key_id": 4,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [],
            "code": "def visit(visitor, st, *args, **kwargs):\n    # This is a duplicate task with the same logic as the previous visit function\n    # It would be implemented in the same way, handling different types of syntax tree nodes"
        },
        {
            "key_id": 16,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging"
            ],
            "code": "logger = logging.getLogger('ufomerge.layout')\ndef visit(visitor, st, *args, **kwargs):\n    try:\n        method_name = 'visit_' + type(st).__name__\n        visitor_method = getattr(visitor, method_name, None)\n        if visitor_method:\n            return visitor_method(st, *args, **kwargs)\n        else:\n            logger.warning(f'No visit method for {type(st).__name__}')\n    except Exception as e:\n        logger.error(f'Error visiting {type(st).__name__}: {e}')\n        raise"
        },
        {
            "key_id": 17,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging"
            ],
            "code": "logger = logging.getLogger('ufomerge.layout')\ndef visit(visitor, block, *args, **kwargs):\n    try:\n        method_name = 'visit_' + type(block).__name__\n        visitor_method = getattr(visitor, method_name, None)\n        if visitor_method:\n            return visitor_method(block, *args, **kwargs)\n        else:\n            logger.warning(f'No visit method for {type(block).__name__}')\n    except Exception as e:\n        logger.error(f'Error visiting {type(block).__name__}: {e}')\n        raise"
        },
        {
            "key_id": 35,
            "fqn": "ufomerge/__init__.py/UFOMerger/__post_init__",
            "imports": [
                "import logging",
                "from fontTools.ttLib import TTFont",
                "from ufoLib2 import Font",
                "from pathlib import Path",
                "from typing import Iterable, Set, Dict, Tuple, Optional",
                "import fontFeatures"
            ],
            "code": "logger = logging.getLogger('ufomerge')\nclass UFOMerger:\n    def __init__(self, ufo1: Font, ufo2: Font, glyphs: Iterable[str] = None, exclude_glyphs: Iterable[str] = None, codepoints: Iterable[int] = None, layout_handling: str = 'subset', existing_handling: str = 'replace', include_dir: Path = None, original_glyphlist: Iterable[str] = None):\n        self.ufo1 = ufo1\n        self.ufo2 = ufo2\n        self.glyphs = glyphs or []\n        self.exclude_glyphs = exclude_glyphs or []\n        self.codepoints = codepoints or []\n        self.layout_handling = layout_handling\n        self.existing_handling = existing_handling\n        self.include_dir = include_dir\n        self.original_glyphlist = original_glyphlist or []\n        self.incoming_glyphset = {}\n        self.final_glyphset = set()\n        self.blacklisted = set()\n        self.ufo2_features = None\n        self.ufo2_languagesystems = []\n    def __post_init__(self):\n        logger.info('UFOMerger initialized')"
        },
        {
            "key_id": 36,
            "fqn": "ufomerge/__init__.py/UFOMerger/merge",
            "imports": [
                "import logging",
                "from ufoLib2 import Font",
                "from typing import Iterable, Set, Dict, Tuple, Optional",
                "from ufomerge.utils import filter_glyphs, filter_glyph_mapping, filter_sequence, filter_glyph_container, has_any_empty_slots",
                "import fontFeatures"
            ],
            "code": "logger = logging.getLogger('ufomerge')\ndef merge(self):\n    logger.info('Merging UFOs')\n    # Filter glyphs based on the provided criteria\n    filtered_glyphs = filter_glyphs(self.glyphs, self.final_glyphset)\n    # Merge glyphs\n    for glyph_name in filtered_glyphs:\n        if glyph_name in self.ufo1 and self.existing_handling == 'skip':\n            continue\n        elif glyph_name in self.ufo1 and self.existing_handling == 'replace':\n            self.ufo1.removeGlyph(glyph_name)\n        self.ufo1.addGlyph(self.ufo2[glyph_name])\n    # Handle additional merging tasks such as kerning, features, etc.\n    self.merge_kerning()\n    # TODO: Implement additional merging logic here\n    logger.info('Merge completed')"
        },
        {
            "key_id": 42,
            "fqn": "ufomerge/__init__.py/UFOMerger/merge_dict",
            "imports": [
                "from typing import Any, Dict, Set",
                "from fontTools.ufoLib import UFOReader",
                "from ufoLib2.objects import Font",
                "import logging"
            ],
            "code": "def merge_dict(self, name: str, glyph: str, create_if_not_in_ufo1: bool = False) -> None:\n    logger = logging.getLogger('ufomerge')\n    if name not in self.ufo1.lib:\n        if create_if_not_in_ufo1:\n            self.ufo1.lib[name] = {}\n        else:\n            logger.warning(f'{name} not found in ufo1 lib; skipping.')\n            return\n    if name in self.ufo2.lib:\n        for key, value in self.ufo2.lib[name].items():\n            if key not in self.ufo1.lib[name]:\n                self.ufo1.lib[name][key] = value\n            else:\n                logger.info(f'Duplicate key {key} found in {name}; using value from ufo1.')"
        },
        {
            "key_id": 43,
            "fqn": "ufomerge/__init__.py/merge_ufos",
            "imports": [
                "from typing import Iterable, Optional",
                "from pathlib import Path",
                "from ufoLib2.objects import Font",
                "import logging"
            ],
            "code": "def merge_ufos(ufo1: Font, ufo2: Font, glyphs: Optional[Iterable[str]] = None, exclude_glyphs: Optional[Iterable[str]] = None, codepoints: Optional[Iterable[int]] = None, layout_handling: str = 'subset', existing_handling: str = 'replace', include_dir: Optional[Path] = None, original_glyphlist: Optional[Iterable[str]] = None) -> None:\n    logger = logging.getLogger('ufomerge')\n    merger = UFOMerger(ufo1, ufo2, glyphs, exclude_glyphs, codepoints, layout_handling, existing_handling, include_dir, original_glyphlist)\n    merger.merge()\n    logger.info('Merge completed successfully.')"
        },
        {
            "key_id": 44,
            "fqn": "ufomerge/__init__.py/subset_ufo",
            "imports": [
                "from typing import Iterable, Optional",
                "from pathlib import Path",
                "from ufoLib2.objects import Font",
                "import logging",
                "from ufomerge.layout import LayoutSubsetter"
            ],
            "code": "def subset_ufo(ufo: Font, glyphs: Optional[Iterable[str]] = None, exclude_glyphs: Optional[Iterable[str]] = None, codepoints: Optional[Iterable[int]] = None, layout_handling: str = 'subset', include_dir: Optional[Path] = None, original_glyphlist: Optional[Iterable[str]] = None) -> Font:\n    logger = logging.getLogger('ufomerge')\n    subsetter = LayoutSubsetter(ufo)\n    if glyphs or exclude_glyphs or codepoints:\n        subsetter.subset(glyphs=glyphs, exclude_glyphs=exclude_glyphs, codepoints=codepoints, layout_handling=layout_handling)\n    logger.info('Subsetting completed successfully.')\n    return ufo"
        }
    ]
}