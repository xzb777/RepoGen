{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "santorinai/board.py/Board/__init__",
            "imports": [
                "from typing import List",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class Board:\n    def __init__(self, number_of_players: int):\n        self.number_of_players = number_of_players\n        self.board = [[0 for _ in range(5)] for _ in range(5)]\n        self.pawns = [Pawn(i, i+1, (i % number_of_players) + 1) for i in range(number_of_players * 2)]\n        self.player_turn = 1\n        self.turn_number = 0"
        },
        {
            "key_id": 25,
            "fqn": "santorinai/pawn.py/Pawn/__init__",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "class Pawn:\n    def __init__(self, number: int, order: int, player_number: int):\n        self.number = number\n        self.order = order\n        self.player_number = player_number\n        self.pos = (None, None)"
        },
        {
            "key_id": 21,
            "fqn": "santorinai/player.py/Player/__init__",
            "imports": [
                "from abc import ABC, abstractmethod",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class Player(ABC):\n    def __init__(self, player_number: int, log_level=0):\n        self.player_number = player_number\n        self.log_level = log_level\n        self.pawns = []\n\n    @abstractmethod\n    def name(self):\n        pass\n\n    @abstractmethod\n    def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n        pass\n\n    @abstractmethod\n    def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n        pass"
        },
        {
            "key_id": 33,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/__init__",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class FirstChoicePlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n\n    def name(self):\n        return 'First Choice Player'\n\n    def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n        for x in range(5):\n            for y in range(5):\n                if board.is_position_valid((x, y)) and not board.is_pawn_on_position((x, y)):\n                    return (x, y)\n        return (None, None)\n\n    def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n        # Simplified logic for demonstration\n        return (1, (0, 0), (1, 1))"
        },
        {
            "key_id": 37,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/__init__",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n\n    def name(self):\n        return 'Random Player'\n\n    def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n        possible_positions = [(x, y) for x in range(5) for y in range(5) if board.is_position_valid((x, y)) and not board.is_pawn_on_position((x, y))]\n        return choice(possible_positions) if possible_positions else (None, None)\n\n    def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n        pawns = [pawn for pawn in self.pawns if pawn.pos != (None, None)]\n        pawn = choice(pawns)\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        return choice(possible_moves) if possible_moves else (None, (None, None), (None, None))"
        },
        {
            "key_id": 41,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/__init__",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice",
                "from typing import Tuple"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level = 0) -> None:\n        super().__init__(player_number, log_level)\n        # Initialization code specific to BasicPlayer\n        self.log_level = log_level\n        # You can add more initialization logic here"
        },
        {
            "key_id": 19,
            "fqn": "santorinai/board.py/Board/copy",
            "imports": [
                "from typing import List",
                "from copy import deepcopy",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def copy(self) -> 'Board':\n    new_board = Board(self.number_of_players)\n    new_board.board = deepcopy(self.board)\n    new_board.pawns = [pawn.copy() for pawn in self.pawns]\n    new_board.player_turn = self.player_turn\n    new_board.turn_number = self.turn_number\n    return new_board"
        },
        {
            "key_id": 20,
            "fqn": "santorinai/board.py/Board/__repr__",
            "imports": [],
            "code": "def __repr__(self) -> str:\n    board_str = ''\n    for row in self.board:\n        board_str += ' '.join(str(cell) for cell in row) + '\\n'\n    return board_str"
        },
        {
            "key_id": 1,
            "fqn": "santorinai/board.py/Board/is_move_possible",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_move_possible(self, start_pos: Tuple[int, int], end_pos: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_within_board(start_pos) or not self.is_position_within_board(end_pos):\n        return False, 'Position out of board'\n    if not self.is_position_adjacent(start_pos, end_pos):\n        return False, 'Positions not adjacent'\n    if self.is_pawn_on_position(end_pos):\n        return False, 'Position occupied by another pawn'\n    if abs(self.board[end_pos[0]][end_pos[1]] - self.board[start_pos[0]][start_pos[1]]) > 1:\n        return False, 'Move too high'\n    return True, ''"
        },
        {
            "key_id": 2,
            "fqn": "santorinai/board.py/Board/is_position_within_board",
            "imports": [],
            "code": "def is_position_within_board(self, position: Tuple[int, int]) -> bool:\n    return 0 <= position[0] < 5 and 0 <= position[1] < 5"
        },
        {
            "key_id": 3,
            "fqn": "santorinai/board.py/Board/is_position_adjacent",
            "imports": [],
            "code": "def is_position_adjacent(self, position1: Tuple[int, int], position2: Tuple[int, int]) -> bool:\n    return max(abs(position1[0] - position2[0]), abs(position1[1] - position2[1])) == 1"
        },
        {
            "key_id": 4,
            "fqn": "santorinai/board.py/Board/is_pawn_on_position",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_pawn_on_position(self, position: Tuple[int, int]) -> bool:\n    for pawn in self.pawns:\n        if pawn.pos == position:\n            return True\n    return False"
        },
        {
            "key_id": 5,
            "fqn": "santorinai/board.py/Board/is_build_possible",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_build_possible(self, builder_position: Tuple[int, int], build_position: Tuple[int, int]) -> bool:\n    if not self.is_position_adjacent(builder_position, build_position):\n        return False\n    if not self.is_position_valid(build_position):\n        return False\n    if self.is_pawn_on_position(build_position):\n        return False\n    return True"
        },
        {
            "key_id": 13,
            "fqn": "santorinai/board.py/Board/place_pawn",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def place_pawn(self, position: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_valid(position):\n        return False, 'Invalid position'\n    if self.is_pawn_on_position(position):\n        return False, 'Position already occupied'\n    self.pawns[self.player_turn - 1].move(position)\n    return True, 'Pawn placed successfully'"
        },
        {
            "key_id": 14,
            "fqn": "santorinai/board.py/Board/play_move",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def play_move(self, pawn_number: int, move_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_valid(move_position) or not self.is_position_valid(build_position):\n        return False, 'Invalid position(s)'\n    if not self.is_move_possible(self.pawns[pawn_number - 1].pos, move_position):\n        return False, 'Move not possible'\n    if not self.is_build_possible(move_position, build_position):\n        return False, 'Build not possible'\n    self.pawns[pawn_number - 1].move(move_position)\n    self.board[build_position[0]][build_position[1]] += 1\n    self.next_turn()\n    return True, 'Move and build successful'"
        },
        {
            "key_id": 15,
            "fqn": "santorinai/board.py/Board/is_position_valid",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_position_valid(self, pos: Tuple[int, int]) -> bool:\n    x, y = pos\n    if x < 0 or x >= 5 or y < 0 or y >= 5:\n        return False\n    return True"
        },
        {
            "key_id": 16,
            "fqn": "santorinai/board.py/Board/is_game_over",
            "imports": [],
            "code": "def is_game_over(self):\n    if self.is_everyone_stuck():\n        return True\n    for pawn in self.pawns:\n        if pawn.pos is not None and self.board[pawn.pos[0]][pawn.pos[1]] == 3:\n            return True\n    return False"
        },
        {
            "key_id": 17,
            "fqn": "santorinai/board.py/Board/is_everyone_stuck",
            "imports": [],
            "code": "def is_everyone_stuck(self):\n    for pawn in self.pawns:\n        if pawn.player_number == self.player_turn and len(self.get_possible_movement_and_building_positions(pawn)) > 0:\n            return False\n    return True"
        },
        {
            "key_id": 18,
            "fqn": "santorinai/board.py/Board/next_turn",
            "imports": [],
            "code": "def next_turn(self):\n    self.player_turn = (self.player_turn % self.number_of_players) + 1\n    self.turn_number += 1"
        },
        {
            "key_id": 26,
            "fqn": "santorinai/pawn.py/Pawn/move",
            "imports": [],
            "code": "def move(self, new_pos):\n    if new_pos[0] >= 0 and new_pos[0] < 5 and new_pos[1] >= 0 and new_pos[1] < 5:\n        self.pos = new_pos\n    else:\n        raise ValueError('Move position is out of the board')"
        },
        {
            "key_id": 27,
            "fqn": "santorinai/pawn.py/Pawn/copy",
            "imports": [],
            "code": "def copy(self):\n    new_pawn = Pawn(self.number, self.order, self.player_number)\n    new_pawn.pos = self.pos\n    return new_pawn"
        },
        {
            "key_id": 28,
            "fqn": "santorinai/pawn.py/Pawn/__repr__",
            "imports": [],
            "code": "def __repr__(self):\n    return f'Pawn{{number={self.number}, order={self.order}, player_number={self.player_number}, pos={self.pos}}}'"
        },
        {
            "key_id": 6,
            "fqn": "santorinai/board.py/Board/get_player_pawns",
            "imports": [
                "from santorinai.pawn import Pawn",
                "from typing import List"
            ],
            "code": "def get_player_pawns(self, player_number: int) -> List[Pawn]:\n    return [pawn for pawn in self.pawns if pawn.player_number == player_number]"
        },
        {
            "key_id": 7,
            "fqn": "santorinai/board.py/Board/get_player_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_player_pawn(self, player_number: int, pawn_number: int) -> Pawn:\n    for pawn in self.pawns:\n        if pawn.player_number == player_number and pawn.number == pawn_number:\n            return pawn\n    raise ValueError('Pawn not found')"
        },
        {
            "key_id": 8,
            "fqn": "santorinai/board.py/Board/get_playing_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_playing_pawn(self, pawn_number: int) -> Pawn:\n    for pawn in self.pawns:\n        if pawn.order == pawn_number and pawn.player_number == self.player_turn:\n            return pawn\n    raise ValueError('Playing pawn not found')"
        },
        {
            "key_id": 9,
            "fqn": "santorinai/board.py/Board/get_first_unplaced_player_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_first_unplaced_player_pawn(self, player_number: int) -> Pawn:\n    for pawn in self.pawns:\n        if pawn.player_number == player_number and pawn.pos == (None, None):\n            return pawn\n    raise ValueError('All pawns are already placed')"
        },
        {
            "key_id": 10,
            "fqn": "santorinai/board.py/Board/get_possible_movement_positions",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_possible_movement_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:\n        possible_positions = []\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        for dx, dy in directions:\n            new_x, new_y = pawn.pos[0] + dx, pawn.pos[1] + dy\n            if self.is_position_within_board((new_x, new_y)) and not self.is_pawn_on_position((new_x, new_y)) and self.is_position_adjacent(pawn.pos, (new_x, new_y)) and self.is_move_possible(pawn.pos, (new_x, new_y))[0]:\n                possible_positions.append((new_x, new_y))\n        return possible_positions"
        },
        {
            "key_id": 11,
            "fqn": "santorinai/board.py/Board/get_possible_building_positions",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_possible_building_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:\n        possible_positions = []\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        for dx, dy in directions:\n            new_x, new_y = pawn.pos[0] + dx, pawn.pos[1] + dy\n            if self.is_position_within_board((new_x, new_y)) and not self.is_pawn_on_position((new_x, new_y)) and self.is_build_possible(pawn.pos, (new_x, new_y)):\n                possible_positions.append((new_x, new_y))\n        return possible_positions"
        },
        {
            "key_id": 12,
            "fqn": "santorinai/board.py/Board/get_possible_movement_and_building_positions",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_possible_movement_and_building_positions(self, pawn: Pawn):\n        possible_moves_and_builds = []\n        possible_moves = self.get_possible_movement_positions(pawn)\n        for move in possible_moves:\n            self.pawns[pawn.order - 1].move(move)\n            possible_builds = self.get_possible_building_positions(pawn)\n            for build in possible_builds:\n                if self.is_build_possible(move, build):\n                    possible_moves_and_builds.append((move, build))\n            self.pawns[pawn.order - 1].move(pawn.pos)  # Move back to original position\n        return possible_moves_and_builds"
        },
        {
            "key_id": 22,
            "fqn": "santorinai/player.py/Player/name",
            "imports": [],
            "code": "def name(self):\n        return 'My Custom Player'"
        },
        {
            "key_id": 23,
            "fqn": "santorinai/player.py/Player/place_pawn",
            "imports": [
                "from typing import Tuple",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n        possible_positions = board.get_possible_movement_positions(pawn)\n        chosen_position = choice(possible_positions) if possible_positions else (None, None)\n        success, message = board.place_pawn(chosen_position)\n        if not success:\n            raise Exception(f'Failed to place pawn: {message}')\n        return chosen_position"
        },
        {
            "key_id": 24,
            "fqn": "santorinai/player.py/Player/play_move",
            "imports": [
                "from typing import Tuple",
                "from random import choice",
                "from santorinai.board import Board"
            ],
            "code": "def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n        pawns = [pawn for pawn in self.pawns if pawn.pos != (None, None)]\n        pawn = choice(pawns)\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        if not possible_moves:\n            return None, (None, None), (None, None)\n        move_choice = choice(possible_moves)\n        return pawn.order, move_choice[0], move_choice[1]"
        },
        {
            "key_id": 34,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/name",
            "imports": [],
            "code": "def name(self):\n        return 'First Choice Player'"
        },
        {
            "key_id": 35,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/place_pawn",
            "imports": [
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n        for x in range(5):\n            for y in range(5):\n                if board.is_position_valid((x, y)) and not board.is_pawn_on_position((x, y)):\n                    return (x, y)\n        return (None, None)"
        },
        {
            "key_id": 36,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/play_move",
            "imports": [
                "from santorinai.board import Board"
            ],
            "code": "def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n        # Simplified logic for demonstration\n        return (1, (0, 0), (1, 1))"
        },
        {
            "key_id": 38,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/name",
            "imports": [],
            "code": "def name(self):\n        return 'Random Player'"
        },
        {
            "key_id": 39,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/place_pawn",
            "imports": [
                "from random import choice",
                "from santorinai import Board, Pawn, Player"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n\n    def name(self):\n        return 'Random Player'\n\n    def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n        possible_positions = [(x, y) for x in range(5) for y in range(5) if board.is_position_valid((x, y)) and not board.is_pawn_on_position((x, y))]\n        return choice(possible_positions) if possible_positions else (None, None)"
        },
        {
            "key_id": 40,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/play_move",
            "imports": [
                "from random import choice",
                "from santorinai import Board, Pawn, Player"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n\n    def name(self):\n        return 'Random Player'\n\n    def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n        pawns = [pawn for pawn in self.pawns if pawn.pos != (None, None)]\n        pawn = choice(pawns)\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        return choice(possible_moves) if possible_moves else (None, (None, None), (None, None))"
        },
        {
            "key_id": 42,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/name",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level = 0) -> None:\n        super().__init__(player_number, log_level)\n\n    def name(self):\n        return 'Basic Player'"
        },
        {
            "key_id": 43,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_ally_pawn",
            "imports": [
                "from santorinai import Board, Pawn, Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level = 0) -> None:\n        super().__init__(player_number, log_level)\n\n    def get_ally_pawn(self, board: Board, our_pawn: Pawn) -> Tuple[Pawn, None]:\n        for pawn in board.get_player_pawns(self.player_number):\n            if pawn != our_pawn:\n                return pawn, None\n        return None, None"
        },
        {
            "key_id": 44,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_enemy_pawns",
            "imports": [
                "from santorinai import Board, Pawn, Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level = 0) -> None:\n        super().__init__(player_number, log_level)\n\n    def get_enemy_pawns(self, board: Board, our_pawn: Pawn):\n        enemy_pawns = []\n        for pawn in board.pawns:\n            if pawn.player_number != self.player_number:\n                enemy_pawns.append(pawn)\n        return enemy_pawns"
        },
        {
            "key_id": 45,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_winning_moves",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_winning_moves(self, board: Board, pawn: Pawn) -> List[Tuple[int, int, int, int]]:\n    possible_moves = board.get_possible_movement_and_building_positions(pawn)\n    winning_moves = []\n    for move_position, build_position in possible_moves:\n        if move_position[2] == 3:  # Checking if the move leads to a winning position\n            winning_moves.append((pawn.order, move_position[0], move_position[1], build_position))\n    return winning_moves"
        },
        {
            "key_id": 46,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/place_pawn",
            "imports": [
                "from typing import Tuple",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n    available_positions = [(x, y) for x in range(5) for y in range(5) if board.is_position_valid((x, y)) and not board.is_pawn_on_position((x, y))]\n    chosen_position = choice(available_positions) if available_positions else (None, None)\n    return chosen_position"
        },
        {
            "key_id": 47,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/play_move",
            "imports": [
                "from typing import Tuple",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n    pawns = board.get_player_pawns(self.player_number)\n    for pawn in pawns:\n        winning_moves = self.get_winning_moves(board, pawn)\n        if winning_moves:\n            return choice(winning_moves)\n    # If no winning move, choose a random valid move\n    possible_moves = [(pawn.order, move[0], move[1]) for pawn in pawns for move in board.get_possible_movement_and_building_positions(pawn)]\n    return choice(possible_moves) if possible_moves else (None, (None, None), (None, None))"
        },
        {
            "key_id": 29,
            "fqn": "santorinai/board_displayer/board_displayer.py/init_window",
            "imports": [
                "import PySimpleGUI as sg",
                "from santorinai.board import Board"
            ],
            "code": "def init_window(player_names):\n    layout = [[sg.Text('Santorini Game', justification='center')],\n              [sg.Graph(canvas_size=(800, 600), graph_bottom_left=(0,0), graph_top_right=(800, 600), background_color='white', key='graph')]]\n    window = sg.Window('Santorini', layout, finalize=True)\n    graph = window['graph']\n    for name in player_names:\n        graph.DrawText(name, (10, 10))  # Example placement\n    return window"
        },
        {
            "key_id": 30,
            "fqn": "santorinai/board_displayer/board_displayer.py/draw_isometric_cube",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def draw_isometric_cube(window: sg.Window, x, y, size, cube_height, color, line_color, line_width):\n    graph = window['graph']\n    points = [(x, y), (x + size, y + size), (x + size * 2, y), (x + size, y - size), (x, y)]  # Base square\n    for point in points:\n        graph.DrawLine(point, (point[0], point[1] + cube_height), color=line_color, width=line_width)\n    # Draw the top square\n    top_points = [(point[0], point[1] + cube_height) for point in points]\n    graph.DrawPolygon(top_points, fill_color=color, line_color=line_color)"
        },
        {
            "key_id": 31,
            "fqn": "santorinai/board_displayer/board_displayer.py/update_board",
            "imports": [
                "import PySimpleGUI as sg",
                "from santorinai.board import Board"
            ],
            "code": "def update_board(window: sg.Window, board: Board):\n    window.read(timeout=10)\n    for row in range(Board.SIZE):\n        for col in range(Board.SIZE):\n            tile = board.board[row][col]\n            color = 'white' if tile == 0 else 'grey'\n            if tile == 4:\n                color = 'blue'\n            x = col * TILE_SIZE + SIZE_X // 10\n            y = row * TILE_SIZE + SIZE_Y // 10\n            window[\"-CANVAS-\"] .draw_rectangle((x, y), (x + TILE_SIZE, y + TILE_SIZE), fill_color=color, line_color='black')\n    for pawn in board.pawns:\n        if pawn.pos is not None:\n            x, y = pawn.pos\n            x = x * TILE_SIZE + SIZE_X // 10\n            y = y * TILE_SIZE + SIZE_Y // 10\n            window[\"-CANVAS-\"] .draw_circle((x + TILE_SIZE // 2, y + TILE_SIZE // 2), TILE_SIZE // 4, fill_color=pawns_colors[pawn.player_number], line_color='black')\n    sg.Window.refresh(window)"
        },
        {
            "key_id": 32,
            "fqn": "santorinai/board_displayer/board_displayer.py/close_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def close_window(window):\n    window.close()"
        }
    ]
}