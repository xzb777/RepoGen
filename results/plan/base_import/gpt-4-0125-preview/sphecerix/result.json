{
    "implementation": [
        {
            "key_id": 19,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/__init__",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "def __init__(self, mol):\n    self.molecule = mol\n    self.operations = []"
        },
        {
            "key_id": 22,
            "fqn": "sphecerix/symmetry_operations.py/Operation/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "def __init__(self, name):\n    self.name = name\n    self.matrix = None\n    self.wigner_matrix = None"
        },
        {
            "key_id": 24,
            "fqn": "sphecerix/symmetry_operations.py/Identity/__init__",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D"
            ],
            "code": "def __init__(self):\n    super().__init__('Identity')\n    self.matrix = np.eye(3)\n    self.wigner_matrix = lambda l: np.eye(2*l+1)"
        },
        {
            "key_id": 27,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/__init__",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "def __init__(self):\n    super().__init__('Inversion')\n    self.matrix = np.diag([-1, -1, -1])\n    self.wigner_matrix = tesseral_wigner_D_mirror"
        },
        {
            "key_id": 30,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/__init__",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D"
            ],
            "code": "def __init__(self, label, axis, angle):\n    super().__init__(label)\n    self.axis = axis\n    self.angle = angle\n    self.matrix = R.from_rotvec(axis * angle).as_matrix()\n    self.wigner_matrix = lambda l: tesseral_wigner_D(l, R.from_rotvec(axis * angle))"
        },
        {
            "key_id": 33,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/__init__",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = np.array(normal) / np.linalg.norm(normal)\n        self.Robj = R.from_rotvec(np.pi * self.normal)\n        self.D = tesseral_wigner_D_mirror(self.Robj)\n        self.D_tesseral = None\n\n    def get_matrix(self):\n        return self.Robj.as_matrix()\n\n    def get_wigner_matrix(self, l):\n        if self.D_tesseral is None:\n            self.D_tesseral = tesseral_wigner_D(l, self.Robj)\n        return self.D_tesseral"
        },
        {
            "key_id": 36,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/__init__",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.wignerd import tesseral_wigner_D_improper"
            ],
            "code": "class ImproperRotation:\n    def __init__(self, label, axis, angle):\n        self.label = label\n        self.axis = np.array(axis) / np.linalg.norm(axis)\n        self.angle = angle\n        self.Robj = R.from_rotvec(self.axis * self.angle)\n        self.D = tesseral_wigner_D_improper(self.Robj)\n        self.D_tesseral = None\n\n    def get_matrix(self):\n        return self.Robj.as_matrix()\n\n    def get_wigner_matrix(self, l):\n        if self.D_tesseral is None:\n            self.D_tesseral = tesseral_wigner_D(l, self.Robj)\n        return self.D_tesseral"
        },
        {
            "key_id": 3,
            "fqn": "sphecerix/molecule.py/Molecule/__init__",
            "imports": [
                "import numpy as np",
                "from copy import deepcopy"
            ],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def __str__(self):\n        return f'Molecule: {self.name}, Atoms: {len(self.atoms)}, Basis Functions: {len(self.basis_functions)}'\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        position = np.array([x, y, z], dtype=float)\n        if unit == 'angstrom':\n            position *= 1.8897259886\n        self.atoms.append({'atom': atom, 'position': position})\n\n    def build_basis(self, molset):\n        # This method should be implemented to add basis functions based on the molecule set\n        pass"
        },
        {
            "key_id": 40,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.coefficients = None\n\n    def __get_name(self):\n        # This method should return the name of the basis function\n        pass\n\n    def __get_type(self):\n        # This method should return the type of the basis function\n        pass"
        },
        {
            "key_id": 7,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield",
            "imports": [
                "import numpy as np",
                "from math import factorial",
                "from scipy.special import assoc_laguerre",
                "from scipy.special import sph_harm"
            ],
            "code": "def wffield(n, l, m, d, npts):\n    r = np.linspace(0, d, npts)\n    theta, phi = np.mgrid[0:np.pi:npts*1j, 0:2*np.pi:npts*1j]\n    Ylm = sph_harm(m, l, phi, theta)\n    Rnl = np.sqrt((2/(n**2))**3 * factorial(n-l-1)/(2*n*factorial(n+l))) * np.exp(-r/n) * (2*r/n)**l * assoc_laguerre(2*r/n, n-l-1, 2*l+1)\n    psi = np.multiply(Rnl[:, None, None], Ylm)\n    return psi"
        },
        {
            "key_id": 8,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield_l",
            "imports": [
                "import numpy as np",
                "from math import factorial",
                "from scipy.special import assoc_laguerre",
                "from scipy.special import sph_harm"
            ],
            "code": "def wffield_l(n, l, d, npts):\n    r = np.linspace(0, d, npts)\n    psi_sum = np.zeros((npts, npts, npts), dtype=np.complex_)\n    for m in range(-l, l+1):\n        psi = wffield(n, l, m, d, npts)\n        psi_sum += np.abs(psi)**2\n    return psi_sum"
        },
        {
            "key_id": 9,
            "fqn": "sphecerix/atomic_wave_functions.py/wfcart",
            "imports": [
                "import numpy as np",
                "from math import factorial",
                "from scipy.special import assoc_laguerre",
                "from scipy.special import sph_harm"
            ],
            "code": "def wfcart(n, l, m, x, y, z):\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arccos(z/r)\n    phi = np.arctan2(y, x)\n    psi = wffield(n, l, m, r, len(r.flatten()))\n    return psi.reshape(x.shape)"
        },
        {
            "key_id": 10,
            "fqn": "sphecerix/atomic_wave_functions.py/wf",
            "imports": [
                "import numpy as np",
                "from math import factorial",
                "from scipy.special import assoc_laguerre",
                "from scipy.special import sph_harm"
            ],
            "code": "def wf(n, l, m, r, theta, phi):\n    Ylm = sph_harm(m, l, phi, theta)\n    Rnl = np.sqrt((2/(n**2))**3 * factorial(n-l-1)/(2*n*factorial(n+l))) * np.exp(-r/n) * (2*r/n)**l * assoc_laguerre(2*r/n, n-l-1, 2*l+1)\n    psi = Rnl * Ylm\n    return psi"
        },
        {
            "key_id": 11,
            "fqn": "sphecerix/atomic_wave_functions.py/angular",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def angular(l, m, theta, phi):\n    Ylm = sph_harm(m, l, phi, theta)\n    return Ylm"
        },
        {
            "key_id": 12,
            "fqn": "sphecerix/atomic_wave_functions.py/radial",
            "imports": [
                "import numpy as np",
                "from math import factorial",
                "from scipy.special import assoc_laguerre"
            ],
            "code": "def radial(n, l, r):\n    # Normalization constant\n    a0 = 1  # Bohr radius, for simplicity set to 1\n    rho = 2 * r / (n * a0)\n    normalization = np.sqrt((2 / (n * a0))**3 * factorial(n - l - 1) / (2 * n * factorial(n + l)))\n    # Radial part of the wave function\n    radial_part = normalization * np.exp(-rho / 2) * rho**l * assoc_laguerre(2 * rho, n - l - 1, 2 * l + 1)\n    return radial_part"
        },
        {
            "key_id": 13,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from tesseral import tesseral_transformation",
                "import warnings"
            ],
            "code": "def tesseral_wigner_D(l, Robj):\n    try:\n        D_matrix = tesseral_transformation(l)\n        rotation_matrix = Robj.as_matrix()\n        transformed_matrix = np.dot(np.dot(D_matrix, rotation_matrix), np.linalg.inv(D_matrix))\n        return transformed_matrix\n    except Exception as e:\n        warnings.warn(f'Error in calculating tesseral Wigner D matrix: {e}')\n        return None"
        },
        {
            "key_id": 14,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_mirror",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from tesseral import tesseral_transformation",
                "import warnings"
            ],
            "code": "def tesseral_wigner_D_mirror(l, normal):\n    try:\n        D_matrix = tesseral_transformation(l)\n        mirror_matrix = np.eye(3) - 2 * np.outer(normal, normal) / np.linalg.norm(normal)**2\n        transformed_matrix = np.dot(np.dot(D_matrix, mirror_matrix), np.linalg.inv(D_matrix))\n        return transformed_matrix\n    except Exception as e:\n        warnings.warn(f'Error in calculating tesseral Wigner D mirror matrix: {e}')\n        return None"
        },
        {
            "key_id": 15,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_improper",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from tesseral import tesseral_transformation",
                "import warnings"
            ],
            "code": "def tesseral_wigner_D_improper(l, Robj):\n    try:\n        D_matrix = tesseral_transformation(l)\n        improper_rotation_matrix = np.dot(Robj.as_matrix(), np.diag([1, 1, -1]))\n        transformed_matrix = np.dot(np.dot(D_matrix, improper_rotation_matrix), np.linalg.inv(D_matrix))\n        return transformed_matrix\n    except Exception as e:\n        warnings.warn(f'Error in calculating tesseral Wigner D improper rotation matrix: {e}')\n        return None"
        },
        {
            "key_id": 16,
            "fqn": "sphecerix/wignerd.py/wigner_D",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from tesseral import tesseral_transformation",
                "import warnings"
            ],
            "code": "def wigner_D(l, Robj):\n    try:\n        # This function is intended to provide a more general approach to calculating Wigner D matrices,\n        # possibly incorporating both proper and improper rotations, reflections, etc.\n        # For demonstration, it currently mirrors the tesseral_wigner_D function's behavior\n        D_matrix = tesseral_transformation(l)\n        rotation_matrix = Robj.as_matrix()\n        transformed_matrix = np.dot(np.dot(D_matrix, rotation_matrix), np.linalg.inv(D_matrix))\n        return transformed_matrix\n    except Exception as e:\n        warnings.warn(f'Error in calculating Wigner D matrix: {e}')\n        return None"
        },
        {
            "key_id": 17,
            "fqn": "sphecerix/wignerd.py/wigner_d",
            "imports": [
                "import numpy as np",
                "from scipy.special import factorial",
                "from scipy.spatial.transform import Rotation as R",
                "from tesseral import tesseral_transformation",
                "import warnings"
            ],
            "code": "def wigner_d(l, beta):\n    try:\n        d_matrix = np.zeros((2*l+1, 2*l+1))\n        for m in range(-l, l+1):\n            for mp in range(-l, l+1):\n                if abs(m-mp) <= l:\n                    d_matrix[m+l, mp+l] = np.sqrt(factorial(l+m)*factorial(l-m)*factorial(l+mp)*factorial(l-mp)) * np.cos(beta/2)**(2*l+m-mp) * np.sin(beta/2)**(mp-m)\n                else:\n                    d_matrix[m+l, mp+l] = 0\n        return d_matrix\n    except Exception as e:\n        warnings.warn(f'Error computing Wigner d matrix: {e}')\n        return np.zeros((2*l+1, 2*l+1))"
        },
        {
            "key_id": 18,
            "fqn": "sphecerix/wignerd.py/wigner_d_element_euler_angles",
            "imports": [
                "import numpy as np",
                "from scipy.special import factorial",
                "from scipy.spatial.transform import Rotation as R",
                "from tesseral import tesseral_transformation",
                "import warnings"
            ],
            "code": "def wigner_d_element_euler_angles(l, m1, m2, beta):\n    try:\n        element = np.sqrt(factorial(l+m1)*factorial(l-m1)*factorial(l+m2)*factorial(l-m2)) * np.cos(beta/2)**(2*l+m2-m1) * np.sin(beta/2)**(m1-m2)\n        return element\n    except Exception as e:\n        warnings.warn(f'Error computing Wigner d matrix element: {e}')\n        return 0"
        },
        {
            "key_id": 20,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/add",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from None import tesseral_wigner_D",
                "from None import tesseral_wigner_D_mirror"
            ],
            "code": "def __init__(self, mol):\n    self.molecule = mol\n    self.operations = []\n\ndef add(self, name, label = None, vec = None, angle = None):\n    operation = {'name': name, 'label': label, 'vec': vec, 'angle': angle}\n    self.operations.append(operation)"
        },
        {
            "key_id": 21,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/run",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from None import tesseral_wigner_D",
                "from None import tesseral_wigner_D_mirror"
            ],
            "code": "def __init__(self, mol):\n    self.molecule = mol\n    self.operations = []\n\ndef run(self):\n    for operation in self.operations:\n        print(f'Running {operation['name']} operation with label {operation['label']}, vector {operation['vec']}, and angle {operation['angle']}')"
        },
        {
            "key_id": 23,
            "fqn": "sphecerix/symmetry_operations.py/Operation/set_atomic_id",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from None import tesseral_wigner_D",
                "from None import tesseral_wigner_D_mirror"
            ],
            "code": "def __init__(self, name):\n    self.name = name\n    self.matrix = None\n    self.wigner_matrix = None\n\ndef set_atomic_id(self, idx):\n    self.atomic_id = idx\n    print(f'Set atomic ID for {self.name} operation to {idx}')"
        },
        {
            "key_id": 25,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "def get_matrix(self):\n    return np.eye(3)"
        },
        {
            "key_id": 26,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_wigner_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "def get_wigner_matrix(self, l):\n    return np.eye(2*l+1)"
        },
        {
            "key_id": 28,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "def get_matrix(self):\n    return np.diag([-1, -1, -1])"
        },
        {
            "key_id": 29,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_wigner_matrix",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D_mirror(l)"
        },
        {
            "key_id": 31,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_matrix",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "def get_matrix(self):\n    return R.from_rotvec(self.axis * self.angle).as_matrix()"
        },
        {
            "key_id": 32,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_wigner_matrix",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D"
            ],
            "code": "class Rotation:\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        self.matrix = R.from_rotvec(axis * angle).as_matrix()\n        self.wigner_matrix = lambda l: tesseral_wigner_D(l, R.from_rotvec(axis * angle))\n\n    def get_wigner_matrix(self, l):\n        return self.wigner_matrix(l)"
        },
        {
            "key_id": 34,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_matrix",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = np.array(normal) / np.linalg.norm(normal)\n        self.Robj = R.from_rotvec(np.pi * self.normal)\n        self.D = tesseral_wigner_D_mirror(self.Robj)\n        self.D_tesseral = None\n\n    def get_matrix(self):\n        return self.Robj.as_matrix()"
        },
        {
            "key_id": 35,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_wigner_matrix",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D"
            ],
            "code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = np.array(normal) / np.linalg.norm(normal)\n        self.Robj = R.from_rotvec(np.pi * self.normal)\n        self.D = tesseral_wigner_D_mirror(self.Robj)\n        self.D_tesseral = None\n\n    def get_wigner_matrix(self, l):\n        if self.D_tesseral is None:\n            self.D_tesseral = tesseral_wigner_D(l, self.Robj)\n        return self.D_tesseral"
        },
        {
            "key_id": 37,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/get_matrix",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D_improper"
            ],
            "code": "class ImproperRotation:\n    def __init__(self, label, axis, angle):\n        self.label = label\n        self.axis = np.array(axis) / np.linalg.norm(axis)\n        self.angle = angle\n        self.Robj = R.from_rotvec(self.axis * self.angle)\n        self.D = tesseral_wigner_D_improper(self.Robj)\n        self.D_tesseral = None\n\n    def get_matrix(self):\n        return self.Robj.as_matrix()"
        },
        {
            "key_id": 4,
            "fqn": "sphecerix/molecule.py/Molecule/__str__",
            "imports": [
                "import numpy as np",
                "from copy import deepcopy"
            ],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def __str__(self):\n        return f'Molecule: {self.name}, Atoms: {len(self.atoms)}, Basis Functions: {len(self.basis_functions)}'\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        position = np.array([x, y, z], dtype=float)\n        if unit == 'angstrom':\n            position *= 1.8897259886\n        self.atoms.append({'atom': atom, 'position': position})\n\n    def build_basis(self, molset):\n        # This method should be implemented to add basis functions based on the molecule set\n        pass"
        },
        {
            "key_id": 5,
            "fqn": "sphecerix/molecule.py/Molecule/add_atom",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def __str__(self):\n        return f'Molecule: {self.name}, Atoms: {len(self.atoms)}, Basis Functions: {len(self.basis_functions)}'\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        position = np.array([x, y, z], dtype=float)\n        if unit == 'angstrom':\n            position *= 1.8897259886\n        self.atoms.append({'atom': atom, 'position': position})"
        },
        {
            "key_id": 6,
            "fqn": "sphecerix/molecule.py/Molecule/build_basis",
            "imports": [
                "import numpy as np",
                "from sphecerix.atomic_wave_functions import wffield, wffield_l, wfcart, wf, angular, radial",
                "from sphecerix.basis_functions import BasisFunction"
            ],
            "code": "class Molecule:\n    def build_basis(self, molset):\n        for atom in self.atoms:\n            for orbital in molset.get('orbitals', []):\n                n, l, m = orbital['n'], orbital['l'], orbital['m']\n                basis_func = BasisFunction(n, l, m)\n                self.basis_functions.append(basis_func)"
        },
        {
            "key_id": 38,
            "fqn": "sphecerix/tesseral.py/tesseral_transformation",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D"
            ],
            "code": "def tesseral_transformation(l):\n    D = tesseral_wigner_D(l, None)  # Assuming Robj is handled within tesseral_wigner_D\n    # Transformation logic here, using D as needed\n    # This is a placeholder for the actual transformation logic\n    return D"
        },
        {
            "key_id": 39,
            "fqn": "sphecerix/tesseral.py/permutation_sh_car",
            "imports": [
                "import numpy as np"
            ],
            "code": "def permutation_sh_car():\n    # Assuming this function generates a permutation matrix for spherical harmonics to Cartesian\n    # This is a placeholder for the actual permutation logic\n    perm_matrix = np.eye(3)  # Placeholder for actual permutation matrix\n    return perm_matrix"
        },
        {
            "key_id": 41,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_name",
            "imports": [
                "import numpy as np"
            ],
            "code": "class BasisFunction:\n    def __get_name(self):\n        # Assuming this method generates a name for the basis function based on n, l, m\n        name = f'N={self.n}, L={self.l}, M={self.m}'\n        return name"
        },
        {
            "key_id": 42,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_type",
            "imports": [
                "import numpy as np"
            ],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.coefficients = None\n\n    def __get_name(self):\n        # This method should return the name of the basis function\n        pass\n\n    def __get_type(self):\n        # This method should return the type of the basis function\n        # Assuming the type is determined by the quantum number l\n        if self.l == 0:\n            return 's'\n        elif self.l == 1:\n            return 'p'\n        elif self.l == 2:\n            return 'd'\n        elif self.l == 3:\n            return 'f'\n        else:\n            return 'unknown'"
        },
        {
            "key_id": 0,
            "fqn": "sphecerix/matrixplot.py/visualize_matrices",
            "imports": [
                "import matplotlib.pyplot as plt",
                "import numpy as np",
                "import matplotlib.patches as patches"
            ],
            "code": "def visualize_matrices(symops, numcols = 3, highlight_groups = None, filename = None, figsize = (7,5), xlabelrot = 0):\n    fig, axs = plt.subplots(figsize=figsize)\n    numrows = len(symops) // numcols + (1 if len(symops) % numcols > 0 else 0)\n    for i, symop in enumerate(symops):\n        ax = fig.add_subplot(numrows, numcols, i + 1)\n        ax.imshow(np.random.rand(10, 10))  # Placeholder for actual matrix visualization\n        ax.set_title(f'SymOp {i+1}')\n    plt.tight_layout()\n    if filename:\n        plt.savefig(filename)\n    else:\n        plt.show()"
        },
        {
            "key_id": 1,
            "fqn": "sphecerix/matrixplot.py/plot_highlight_groups",
            "imports": [
                "import matplotlib.pyplot as plt",
                "import numpy as np",
                "import matplotlib.patches as patches"
            ],
            "code": "def plot_highlight_groups(axh, groups, mat):\n    for group in groups:\n        rect = patches.Rectangle((group['x'], group['y']), group['width'], group['height'], linewidth=1, edgecolor='r', facecolor='none')\n        axh.add_patch(rect)"
        },
        {
            "key_id": 2,
            "fqn": "sphecerix/matrixplot.py/plot_matrix",
            "imports": [
                "import matplotlib.pyplot as plt",
                "import numpy as np",
                "import matplotlib.patches as patches"
            ],
            "code": "def plot_matrix(ax, mat, bfs, title = None, xlabelrot = 0):\n    ax.imshow(mat)\n    ax.set_title(title)\n    ax.set_xticks(np.arange(len(bfs)))\n    ax.set_yticks(np.arange(len(bfs)))\n    ax.set_xticklabels(bfs)\n    ax.set_yticklabels(bfs)\n    plt.setp(ax.get_xticklabels(), rotation=xlabelrot, ha='right', rotation_mode='anchor')"
        },
        {
            "key_id": 43,
            "fqn": "docs/conf.py/setup",
            "imports": [
                "import os",
                "import sys",
                "import sphinx_rtd_theme"
            ],
            "code": "def setup(app):\n    app.add_css_file('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css')\n    app.add_html_theme('sphinx_rtd_theme', sphinx_rtd_theme.get_html_theme_path())"
        },
        {
            "key_id": 44,
            "fqn": "examples/fz3_rotation.py/main",
            "imports": [
                "import sys",
                "import os",
                "from sphecerix import tesseral_wigner_D_axis_angle",
                "from sphecerix import wffield_l",
                "import numpy as np",
                "from pytessel import PyTessel"
            ],
            "code": "def main():\n    # Define the rotation axis and angle\n    axis = np.array([1, 1, 1]) / np.sqrt(3)\n    angle = np.pi\n    \n    # Obtain the tesseral Wigner D matrix for the specified axis and angle\n    D = tesseral_wigner_D_axis_angle(3, axis, angle)\n    \n    # Initialize the spherical harmonic field\n    Y = wffield_l(3, 3, np.pi/4, 100)\n    \n    # Apply the rotation\n    Y_rotated = np.dot(D, Y)\n    \n    # Visualize the rotated field\n    tessel = PyTessel()\n    tessel.plot(Y_rotated)"
        },
        {
            "key_id": 45,
            "fqn": "examples/ethylene.py/main",
            "imports": [
                "import sys",
                "import os",
                "import numpy as np",
                "from sphecerix import Molecule",
                "from sphecerix import BasisFunction",
                "from sphecerix import SymmetryOperations",
                "from sphecerix import visualize_matrices"
            ],
            "code": "def main():\n    ethylene = Molecule('Ethylene')\n    ethylene.add_atom('C', 0.0, 0.0, 0.0)\n    ethylene.add_atom('C', 1.2, 0.0, 0.0)\n    ethylene.add_atom('H', -0.9, 0.9, 0.0)\n    ethylene.add_atom('H', -0.9, -0.9, 0.0)\n    ethylene.add_atom('H', 2.1, 0.9, 0.0)\n    ethylene.add_atom('H', 2.1, -0.9, 0.0)\n    \n    ethylene.build_basis('sto-3g')\n    \n    symops = SymmetryOperations(ethylene)\n    symops.add('C2', axis=[0,0,1], angle=np.pi)\n    symops.run()\n    \n    visualize_matrices(symops.get_matrices(), filename='ethylene_symmetry_matrices.png')"
        },
        {
            "key_id": 46,
            "fqn": "examples/dz2_rotation.py/main",
            "imports": [
                "import sys",
                "import os",
                "from sphecerix import tesseral_wigner_D_axis_angle",
                "from sphecerix import wffield_l",
                "import numpy as np",
                "from pytessel import PyTessel"
            ],
            "code": "def main():\n    # Define the rotation axis and angle\n    axis = np.array([1, 1, 1]) / np.sqrt(3)\n    angle = np.pi\n    \n    # Obtain the tesseral Wigner D matrix for the specified axis and angle\n    D = tesseral_wigner_D_axis_angle(2, axis, angle)\n    \n    # Initialize the spherical harmonic field for dz2\n    Y = wffield_l(2, 2, np.pi/4, 100)\n    \n    # Apply the rotation\n    Y_rotated = np.dot(D, Y)\n    \n    # Visualize the rotated field\n    tessel = PyTessel()\n    tessel.plot(Y_rotated)"
        },
        {
            "key_id": 47,
            "fqn": "examples/nh3.py/main",
            "imports": [
                "import sys",
                "import os",
                "import numpy as np",
                "from sphecerix import Molecule",
                "from sphecerix import BasisFunction",
                "from sphecerix import SymmetryOperations",
                "from sphecerix import visualize_matrices"
            ],
            "code": "def main():\n    ammonia = Molecule('Ammonia')\n    ammonia.add_atom('N', 0.0, 0.0, 0.0)\n    ammonia.add_atom('H', 0.94, 0.0, 0.38)\n    ammonia.add_atom('H', -0.47, 0.81, 0.38)\n    ammonia.add_atom('H', -0.47, -0.81, 0.38)\n    \n    ammonia.build_basis('sto-3g')\n    \n    symops = SymmetryOperations(ammonia)\n    symops.add('C3', axis=[0,0,1], angle=2*np.pi/3)\n    symops.run()\n    \n    visualize_matrices(symops.get_matrices(), filename='ammonia_symmetry_matrices.png')"
        }
    ]
}