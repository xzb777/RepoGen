{
    "implementation": [
        {
            "key_id": 14,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/__init__",
            "imports": [
                "import re",
                "import logging",
                "from dataclasses import dataclass",
                "from itertools import chain",
                "from typing import Dict, List, Optional, Tuple",
                "from parsimonious.nodes import Node",
                "from parsimonious.nodes import NodeVisitor",
                "from parsimonious.grammar import Grammar",
                "from maccarone.openai import ChatAPI"
            ],
            "code": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n    self.logger = logging.getLogger(__name__)\n    self.grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    self.raw_source = raw_source\n    self.block_at_line = block_at_line"
        },
        {
            "key_id": 3,
            "fqn": "examples/todo.py/Todo/__init__",
            "imports": [
                "import argparse",
                "import json",
                "import os"
            ],
            "code": "def __init__(self, description, status = 'not done', id = None):\n    self.description = description\n    self.status = status\n    self.id = id\n\n    todos = load_todos()\n    self.id = len(todos) + 1 if id is None else id\n    todos.append(self)\n    save_todos(todos)"
        },
        {
            "key_id": 11,
            "fqn": "src/maccarone/preprocessor.py/MissingPiece/get_line_pos",
            "imports": [
                "import re"
            ],
            "code": "def get_line_pos(self, raw_source: str) -> Tuple[int, int]:\n    matches = list(re.finditer(r'\\n', raw_source))\n    if not matches:\n        return (0, len(raw_source))\n    line_start = matches[-1].start() if matches else 0\n    line_end = len(raw_source)\n    return (line_start, line_end)"
        },
        {
            "key_id": 12,
            "fqn": "src/maccarone/preprocessor.py/MissingPiece/complete",
            "imports": [
                "from typing import Optional"
            ],
            "code": "def complete(self, replacement: Optional[str]) -> str:\n    if replacement is None:\n        return self.raw_source\n    start_pos, end_pos = self.get_line_pos(self.raw_source)\n    return self.raw_source[:start_pos] + replacement + self.raw_source[end_pos:]"
        },
        {
            "key_id": 13,
            "fqn": "src/maccarone/preprocessor.py/find_line_number",
            "imports": [
                "import re"
            ],
            "code": "def find_line_number(text: str, pos: int):\n    return text.count('\\n', 0, pos) + 1"
        },
        {
            "key_id": 15,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/generic_visit",
            "imports": [
                "from parsimonious.nodes import NodeVisitor, Node"
            ],
            "code": "def generic_visit(self, node: Node, visited_children: List[Node]):\n    self.logger.debug(f'Visiting node: {node.expr_name}')\n    return ''.join(visited_children or [])"
        },
        {
            "key_id": 16,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_maccarone",
            "imports": [],
            "code": "def visit_maccarone(self, node: Node, visited_children: list):\n    return ''.join(visited_children)"
        },
        {
            "key_id": 17,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_maccarone_chunk",
            "imports": [
                "import logging",
                "from parsimonious.grammar import Grammar",
                "from typing import Optional"
            ],
            "code": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n    self.logger = logging.getLogger(__name__)\n    self.grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    self.raw_source = raw_source\n    self.block_at_line = block_at_line\n\n    def visit_maccarone_chunk(self, node: Node, visited_children: list):\n        # This method will process maccarone chunks within the source code\n        # Implement the logic to handle maccarone chunks based on the grammar defined\n        self.logger.info('Visiting maccarone chunk')\n        # Example processing logic\n        # This should be replaced with actual logic to process the chunk\n        chunks = [child for child in visited_children if isinstance(child, Node)]\n        return ''.join([chunk.text for chunk in chunks])"
        },
        {
            "key_id": 18,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet",
            "imports": [
                "import logging",
                "from parsimonious.grammar import Grammar",
                "from typing import Optional"
            ],
            "code": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n    self.logger = logging.getLogger(__name__)\n    self.grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    self.raw_source = raw_source\n    self.block_at_line = block_at_line\n\n    def visit_snippet(self, node: Node, visited_children: list):\n        # This method will process snippets within the source code\n        self.logger.info('Visiting snippet')\n        # Example processing logic\n        # This should be replaced with actual logic to process the snippet\n        snippets = [child for child in visited_children if isinstance(child, Node)]\n        return ''.join([snippet.text for snippet in snippets])"
        },
        {
            "key_id": 19,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open",
            "imports": [
                "import logging",
                "from parsimonious.grammar import Grammar",
                "from typing import Optional"
            ],
            "code": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n    self.logger = logging.getLogger(__name__)\n    self.grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    self.raw_source = raw_source\n    self.block_at_line = block_at_line\n\n    def visit_snippet_open(self, node: Node, visited_children: list):\n        # This method will process the opening of snippets within the source code\n        self.logger.info('Visiting snippet open')\n        # Example processing logic\n        # This should be replaced with actual logic to process the opening of the snippet\n        open_snippets = [child for child in visited_children if isinstance(child, Node)]\n        return ''.join([open_snippet.text for open_snippet in open_snippets])"
        },
        {
            "key_id": 20,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open_single",
            "imports": [
                "import logging",
                "from parsimonious.grammar import Grammar",
                "from typing import Optional"
            ],
            "code": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n    self.logger = logging.getLogger(__name__)\n    self.grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    self.raw_source = raw_source\n    self.block_at_line = block_at_line\n\n    def visit_snippet_open_single(self, node: Node, visited_children: list):\n        # This method will process the single line opening of snippets within the source code\n        self.logger.info('Visiting single line snippet open')\n        # Example processing logic\n        # This should be replaced with actual logic to process the single line opening of the snippet\n        single_open_snippets = [child for child in visited_children if isinstance(child, Node)]\n        return ''.join([single_open_snippet.text for single_open_snippet in single_open_snippets])"
        },
        {
            "key_id": 21,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open_multi",
            "imports": [
                "import logging",
                "from parsimonious.grammar import Grammar",
                "from typing import Optional"
            ],
            "code": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n    self.logger = logging.getLogger(__name__)\n    self.grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    self.raw_source = raw_source\n    self.block_at_line = block_at_line\n\n    def visit_snippet_open_multi(self, node: Node, visited_children: list):\n        # This method will process the multi-line opening of snippets within the source code\n        self.logger.info('Visiting multi-line snippet open')\n        # Example processing logic\n        # This should be replaced with actual logic to process the multi-line opening of the snippet\n        multi_open_snippets = [child for child in visited_children if isinstance(child, Node)]\n        return ''.join([multi_open_snippet.text for multi_open_snippet in multi_open_snippets])"
        },
        {
            "key_id": 22,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_open",
            "imports": [
                "from parsimonious.nodes import Node",
                "import logging",
                "from parsimonious.grammar import Grammar"
            ],
            "code": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n    self.logger = logging.getLogger(__name__)\n    self.grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    self.raw_source = raw_source\n    self.block_at_line = block_at_line"
        },
        {
            "key_id": 23,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_line",
            "imports": [
                "from parsimonious.nodes import Node",
                "import logging"
            ],
            "code": "def visit_guidance_line(self, node: Node, visited_children: list):\n    # This method processes individual guidance lines within a multi-line guidance block\n    self.logger.debug('Visiting guidance line')\n    # Extract and process the guidance line content here\n    # Placeholder for guidance line processing logic\n    return node.text.strip()"
        },
        {
            "key_id": 24,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_lines",
            "imports": [
                "from parsimonious.nodes import Node",
                "import logging"
            ],
            "code": "def visit_guidance_lines(self, node: Node, visited_children: list):\n    # This method processes the collection of guidance lines in a snippet\n    self.logger.debug('Visiting guidance lines')\n    # Aggregate and process the guidance lines content here\n    # Placeholder for guidance lines aggregation logic\n    guidance_lines_content = '\\n'.join(child.text for child in visited_children)\n    return guidance_lines_content"
        },
        {
            "key_id": 25,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_inner",
            "imports": [
                "from parsimonious.nodes import Node",
                "import logging"
            ],
            "code": "def visit_guidance_inner(self, node: Node, visited_children: list):\n    # This method processes the inner content of a guidance block\n    self.logger.debug('Visiting guidance inner')\n    # Extract and process the inner content of the guidance here\n    # Placeholder for guidance inner content processing logic\n    return node.text.strip()"
        },
        {
            "key_id": 26,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_human_source",
            "imports": [
                "from parsimonious.nodes import Node",
                "import logging"
            ],
            "code": "def visit_human_source(self, node: Node, visited_children: list):\n    # This method processes the human-written source code segments\n    self.logger.debug('Visiting human source')\n    # Process and return the human-written source code here\n    # Placeholder for human source code processing logic\n    human_source_content = '\\n'.join(child.text for child in visited_children if child.text.strip())\n    return human_source_content"
        },
        {
            "key_id": 27,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_ai_source",
            "imports": [
                "import logging",
                "from parsimonious.grammar import Grammar"
            ],
            "code": "class RawSourceVisitor:\n    def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n        self.logger = logging.getLogger(__name__)\n        self.grammar = Grammar(\n            r\"\"\"\n            maccarone = human_source maccarone_chunk*\n            maccarone_chunk = snippet human_source?\n\n            snippet = snippet_open (ai_source snippet_close)?\n            snippet_open = snippet_open_single / snippet_open_multi\n            snippet_open_single = guidance_open guidance_inner \">>\" nl\n            snippet_open_multi = guidance_open nl guidance_lines guidance_close\n            snippet_close = ws \"#<</>>\" nl\n\n            guidance_open = ws \"#<<\"\n            guidance_close = ws \"#>>\" nl\n            guidance_line = ws \"#\" guidance_inner nl\n            guidance_lines = guidance_line+\n            guidance_inner = ~\"((?!>>).)*\"\n\n            human_source = source_line*\n            ai_source = source_line*\n            source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n            ws = ~\"[ \\t]*\"\n            nl = ws ~\"[\\r\\n]\"\n            \"\"\"\n        )\n        self.raw_source = raw_source\n        self.block_at_line = block_at_line\n\n    def visit_ai_source(self, node: Node, visited_children: list):\n        # Implementation for processing AI source code blocks\n        # This method would interact with the AI to fill in the delegated code sections\n        self.logger.info('Visiting AI source node')\n        # Example implementation detail, further logic needed based on AI interaction\n        return 'Processed AI source'"
        },
        {
            "key_id": 28,
            "fqn": "src/maccarone/preprocessor.py/raw_source_to_pieces",
            "imports": [
                "from typing import List",
                "from maccarone.preprocessor import Piece"
            ],
            "code": "def raw_source_to_pieces(input: str, block_at_line: Optional[int] = None) -> List[Piece]:\n    # Parses the raw source code into manageable pieces for further processing\n    # This function would likely use the Grammar defined in RawSourceVisitor to parse the source\n    # Example implementation, needs to be expanded with actual parsing logic\n    pieces = []\n    # Parsing logic goes here\n    return pieces"
        },
        {
            "key_id": 29,
            "fqn": "src/maccarone/preprocessor.py/raw_pieces_to_tagged_input",
            "imports": [],
            "code": "def raw_pieces_to_tagged_input(raw_pieces: List[Piece]) -> str:\n    # Converts raw pieces into a tagged input format for the AI\n    # This function prepares the data for AI processing\n    tagged_input = ''\n    # Conversion logic goes here\n    return tagged_input"
        },
        {
            "key_id": 30,
            "fqn": "src/maccarone/preprocessor.py/tagged_input_to_tagged_output",
            "imports": [
                "from maccarone.openai import ChatAPI"
            ],
            "code": "def tagged_input_to_tagged_output(tagged_input: str, chat_api: ChatAPI) -> str:\n    # Sends the tagged input to the AI and retrieves the tagged output\n    # This function interacts with the AI to process the input\n    tagged_output = chat_api.complete_chat(tagged_input)\n    # Example implementation, needs actual interaction logic with the AI\n    return tagged_output"
        },
        {
            "key_id": 31,
            "fqn": "src/maccarone/preprocessor.py/tagged_output_to_completed_pieces",
            "imports": [
                "from typing import Dict"
            ],
            "code": "def tagged_output_to_completed_pieces(tagged_output: str) -> Dict[int, str]:\n    # Processes the tagged output from the AI into completed code pieces\n    # This function converts AI output into a format that can be integrated back into the source code\n    completed_pieces = {}\n    # Processing logic to convert tagged output into completed pieces\n    return completed_pieces"
        },
        {
            "key_id": 32,
            "fqn": "src/maccarone/preprocessor.py/pieces_to_final_source",
            "imports": [
                "from typing import List, Dict",
                "from maccarone.preprocessor import Piece"
            ],
            "code": "def pieces_to_final_source(raw_pieces: List[Piece], completed_pieces: Dict[int, str]) -> str:\n    final_source = ''\n    for piece in raw_pieces:\n        if piece.line_number in completed_pieces:\n            final_source += completed_pieces[piece.line_number]\n        else:\n            final_source += piece.content\n    return final_source"
        },
        {
            "key_id": 33,
            "fqn": "src/maccarone/preprocessor.py/preprocess_maccarone",
            "imports": [
                "from maccarone.openai import ChatAPI",
                "from typing import Optional"
            ],
            "code": "def preprocess_maccarone(raw_source: str, chat_api: ChatAPI, block_at_line: Optional[int] = None) -> str:\n    # Assuming the existence of functions that handle the preprocessing logic\n    processed_source = '...'  # Placeholder for actual implementation\n    return processed_source"
        },
        {
            "key_id": 34,
            "fqn": "src/maccarone/openai.py/complete_chat",
            "imports": [
                "from typing import List, Dict, Callable",
                "import openai"
            ],
            "code": "def complete_chat(messages: List[Dict[str, str]], model = 'gpt-4', on_token: Callable[[int], None] = lambda p: None) -> str:\n    response = openai.Completion.create(\n        engine=model,\n        prompt=[msg['content'] for msg in messages],\n        max_tokens=150,\n        n=1,\n        stop=None,\n        temperature=0.5\n    )\n    return response.choices[0].text"
        },
        {
            "key_id": 35,
            "fqn": "src/maccarone/openai.py/ChatAPI/complete_chat",
            "imports": [
                "from typing import List, Dict"
            ],
            "code": "class ChatAPI:\n    def complete_chat(self, chat_name: str, messages: List[Dict[str, str]], model = 'gpt-4') -> str:\n        # Assuming the existence of a method to handle chat completion\n        completed_chat = '...'  # Placeholder for actual implementation\n        return completed_chat"
        },
        {
            "key_id": 38,
            "fqn": "src/maccarone/scripts/preprocess.py/parse_args",
            "imports": [
                "import argparse",
                "from typing import Namespace"
            ],
            "code": "def parse_args() -> Namespace:\n    parser = argparse.ArgumentParser(description='Process some integers.')\n    parser.add_argument('--path', type=str, help='Path to the file or directory')\n    parser.add_argument('--print', action='store_true', help='Print the processed output')\n    parser.add_argument('--rewrite', action='store_true', help='Rewrite the source file with processed output')\n    return parser.parse_args()"
        },
        {
            "key_id": 36,
            "fqn": "src/maccarone/scripts/preprocess.py/preprocess",
            "imports": [
                "import os",
                "import os.path",
                "import glob",
                "import logging",
                "from argparse import Namespace",
                "from typing import Optional",
                "from maccarone.openai import ChatAPI",
                "from maccarone.preprocessor import preprocess_maccarone"
            ],
            "code": "def preprocess(mn_path: str, print_: bool, rewrite: bool, block_at_line: Optional[int]) -> None:\n    logger = logging.getLogger(__name__)\n    if os.path.isdir(mn_path):\n        for file in glob.glob(os.path.join(mn_path, '*.py')):\n            try:\n                preprocess_maccarone(file, ChatAPI(), block_at_line)\n                if print_:\n                    with open(file, 'r') as f:\n                        print(f.read())\n                if rewrite:\n                    with open(file, 'w') as f:\n                        f.write(preprocess_maccarone(file, ChatAPI(), block_at_line))\n            except Exception as e:\n                logger.error(f'Error processing {file}: {e}')\n    else:\n        try:\n            output = preprocess_maccarone(mn_path, ChatAPI(), block_at_line)\n            if print_:\n                print(output)\n            if rewrite:\n                with open(mn_path, 'w') as f:\n                    f.write(output)\n        except Exception as e:\n            logger.error(f'Error processing {mn_path}: {e}')"
        },
        {
            "key_id": 37,
            "fqn": "src/maccarone/scripts/preprocess.py/main",
            "imports": [
                "import os",
                "import os.path",
                "import glob",
                "import logging",
                "from argparse import Namespace",
                "from typing import Optional",
                "from maccarone.openai import ChatAPI",
                "from maccarone.preprocessor import preprocess_maccarone",
                "import argparse"
            ],
            "code": "def main(path: str, print_: bool, rewrite: bool, suffix: str, block_at_line: Optional[int] = None) -> None:\n    logger = logging.getLogger(__name__)\n    args = parse_args()\n    if os.path.isdir(path):\n        for file in glob.glob(os.path.join(path, '*' + suffix)):\n            preprocess(file, args.print_, args.rewrite, args.block_at_line)\n    else:\n        preprocess(path, args.print_, args.rewrite, args.block_at_line)"
        },
        {
            "key_id": 39,
            "fqn": "src/maccarone/scripts/preprocess.py/script_main",
            "imports": [
                "import os",
                "import os.path",
                "import glob",
                "import logging",
                "from argparse import Namespace",
                "from typing import Optional",
                "from maccarone.openai import ChatAPI",
                "from maccarone.preprocessor import preprocess_maccarone",
                "import argparse"
            ],
            "code": "def script_main():\n    logger = logging.getLogger(__name__)\n    parser = argparse.ArgumentParser(description='Preprocess Python files using Maccarone.')\n    parser.add_argument('path', type=str, help='Path to the file or directory to preprocess.')\n    parser.add_argument('--print', dest='print_', action='store_true', help='Print the processed file to stdout.')\n    parser.add_argument('--rewrite', action='store_true', help='Rewrite the file in place.')\n    parser.add_argument('--suffix', type=str, default='.py', help='File suffix for preprocessing if a directory is given.')\n    parser.add_argument('--block-at-line', type=int, default=None, help='Process a specific block starting at the given line number.')\n    args = parser.parse_args()\n    main(args.path, args.print_, args.rewrite, args.suffix, args.block_at_line)"
        },
        {
            "key_id": 4,
            "fqn": "examples/todo.py/load_todos",
            "imports": [
                "import json",
                "import os"
            ],
            "code": "def load_todos() -> list[Todo]:\n    if not os.path.exists('todos.json'):\n        return []\n    with open('todos.json', 'r') as file:\n        todos_data = json.load(file)\n    return [Todo(description=todo['description'], status=todo['status'], id=todo['id']) for todo in todos_data]"
        },
        {
            "key_id": 5,
            "fqn": "examples/todo.py/save_todos",
            "imports": [
                "import json",
                "import os"
            ],
            "code": "def save_todos(todos: list[Todo]) -> None:\n    with open('todos.json', 'w') as file:\n        json.dump([{'description': todo.description, 'status': todo.status, 'id': todo.id} for todo in todos], file)"
        },
        {
            "key_id": 6,
            "fqn": "examples/todo.py/add_todo",
            "imports": [
                "import json",
                "import os"
            ],
            "code": "def add_todo(description):\n    todos_file = 'todos.json'\n    if not os.path.exists(todos_file):\n        todos = []\n    else:\n        with open(todos_file, 'r') as file:\n            todos = json.load(file)\n    todos.append({'description': description, 'status': 'not done'})\n    with open(todos_file, 'w') as file:\n        json.dump(todos, file, indent=4)"
        },
        {
            "key_id": 7,
            "fqn": "examples/todo.py/remove_todo",
            "imports": [
                "import json",
                "import os"
            ],
            "code": "def remove_todo(id):\n    todos_file = 'todos.json'\n    if not os.path.exists(todos_file):\n        print('Todo list is empty.')\n        return\n    with open(todos_file, 'r') as file:\n        todos = json.load(file)\n    todos = [todo for todo in todos if todo.get('id') != id]\n    with open(todos_file, 'w') as file:\n        json.dump(todos, file, indent=4)"
        },
        {
            "key_id": 8,
            "fqn": "examples/todo.py/print_todos",
            "imports": [
                "import json",
                "import os"
            ],
            "code": "def print_todos():\n    todos_file = 'todos.json'\n    if not os.path.exists(todos_file):\n        print('Todo list is empty.')\n        return\n    with open(todos_file, 'r') as file:\n        todos = json.load(file)\n    for todo in todos:\n        print(f\"{todo.get('id')}: {todo.get('description')} - {todo.get('status')}\")"
        },
        {
            "key_id": 9,
            "fqn": "examples/todo.py/main",
            "imports": [
                "import argparse",
                "import sys"
            ],
            "code": "def main():\n    parser = argparse.ArgumentParser(description='Manage your todos.')\n    parser.add_argument('--add', metavar='TODO', type=str, help='Add a new todo')\n    parser.add_argument('--remove', metavar='ID', type=int, help='Remove a todo by its ID')\n    parser.add_argument('--print', action='store_true', help='Print all todos')\n    args = parser.parse_args()\n\n    if args.add:\n        add_todo(args.add)\n    elif args.remove is not None:\n        remove_todo(args.remove)\n    elif args.print:\n        print_todos()\n    else:\n        print('No action specified.', file=sys.stderr)\n        sys.exit(1)"
        },
        {
            "key_id": 0,
            "fqn": "examples/file_sizes_ext.py/main",
            "imports": [
                "import argparse",
                "import os",
                "from typing import Optional"
            ],
            "code": "def main(path: str, extension: Optional[str] = None):\n    filenames = [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]\n    if extension:\n        filenames = [f for f in filenames if f.endswith(extension)]\n    for fn in filenames:\n        size = os.path.getsize(os.path.join(path, fn))\n        print(f'{fn} - {size} bytes')"
        },
        {
            "key_id": 10,
            "fqn": "examples/file_sizes.py/main",
            "imports": [
                "import os",
                "import argparse"
            ],
            "code": "def main(path: str):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('path', type=str, help='Directory path to list files sizes')\n    args = parser.parse_args()\n    filenames = [f for f in os.listdir(args.path) if os.path.isfile(os.path.join(args.path, f))]\n    for fn in filenames:\n        size = os.path.getsize(os.path.join(args.path, fn))\n        print(f'{fn}: {size} bytes')"
        },
        {
            "key_id": 1,
            "fqn": "examples/add.py/add_two_numbers",
            "imports": [
                "import argparse"
            ],
            "code": "def add_two_numbers(x, y):\n    return x + y\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('x', type=int, help='First number')\n    parser.add_argument('y', type=int, help='Second number')\n    args = parser.parse_args()\n    result = add_two_numbers(args.x, args.y)\n    print(f'The sum of {args.x} and {args.y} is {result}')"
        },
        {
            "key_id": 2,
            "fqn": "examples/fizzbuzz.py/main",
            "imports": [
                "import argparse"
            ],
            "code": "def main(n: int):\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            print('FizzBuzz')\n        elif i % 3 == 0:\n            print('Fizz')\n        elif i % 5 == 0:\n            print('Buzz')\n        else:\n            print(i)\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('n', type=int, help='Enter a number')\n    args = parser.parse_args()\n    main(args.n)"
        }
    ]
}