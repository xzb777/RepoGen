{
    "implementation": [
        {
            "key_id": 3,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/__init__",
            "imports": [
                "from typing import Union",
                "from nest.common.module import Module, ModuleCompiler",
                "from nest.core.pynest_container import PyNestContainer",
                "import logging",
                "from nest.common.exceptions import UnknownModuleException"
            ],
            "code": "def __init__(self, container: PyNestContainer, context_module: Union[Module, None] = None):\n    self.container = container\n    self.context_module = context_module\n    self._is_initialized = False\n    self._module_compiler = ModuleCompiler()\n    logging.info('PyNestApplicationContext initialized')"
        },
        {
            "key_id": 9,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/__init__",
            "imports": [
                "from nest.common.exceptions import CircularDependencyException, NoneInjectableException",
                "from nest.common.module import Module, ModuleCompiler, ModuleFactory, ModulesContainer, ModuleTokenFactory",
                "import logging",
                "from typing import Any, List, Optional, Union",
                "import click",
                "from injector import Injector, UnknownProvider, singleton",
                "from nest.common.constants import DEPENDENCIES, INJECTABLE_TOKEN",
                "from nest.common.exceptions import UnknownModuleException"
            ],
            "code": "def __init__(self):\n    self._instance = None\n    self._dependencies = {}\n    self.modules = ModulesContainer()\n    self.module_compiler = ModuleCompiler()\n    self.module_token_factory = ModuleTokenFactory()\n    logging.info('PyNestContainer initialized')"
        },
        {
            "key_id": 30,
            "fqn": "nest/core/pynest_application.py/PyNestApp/__init__",
            "imports": [
                "from typing import Any",
                "from fastapi import FastAPI",
                "from nest.core.pynest_app_context import PyNestApplicationContext",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.common.route_resolver import RoutesResolver"
            ],
            "code": "def __init__(self, container: PyNestContainer, http_server: FastAPI):\n    self.container = container\n    self.http_server = http_server\n    self._is_listening = False\n    self.application_context = PyNestApplicationContext(container)\n    RoutesResolver(self.http_server, self.container).resolve_routes()\n    logging.info('PyNestApp initialized and routes registered')"
        },
        {
            "key_id": 55,
            "fqn": "nest/core/decorators/module.py/Module/__init__",
            "imports": [
                "from nest.common.constants import ModuleMetadata"
            ],
            "code": "def __init__(self, imports=None, controllers=None, providers=None, exports=None, is_global: bool = False):\n    self.imports = imports or []\n    self.controllers = controllers or []\n    self.providers = providers or []\n    self.exports = exports or []\n    self.is_global = is_global\n    ModuleMetadata.register_module(self)"
        },
        {
            "key_id": 63,
            "fqn": "nest/core/database/base_config.py/ConfigFactoryBase/__init__",
            "imports": [
                "from abc import abstractmethod"
            ],
            "code": "def __init__(self, db_type: str):\n    self.db_type = db_type\n    @abstractmethod\n    def get_config(self):\n        pass\n    logging.info(f'ConfigFactoryBase for {db_type} initialized')"
        },
        {
            "key_id": 66,
            "fqn": "nest/core/database/base_config.py/BaseProvider/__init__",
            "imports": [
                "from abc import ABC, abstractmethod"
            ],
            "code": "class BaseProvider(ABC):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n\n    @abstractmethod\n    def get_engine_url(self) -> str:\n        raise NotImplementedError('Subclasses must implement get_engine_url method')"
        },
        {
            "key_id": 68,
            "fqn": "nest/core/database/odm_provider.py/OdmProvider/__init__",
            "imports": [
                "from typing import List",
                "from beanie import Document",
                "from beanie import init_beanie",
                "from motor.motor_asyncio import AsyncIOMotorClient",
                "from nest.core.database.odm_config import ConfigFactory"
            ],
            "code": "class OdmProvider:\n    def __init__(self, db_type = 'mongodb', config_params: dict = None, document_models: List[Document] = None):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.document_models = document_models\n        config_factory = ConfigFactory(db_type)\n        self.config_url = config_factory.get_config().get_engine_url()\n        self.client = AsyncIOMotorClient(self.config_url)\n\n    async def init_beanie(self):\n        await init_beanie(database=self.client[self.db_name], document_models=self.document_models)"
        },
        {
            "key_id": 70,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/__init__",
            "imports": [
                "from abc import ABC, abstractmethod",
                "from contextlib import asynccontextmanager",
                "from typing import Any, Dict",
                "from sqlalchemy import create_engine",
                "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine",
                "from sqlalchemy.ext.asyncio import async_sessionmaker",
                "from sqlalchemy.orm import DeclarativeBase, Session, sessionmaker",
                "from nest.core.database.orm_config import AsyncConfigFactory, ConfigFactory"
            ],
            "code": "class BaseOrmProvider(ABC):\n    def __init__(self, db_type: str = 'postgresql', config_params: dict = None, async_mode: bool = False, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.async_mode = async_mode\n        if async_mode:\n            config_factory = AsyncConfigFactory(db_type)\n        else:\n            config_factory = ConfigFactory(db_type)\n        self.engine_url = config_factory.get_config().get_engine_url()\n        if async_mode:\n            self.engine = create_async_engine(self.engine_url)\n        else:\n            self.engine = create_engine(self.engine_url)\n\n    @abstractmethod\n    def get_db(self):\n        raise NotImplementedError('Subclasses must implement get_db method')"
        },
        {
            "key_id": 74,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/__init__",
            "imports": [
                "from nest.core.database.orm_config import ConfigFactory",
                "from sqlalchemy import create_engine",
                "from sqlalchemy.orm import sessionmaker"
            ],
            "code": "class OrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: dict = None):\n        self.db_type = db_type\n        self.config_params = config_params\n        config_factory = ConfigFactory(db_type)\n        self.engine_url = config_factory.get_config().get_engine_url()\n        self.engine = create_engine(self.engine_url)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)\n\n    def get_db(self):\n        db = self.SessionLocal()\n        try:\n            yield db\n        finally:\n            db.close()"
        },
        {
            "key_id": 78,
            "fqn": "nest/core/database/orm_provider.py/AsyncOrmProvider/__init__",
            "imports": [
                "from contextlib import asynccontextmanager",
                "from nest.core.database.orm_config import AsyncConfigFactory",
                "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession",
                "from sqlalchemy.ext.asyncio import async_sessionmaker"
            ],
            "code": "class AsyncOrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: dict = None, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        config_factory = AsyncConfigFactory(db_type)\n        self.engine_url = config_factory.get_config().get_engine_url()\n        self.engine = create_async_engine(self.engine_url)\n        self.AsyncSessionLocal = async_sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    @asynccontextmanager\n    async def get_db(self):\n        async with self.AsyncSessionLocal() as session:\n            yield session"
        },
        {
            "key_id": 79,
            "fqn": "nest/core/database/odm_config.py/MongoDBConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider",
                "from nest.core.database.base_config import ConfigFactoryBase"
            ],
            "code": "class MongoDBConfig(BaseProvider, ConfigFactoryBase):\n    def __init__(self, host: str, db_name: str, user: str = None, password: str = None, port: int = 27017, srv: bool = False):\n        BaseProvider.__init__(self, host=host, db_name=db_name, user=user, password=password, port=port)\n        self.srv = srv\n        self.engine_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        if self.srv:\n            return f'mongodb+srv://{self.user}:{self.password}@{self.host}/{self.db_name}'\n        else:\n            return f'mongodb://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 81,
            "fqn": "nest/core/database/odm_config.py/ConfigFactory/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider",
                "from nest.core.database.base_config import ConfigFactoryBase"
            ],
            "code": "class ConfigFactory(ConfigFactoryBase):\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n        self.config = self.get_config()\n\n    def get_config(self):\n        if self.db_type == 'mongodb':\n            return MongoDBConfig\n        else:\n            raise ValueError(f'Unsupported database type: {self.db_type}')"
        },
        {
            "key_id": 83,
            "fqn": "nest/core/database/orm_config.py/PostgresConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseConfig",
                "from nest.core.database.base_config import BaseProvider",
                "from nest.core.database.base_config import ConfigFactoryBase"
            ],
            "code": "class PostgresConfig(BaseConfig, BaseProvider, ConfigFactoryBase):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        BaseProvider.__init__(self, host=host, db_name=db_name, user=user, password=password, port=port)\n        self.engine_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        return f'postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 85,
            "fqn": "nest/core/database/orm_config.py/MySQLConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseConfig",
                "from nest.core.database.base_config import BaseProvider",
                "from nest.core.database.base_config import ConfigFactoryBase"
            ],
            "code": "class MySQLConfig(BaseConfig, BaseProvider, ConfigFactoryBase):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        BaseProvider.__init__(self, host=host, db_name=db_name, user=user, password=password, port=port)\n        self.engine_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        return f'mysql+pymysql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 87,
            "fqn": "nest/core/database/orm_config.py/SQLiteConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseConfig",
                "from nest.core.database.base_config import BaseProvider",
                "from nest.core.database.base_config import ConfigFactoryBase"
            ],
            "code": "class SQLiteConfig(BaseConfig, BaseProvider, ConfigFactoryBase):\n    def __init__(self, db_name: str):\n        self.db_name = db_name\n        self.engine_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        return f'sqlite:///{self.db_name}'"
        },
        {
            "key_id": 89,
            "fqn": "nest/core/database/orm_config.py/AsyncSQLiteConfig/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from nest.core.database.base_config import BaseConfig"
            ],
            "code": "class AsyncSQLiteConfig(BaseConfig):\n    def __init__(self, db_name: str):\n        self.db_name = db_name\n        self.engine_url = f'sqlite+aiosqlite:///{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)"
        },
        {
            "key_id": 91,
            "fqn": "nest/core/database/orm_config.py/AsyncPostgresConfig/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from nest.core.database.base_config import BaseConfig"
            ],
            "code": "class AsyncPostgresConfig(BaseConfig):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine_url = f'postgresql+asyncpg://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)"
        },
        {
            "key_id": 93,
            "fqn": "nest/core/database/orm_config.py/AsyncMySQLConfig/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from nest.core.database.base_config import BaseConfig"
            ],
            "code": "class AsyncMySQLConfig(BaseConfig):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine_url = f'mysql+aiomysql://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)"
        },
        {
            "key_id": 95,
            "fqn": "nest/core/database/orm_config.py/ConfigFactory/__init__",
            "imports": [
                "from nest.core.database.orm_config import AsyncSQLiteConfig",
                "from nest.core.database.orm_config import AsyncPostgresConfig",
                "from nest.core.database.orm_config import AsyncMySQLConfig"
            ],
            "code": "class ConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n        self.config = None\n        if db_type == 'sqlite':\n            self.config = AsyncSQLiteConfig('database.db')\n        elif db_type == 'postgresql':\n            self.config = AsyncPostgresConfig(host='localhost', db_name='test_db', user='user', password='password', port=5432)\n        elif db_type == 'mysql':\n            self.config = AsyncMySQLConfig(host='localhost', db_name='test_db', user='user', password='password', port=3306)\n\n    def get_config(self):\n        return self.config"
        },
        {
            "key_id": 97,
            "fqn": "nest/core/database/orm_config.py/AsyncConfigFactory/__init__",
            "imports": [
                "from nest.core.database.orm_config import AsyncSQLiteConfig",
                "from nest.core.database.orm_config import AsyncPostgresConfig",
                "from nest.core.database.orm_config import AsyncMySQLConfig"
            ],
            "code": "class AsyncConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n        self.config = None\n        if db_type == 'sqlite':\n            self.config = AsyncSQLiteConfig('database.db')\n        elif db_type == 'postgresql':\n            self.config = AsyncPostgresConfig(host='localhost', db_name='test_db', user='user', password='password', port=5432)\n        elif db_type == 'mysql':\n            self.config = AsyncMySQLConfig(host='localhost', db_name='test_db', user='user', password='password', port=3306)\n\n    def get_config(self):\n        return self.config"
        },
        {
            "key_id": 0,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
            "imports": [
                "from typing import Union",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.common.module import ModuleCompiler",
                "import logging"
            ],
            "code": "def is_initialized(self) -> bool:\n    return self._is_initialized"
        },
        {
            "key_id": 1,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
            "imports": [
                "from typing import Union",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.common.module import ModuleCompiler",
                "import logging"
            ],
            "code": "def is_initialized(self, value: bool) -> None:\n    self._is_initialized = value\n    logging.info(f'PyNestApplicationContext initialization status set to {value}')"
        },
        {
            "key_id": 2,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/init",
            "imports": [
                "from typing import Union",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.common.module import ModuleCompiler",
                "import logging"
            ],
            "code": "def init(self) -> None:\n    if not self._is_initialized:\n        self._module_compiler.compile(self.container, self.context_module)\n        self._is_initialized = True\n        logging.info('PyNestApplicationContext initialized')"
        },
        {
            "key_id": 4,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/select_context_module",
            "imports": [
                "from typing import Union",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.common.module import ModuleCompiler",
                "import logging"
            ],
            "code": "def select_context_module(self) -> None:\n    if self.context_module is None:\n        logging.error('No context module selected')\n        raise ValueError('A context module must be selected for the application context')\n    logging.info(f'Selected context module: {self.context_module}')"
        },
        {
            "key_id": 5,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/select",
            "imports": [
                "from typing import TypeVar, Union",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.common.module import ModuleCompiler",
                "import logging"
            ],
            "code": "T = TypeVar('T')\n\ndef select(self, module: T) -> T:\n    try:\n        selected_module = self.container.get_instance(module)\n        logging.info(f'Module {module} selected')\n        return selected_module\n    except Exception as e:\n        logging.error(f'Error selecting module {module}: {str(e)}')\n        raise"
        },
        {
            "key_id": 6,
            "fqn": "nest/core/pynest_factory.py/PyNestFactory/create",
            "imports": [
                "from typing import Type",
                "from fastapi import FastAPI",
                "from nest.core.pynest_application import PyNestApp",
                "from nest.core.pynest_container import PyNestContainer"
            ],
            "code": "def create(main_module: Type[ModuleType], **kwargs) -> PyNestApp:\n    container = PyNestContainer()\n    app = _create_server(**kwargs)\n    return PyNestApp(container=container, http_server=app)"
        },
        {
            "key_id": 7,
            "fqn": "nest/core/pynest_factory.py/PyNestFactory/_create_server",
            "imports": [
                "from fastapi import FastAPI"
            ],
            "code": "def _create_server(**kwargs) -> FastAPI:\n    app = FastAPI(**kwargs)\n    # Additional server configuration can be done here\n    return app"
        },
        {
            "key_id": 8,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/__new__",
            "imports": [
                "from nest.common.module import ModulesContainer",
                "from nest.common.module import ModuleCompiler",
                "from nest.common.module import ModuleTokenFactory",
                "import logging"
            ],
            "code": "def __new__(cls):\n    if not hasattr(cls, '_instance') or not cls._instance:\n        cls._instance = super(PyNestContainer, cls).__new__(cls)\n        cls._dependencies = {}\n        cls.modules = ModulesContainer()\n        cls.module_compiler = ModuleCompiler()\n        cls.module_token_factory = ModuleTokenFactory()\n        logging.info('PyNestContainer initialized')\n    return cls._instance"
        },
        {
            "key_id": 10,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/modules",
            "imports": [],
            "code": "def modules(self):\n    return self.modules.all()"
        },
        {
            "key_id": 11,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/module_token_factory",
            "imports": [],
            "code": "def module_token_factory(self):\n    return self.module_token_factory"
        },
        {
            "key_id": 12,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/modules_metadata",
            "imports": [
                "from typing import List",
                "from nest.common.module import Module",
                "from nest.common.exceptions import CircularDependencyException",
                "import logging"
            ],
            "code": "def modules_metadata(self) -> List[Module]:\n    try:\n        return [module for module in self.modules.all()]\n    except CircularDependencyException as e:\n        logging.error(f'Error while accessing modules metadata: {str(e)}')\n        raise"
        },
        {
            "key_id": 13,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/module_compiler",
            "imports": [
                "from nest.common.module import ModuleCompiler",
                "import logging"
            ],
            "code": "def module_compiler(self):\n    try:\n        self.module_compiler.compile(self.modules)\n        logging.info('Modules compiled successfully')\n    except Exception as e:\n        logging.error(f'Error during module compilation: {str(e)}')\n        raise"
        },
        {
            "key_id": 14,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/get_instance",
            "imports": [
                "from typing import TypeVar, Union",
                "from injector import Injector, singleton",
                "from nest.common.exceptions import NoneInjectableException",
                "TProvider = TypeVar('TProvider')",
                "TController = TypeVar('TController')",
                "import logging"
            ],
            "code": "def get_instance(self, dependency: TProvider, provider: Union[TProvider, TController, None] = None):\n    try:\n        if provider is None:\n            return Injector().get(dependency, scope=singleton)\n        else:\n            return Injector().get(provider, scope=singleton)\n    except NoneInjectableException as e:\n        logging.error(f'Error getting instance for {dependency}: {str(e)}')\n        raise"
        },
        {
            "key_id": 15,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_module",
            "imports": [
                "from nest.common.module import ModuleFactory",
                "import logging"
            ],
            "code": "def add_module(self, metaclass) -> dict:\n    try:\n        module = ModuleFactory.create(metaclass)\n        self.modules.add(module)\n        logging.info(f'Module {metaclass.__name__} added successfully')\n        return {'module': module}\n    except Exception as e:\n        logging.error(f'Error adding module {metaclass}: {str(e)}')\n        raise"
        },
        {
            "key_id": 16,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/register_module",
            "imports": [
                "from nest.common.module import ModuleFactory, Module",
                "import logging"
            ],
            "code": "def register_module(self, module_factory: ModuleFactory) -> Module:\n    try:\n        module = module_factory()\n        self.modules.add(module)\n        logging.info(f'Module {module.__class__.__name__} registered successfully')\n        return module\n    except Exception as e:\n        logging.error(f'Error registering module via factory {module_factory}: {str(e)}')\n        raise"
        },
        {
            "key_id": 17,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_metadata",
            "imports": [
                "from nest.common.module import Module"
            ],
            "code": "def add_metadata(self, token: str, module_metadata) -> None:\n    if token not in self._dependencies:\n        self._dependencies[token] = module_metadata\n    else:\n        logging.warning(f'Metadata for token {token} already exists.')"
        },
        {
            "key_id": 18,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_import",
            "imports": [
                "from nest.common.exceptions import UnknownModuleException"
            ],
            "code": "def add_import(self, token: str):\n    try:\n        module = self.modules.get_module_by_token(token)\n        if not module:\n            raise UnknownModuleException(f'Module {token} not found')\n        logging.info(f'Importing module {token}')\n    except UnknownModuleException as e:\n        logging.error(f'Error importing module: {e}')"
        },
        {
            "key_id": 19,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_modules",
            "imports": [
                "from typing import List"
            ],
            "code": "def add_modules(self, modules: List[Any]) -> None:\n    for module in modules:\n        token = self.module_token_factory(module)\n        if token not in self._dependencies:\n            self.add_module(module)\n        else:\n            logging.info(f'Module {token} already exists in dependencies.')"
        },
        {
            "key_id": 20,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_providers",
            "imports": [
                "from typing import List"
            ],
            "code": "def add_providers(self, providers: List[Any], module_token: str) -> None:\n    if module_token not in self._dependencies:\n        logging.error(f'Module {module_token} not found in dependencies.')\n        return\n    for provider in providers:\n        self.add_provider(module_token, provider)"
        },
        {
            "key_id": 21,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_provider",
            "imports": [],
            "code": "def add_provider(self, token: str, provider):\n    if token not in self._dependencies:\n        self._dependencies[token] = []\n    self._dependencies[token].append(provider)\n    logging.info(f'Provider {provider} added to module {token}')"
        },
        {
            "key_id": 22,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_get_providers",
            "imports": [
                "from typing import List",
                "from nest.common.exceptions import CircularDependencyException",
                "from nest.common.exceptions import NoneInjectableException",
                "from nest.common.module import Module"
            ],
            "code": "def _get_providers(self, token: str) -> List[Any]:\n    try:\n        module = self.modules.get_module_by_token(token)\n        if not module:\n            raise NoneInjectableException(f'No module found for token: {token}')\n        return module.providers\n    except CircularDependencyException as e:\n        logging.error(f'Circular dependency detected: {e}')\n        raise"
        },
        {
            "key_id": 23,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_controllers",
            "imports": [
                "from typing import List",
                "from nest.common.module import Module"
            ],
            "code": "def add_controllers(self, controllers: List[Any], module_token: str) -> None:\n    if module_token not in self.modules:\n        logging.error(f'Module token {module_token} not found')\n        return\n    module = self.modules[module_token]\n    for controller in controllers:\n        module.add_controller(controller)\n    logging.info(f'Controllers added to module {module_token}')"
        },
        {
            "key_id": 24,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_add_controller",
            "imports": [
                "from nest.common.exceptions import CircularDependencyException",
                "from nest.common.exceptions import NoneInjectableException"
            ],
            "code": "def _add_controller(self, token: str, controller: TController) -> None:\n    try:\n        if token not in self.modules:\n            raise NoneInjectableException(f'No module found for token: {token}')\n        self.modules[token].add_controller(controller)\n        logging.info(f'Controller {controller} added to module {token}')\n    except CircularDependencyException as e:\n        logging.error(f'Circular dependency detected while adding controller: {e}')\n        raise"
        },
        {
            "key_id": 25,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_get_controllers",
            "imports": [
                "from typing import List",
                "from nest.common.exceptions import CircularDependencyException",
                "from nest.common.exceptions import NoneInjectableException",
                "from nest.common.module import Module"
            ],
            "code": "def _get_controllers(self, token: str) -> List[Any]:\n    try:\n        module = self.modules.get_module_by_token(token)\n        if not module:\n            raise NoneInjectableException(f'No module found for token: {token}')\n        return module.controllers\n    except CircularDependencyException as e:\n        logging.error(f'Circular dependency detected: {e}')\n        raise"
        },
        {
            "key_id": 26,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/clear",
            "imports": [
                "from nest.common.module import Module"
            ],
            "code": "def clear(self):\n    self.modules.clear()\n    self._dependencies.clear()\n    logging.info('PyNestContainer cleared')"
        },
        {
            "key_id": 27,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_related_module",
            "imports": [
                "from typing import Any, List",
                "from nest.common.module import Module",
                "from nest.common.exceptions import CircularDependencyException",
                "import logging"
            ],
            "code": "def add_related_module(self, related_module, token: str) -> None:\n    if token in self._dependencies:\n        raise CircularDependencyException(f'Module {token} already exists in dependencies')\n    try:\n        module_instance = related_module()\n        self._dependencies[token] = module_instance\n        logging.info(f'Module {token} added successfully')\n    except Exception as e:\n        logging.error(f'Error adding module {token}: {e}')\n        raise e"
        },
        {
            "key_id": 28,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/get_module_by_key",
            "imports": [
                "from nest.common.module import Module",
                "from nest.common.exceptions import UnknownModuleException",
                "import logging"
            ],
            "code": "def get_module_by_key(self, module_key: str) -> Module:\n    try:\n        return self._dependencies[module_key]\n    except KeyError:\n        logging.error(f'Module {module_key} not found')\n        raise UnknownModuleException(f'Module {module_key} not found')"
        },
        {
            "key_id": 29,
            "fqn": "nest/core/pynest_application.py/PyNestApp/is_listening",
            "imports": [
                "import logging"
            ],
            "code": "def is_listening(self) -> bool:\n    return self._is_listening"
        },
        {
            "key_id": 31,
            "fqn": "nest/core/pynest_application.py/PyNestApp/use",
            "imports": [
                "from fastapi.middleware.cors import CORSMiddleware",
                "import logging"
            ],
            "code": "def use(self, middleware: type, **options) -> 'PyNestApp':\n    if middleware == CORSMiddleware:\n        self.http_server.add_middleware(CORSMiddleware, **options)\n        logging.info('CORS middleware added successfully')\n    else:\n        logging.warning('Middleware type not recognized')\n    return self"
        },
        {
            "key_id": 32,
            "fqn": "nest/core/pynest_application.py/PyNestApp/get_server",
            "imports": [],
            "code": "def get_server(self) -> FastAPI:\n    return self.http_server"
        },
        {
            "key_id": 33,
            "fqn": "nest/core/pynest_application.py/PyNestApp/register_routes",
            "imports": [
                "from nest.core.pynest_container import PyNestContainer",
                "from fastapi import FastAPI",
                "from nest.common.route_resolver import RoutesResolver",
                "from nest.core.pynest_app_context import PyNestApplicationContext",
                "import logging"
            ],
            "code": "def __init__(self, container: PyNestContainer, http_server: FastAPI):\n    self.container = container\n    self.http_server = http_server\n    self._is_listening = False\n    self.application_context = PyNestApplicationContext(container)\n    RoutesResolver(self.http_server, self.container).resolve_routes()\n    logging.info('PyNestApp initialized and routes registered')"
        },
        {
            "key_id": 34,
            "fqn": "nest/core/decorators/injectable.py/Injectable",
            "imports": [
                "from injector import inject",
                "from typing import Type, Optional, Callable",
                "from nest.core.decorators.utils import parse_dependencies",
                "from nest.common.constants import DEPENDENCIES, INJECTABLE_NAME, INJECTABLE_TOKEN"
            ],
            "code": "def Injectable(target_class: Optional[Type] = None, *args, **kwargs) -> Callable:\n    if target_class is None:\n        return lambda x: Injectable(x, *args, **kwargs)\n\n    dependencies = parse_dependencies(target_class)\n    setattr(target_class, DEPENDENCIES, dependencies)\n    setattr(target_class, INJECTABLE_NAME, target_class.__name__)\n    setattr(target_class, INJECTABLE_TOKEN, target_class)\n\n    return inject(**dependencies)(target_class)"
        },
        {
            "key_id": 35,
            "fqn": "nest/core/decorators/controller.py/Controller",
            "imports": [
                "from typing import Type, Optional",
                "from fastapi.routing import APIRouter",
                "from nest.core.decorators.class_based_view import class_based_view as ClassBasedView",
                "from nest.core.decorators.utils import get_instance_variables, parse_dependencies"
            ],
            "code": "def Controller(prefix: Optional[str] = None, tag: Optional[str] = None):\n    def decorator(cls: Type):\n        cls = ClassBasedView(APIRouter(), cls)\n        process_dependencies(cls)\n        process_prefix(cls, prefix, tag)\n        return cls\n    return decorator"
        },
        {
            "key_id": 36,
            "fqn": "nest/core/decorators/controller.py/process_prefix",
            "imports": [
                "from typing import Optional"
            ],
            "code": "def process_prefix(route_prefix: Optional[str], tag_name: Optional[str]) -> str:\n    if route_prefix is not None:\n        if not route_prefix.startswith('/'):\n            route_prefix = '/' + route_prefix\n    else:\n        route_prefix = ''\n    return route_prefix"
        },
        {
            "key_id": 37,
            "fqn": "nest/core/decorators/controller.py/process_dependencies",
            "imports": [
                "from typing import Type",
                "from nest.core.decorators.utils import parse_dependencies"
            ],
            "code": "def process_dependencies(cls: Type) -> None:\n    dependencies = parse_dependencies(cls)\n    for name, dependency in dependencies.items():\n        setattr(cls, name, dependency)"
        },
        {
            "key_id": 38,
            "fqn": "nest/core/decorators/controller.py/set_instance_variables",
            "imports": [
                "from typing import Type",
                "from nest.core.decorators.utils import get_instance_variables"
            ],
            "code": "def set_instance_variables(cls: Type) -> None:\n    instance_vars = get_instance_variables(cls)\n    for var_name, var_value in instance_vars.items():\n        setattr(cls, var_name, var_value)"
        },
        {
            "key_id": 39,
            "fqn": "nest/core/decorators/controller.py/ensure_init_method",
            "imports": [
                "from typing import Type"
            ],
            "code": "def ensure_init_method(cls: Type) -> None:\n    if not hasattr(cls, '__init__'):\n        def init(self, *args, **kwargs):\n            super(cls, self).__init__(*args, **kwargs)\n        cls.__init__ = init"
        },
        {
            "key_id": 40,
            "fqn": "nest/core/decorators/controller.py/add_routes",
            "imports": [
                "from typing import Type",
                "from fastapi.routing import APIRouter",
                "from nest.core.decorators.utils import parse_dependencies"
            ],
            "code": "def add_routes(cls: Type, router: APIRouter, route_prefix: str) -> None:\n    methods = [func for func in dir(cls) if callable(getattr(cls, func)) and not func.startswith('__')]\n    for method_name in methods:\n        method = getattr(cls, method_name)\n        if hasattr(method, 'route_info'):\n            route_info = method.route_info\n            router.add_api_route(route_prefix + route_info.path, method, methods=[route_info.method], tags=[route_info.tag])\n            parse_dependencies(cls)"
        },
        {
            "key_id": 41,
            "fqn": "nest/core/decorators/controller.py/validate_method_decorator",
            "imports": [
                "from typing import Callable"
            ],
            "code": "def validate_method_decorator(method_function: Callable, method_name: str) -> None:\n    if not hasattr(method_function, 'route_info'):\n        raise Exception(f'Method {method_name} is missing route information. Ensure it is decorated with an HTTP method decorator.')"
        },
        {
            "key_id": 42,
            "fqn": "nest/core/decorators/controller.py/configure_method_route",
            "imports": [
                "from typing import Callable",
                "from nest.core.decorators.http_method import HTTPMethod"
            ],
            "code": "def configure_method_route(method_function: Callable, route_prefix: str) -> None:\n    if hasattr(method_function, 'route_info'):\n        route_info = method_function.route_info\n        route_info.path = route_prefix + route_info.path"
        },
        {
            "key_id": 43,
            "fqn": "nest/core/decorators/controller.py/add_route_to_router",
            "imports": [
                "from fastapi.routing import APIRouter",
                "from typing import Callable",
                "from nest.core.decorators.http_method import HTTPMethod",
                "from fastapi import Depends"
            ],
            "code": "def add_route_to_router(router: APIRouter, method_function: Callable) -> None:\n    http_method = HTTPMethod(method_function.__dict__.get('http_method', 'GET'))\n    route_path = method_function.__dict__.get('route_path', '/')\n    dependencies = method_function.__dict__.get('dependencies', [])\n    \n    if dependencies:\n        dependencies = [Depends(dep) for dep in dependencies]\n    \n    if http_method == HTTPMethod.GET:\n        router.get(route_path, dependencies=dependencies)(method_function)\n    elif http_method == HTTPMethod.POST:\n        router.post(route_path, dependencies=dependencies)(method_function)\n    elif http_method == HTTPMethod.DELETE:\n        router.delete(route_path, dependencies=dependencies)(method_function)\n    elif http_method == HTTPMethod.PUT:\n        router.put(route_path, dependencies=dependencies)(method_function)\n    elif http_method == HTTPMethod.PATCH:\n        router.patch(route_path, dependencies=dependencies)(method_function)\n    elif http_method == HTTPMethod.HEAD:\n        router.head(route_path, dependencies=dependencies)(method_function)\n    elif http_method == HTTPMethod.OPTIONS:\n        router.options(route_path, dependencies=dependencies)(method_function)"
        },
        {
            "key_id": 44,
            "fqn": "nest/core/decorators/http_method.py/route",
            "imports": [
                "from enum import Enum",
                "from typing import Callable, Union, List"
            ],
            "code": "class HTTPMethod(Enum):\n    GET = 'GET'\n    POST = 'POST'\n    DELETE = 'DELETE'\n    PUT = 'PUT'\n    PATCH = 'PATCH'\n    HEAD = 'HEAD'\n    OPTIONS = 'OPTIONS'\n\ndef route(http_method: HTTPMethod, route_path: Union[str, List[str]] = '/', **kwargs) -> Callable:\n    def decorator(func: Callable) -> Callable:\n        func.__dict__['http_method'] = http_method\n        func.__dict__['route_path'] = route_path\n        for key, value in kwargs.items():\n            func.__dict__[key] = value\n        return func\n    return decorator"
        },
        {
            "key_id": 45,
            "fqn": "nest/core/decorators/http_method.py/Get",
            "imports": [
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Get(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable:\n    return route(HTTPMethod.GET, route_path, **kwargs)"
        },
        {
            "key_id": 46,
            "fqn": "nest/core/decorators/http_method.py/Post",
            "imports": [
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Post(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable:\n    return route(HTTPMethod.POST, route_path, **kwargs)"
        },
        {
            "key_id": 47,
            "fqn": "nest/core/decorators/http_method.py/Delete",
            "imports": [
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Delete(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable:\n    return route(HTTPMethod.DELETE, route_path, **kwargs)"
        },
        {
            "key_id": 48,
            "fqn": "nest/core/decorators/http_method.py/Put",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Put(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '_route_decorations'):\n            func._route_decorations = []\n        func._route_decorations.append(('put', route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 49,
            "fqn": "nest/core/decorators/http_method.py/Patch",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Patch(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '_route_decorations'):\n            func._route_decorations = []\n        func._route_decorations.append(('patch', route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 50,
            "fqn": "nest/core/decorators/http_method.py/Head",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Head(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '_route_decorations'):\n            func._route_decorations = []\n        func._route_decorations.append(('head', route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 51,
            "fqn": "nest/core/decorators/http_method.py/Options",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Options(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '_route_decorations'):\n            func._route_decorations = []\n        func._route_decorations.append(('options', route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 52,
            "fqn": "nest/core/decorators/database.py/db_request_handler",
            "imports": [
                "import logging",
                "from fastapi.exceptions import HTTPException",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "import time"
            ],
            "code": "def db_request_handler(func):\n    async def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            result = await func(*args, **kwargs)\n            logging.info(f'DB request successful in {time.time() - start_time} seconds')\n            return result\n        except Exception as e:\n            logging.error(f'DB request failed: {str(e)}')\n            raise HTTPException(status_code=500, detail='Database request failed')\n    return wrapper"
        },
        {
            "key_id": 53,
            "fqn": "nest/core/decorators/database.py/async_db_request_handler",
            "imports": [
                "import logging",
                "import time",
                "from fastapi.exceptions import HTTPException",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from typing import Callable, Any, Awaitable"
            ],
            "code": "logger = logging.getLogger(__name__)\n\nasync def async_db_request_handler(func: Callable[..., Awaitable[Any]]) -> Callable[..., Awaitable[Any]]:\n    async def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            response = await func(*args, **kwargs)\n            duration = time.time() - start_time\n            logger.info(f'DB request {func.__name__} executed in {duration:.2f}s')\n            return response\n        except Exception as e:\n            logger.error(f'Error in DB request {func.__name__}: {str(e)}')\n            raise HTTPException(status_code=500, detail=str(e))\n    return wrapper"
        },
        {
            "key_id": 54,
            "fqn": "nest/core/decorators/http_code.py/HttpCode",
            "imports": [
                "from fastapi import status",
                "from fastapi.responses import JSONResponse",
                "from typing import Callable, Any"
            ],
            "code": "def HttpCode(status_code: int):\n    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:\n        async def wrapper(*args, **kwargs):\n            result = await func(*args, **kwargs)\n            return JSONResponse(status_code=status_code, content={'detail': result})\n        return wrapper\n    return decorator"
        },
        {
            "key_id": 56,
            "fqn": "nest/core/decorators/module.py/Module/__call__",
            "imports": [
                "from nest.common.constants import ModuleMetadata"
            ],
            "code": "def __init__(self, imports=None, controllers=None, providers=None, exports=None, is_global: bool = False):\n    self.imports = imports or []\n    self.controllers = controllers or []\n    self.providers = providers or []\n    self.exports = exports or []\n    self.is_global = is_global\n    ModuleMetadata.register_module(self)\n\ndef __call__(self, cls):\n    ModuleMetadata.add_module(cls, {\n        'imports': self.imports,\n        'controllers': self.controllers,\n        'providers': self.providers,\n        'exports': self.exports,\n        'is_global': self.is_global\n    })\n    return cls"
        },
        {
            "key_id": 57,
            "fqn": "nest/core/decorators/utils.py/get_instance_variables",
            "imports": [
                "import ast",
                "import inspect",
                "from nest.common.constants import INJECTABLE_TOKEN",
                "from typing import List, Tuple"
            ],
            "code": "def get_instance_variables(cls) -> List[Tuple[str, Any]]:\n    source = inspect.getsource(cls)\n    tree = ast.parse(source)\n    return [(node.targets[0].id, ast.literal_eval(node.value)) for node in ast.walk(tree) if isinstance(node, ast.Assign) if node.targets[0].id not in INJECTABLE_TOKEN]"
        },
        {
            "key_id": 58,
            "fqn": "nest/core/decorators/utils.py/get_non_dependencies_params",
            "imports": [
                "import ast",
                "import inspect",
                "from nest.common.constants import INJECTABLE_TOKEN",
                "from typing import List, Dict, Any"
            ],
            "code": "def get_non_dependencies_params(cls) -> Dict[str, Any]:\n    source = inspect.getsource(cls)\n    tree = ast.parse(source)\n    result = {}\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in INJECTABLE_TOKEN:\n                    result[arg.arg] = None\n    return result"
        },
        {
            "key_id": 59,
            "fqn": "nest/core/decorators/utils.py/parse_dependencies",
            "imports": [
                "import ast",
                "import inspect",
                "from nest.common.constants import INJECTABLE_TOKEN"
            ],
            "code": "def parse_dependencies(cls):\n    source = inspect.getsource(cls)\n    tree = ast.parse(source)\n    dependencies = []\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Call) and hasattr(node.func, 'id') and node.func.id == 'Injectable':\n            for arg in node.args:\n                if isinstance(arg, ast.Name):\n                    dependencies.append(arg.id)\n                elif isinstance(arg, ast.Attribute):\n                    dependencies.append(arg.attr)\n    return {INJECTABLE_TOKEN: dependencies}"
        },
        {
            "key_id": 60,
            "fqn": "nest/core/decorators/class_based_view.py/class_based_view",
            "imports": [
                "import inspect",
                "from typing import Any, Callable, List, Type, TypeVar, Union, get_type_hints",
                "from fastapi import APIRouter, Depends",
                "from pydantic.typing import is_classvar",
                "from starlette.routing import Route, WebSocketRoute"
            ],
            "code": "def class_based_view(router: APIRouter, cls: Type[T]) -> Type[T]:\n    _init_cbv(cls)\n    for name, value in inspect.getmembers(cls):\n        if inspect.isfunction(value) and not name.startswith('_'):\n            _update_cbv_route_endpoint_signature(cls, value)\n    return cls"
        },
        {
            "key_id": 61,
            "fqn": "nest/core/decorators/class_based_view.py/_init_cbv",
            "imports": [
                "import inspect",
                "from typing import Any, Callable, List, Type, TypeVar, Union, get_type_hints",
                "from fastapi import APIRouter, Depends",
                "from pydantic.typing import is_classvar",
                "from starlette.routing import Route, WebSocketRoute"
            ],
            "code": "def _init_cbv(cls: Type[Any]) -> None:\n    hints = get_type_hints(cls)\n    for name, hint in hints.items():\n        if not is_classvar(hint):\n            setattr(cls, name, Depends(hint))"
        },
        {
            "key_id": 62,
            "fqn": "nest/core/decorators/class_based_view.py/_update_cbv_route_endpoint_signature",
            "imports": [
                "import inspect",
                "from typing import Any, Callable, List, Type, TypeVar, Union, get_type_hints",
                "from fastapi import APIRouter, Depends",
                "from pydantic.typing import is_classvar",
                "from starlette.routing import Route, WebSocketRoute"
            ],
            "code": "def _update_cbv_route_endpoint_signature(cls: Type[Any], route: Union[Route, WebSocketRoute]) -> None:\n    for name, method in inspect.getmembers(cls, inspect.isfunction):\n        if hasattr(cls, '__annotations__'):\n            for param_name, param_type in cls.__annotations__.items():\n                if param_name in method.__code__.co_varnames:\n                    setattr(method, param_name, Depends(param_type))"
        },
        {
            "key_id": 64,
            "fqn": "nest/core/database/base_config.py/ConfigFactoryBase/get_config",
            "imports": [
                "from abc import abstractmethod",
                "import logging"
            ],
            "code": "class ConfigFactoryBase:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n\n    @abstractmethod\n    def get_config(self):\n        pass\n\n    logging.info(f'ConfigFactoryBase for {db_type} initialized')"
        },
        {
            "key_id": 65,
            "fqn": "nest/core/database/base_config.py/BaseConfig/get_engine_url",
            "imports": [
                "from abc import ABC, abstractmethod"
            ],
            "code": "class BaseConfig(ABC):\n    @abstractmethod\n    def get_engine_url(self) -> str:\n        raise NotImplementedError('Subclasses must implement get_engine_url method')"
        },
        {
            "key_id": 67,
            "fqn": "nest/core/database/base_config.py/BaseProvider/get_engine_url",
            "imports": [
                "from abc import ABC, abstractmethod"
            ],
            "code": "class BaseProvider(ABC):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n\n    @abstractmethod\n    def get_engine_url(self) -> str:\n        raise NotImplementedError('Subclasses must implement get_engine_url method')"
        },
        {
            "key_id": 69,
            "fqn": "nest/core/database/odm_provider.py/OdmProvider/check_document_models",
            "imports": [
                "from typing import List",
                "from beanie import Document",
                "from beanie import init_beanie",
                "from motor.motor_asyncio import AsyncIOMotorClient",
                "from nest.core.database.odm_config import ConfigFactory"
            ],
            "code": "class OdmProvider:\n    def __init__(self, db_type = 'mongodb', config_params: dict = None, document_models: List[Document] = None):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.document_models = document_models\n        config_factory = ConfigFactory(db_type)\n        self.config_url = config_factory.get_config().get_engine_url()\n        self.client = AsyncIOMotorClient(self.config_url)\n\n    async def init_beanie(self):\n        await init_beanie(database=self.client[self.db_name], document_models=self.document_models)\n\n    def check_document_models(self):\n        if not self.document_models:\n            raise ValueError('Document models list cannot be empty')"
        },
        {
            "key_id": 71,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/create_all",
            "imports": [
                "from abc import ABC, abstractmethod",
                "from sqlalchemy import create_engine",
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from nest.core.database.orm_config import ConfigFactory, AsyncConfigFactory"
            ],
            "code": "class BaseOrmProvider(ABC):\n    def __init__(self, db_type: str = 'postgresql', config_params: dict = None, async_mode: bool = False, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.async_mode = async_mode\n        if async_mode:\n            config_factory = AsyncConfigFactory(db_type)\n        else:\n            config_factory = ConfigFactory(db_type)\n        self.engine_url = config_factory.get_config().get_engine_url()\n        if async_mode:\n            self.engine = create_async_engine(self.engine_url)\n        else:\n            self.engine = create_engine(self.engine_url)\n\n    def create_all(self):\n        # Implementation for creating all tables\n        pass"
        },
        {
            "key_id": 72,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/drop_all",
            "imports": [
                "from abc import ABC, abstractmethod",
                "from sqlalchemy import create_engine",
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from nest.core.database.orm_config import ConfigFactory, AsyncConfigFactory"
            ],
            "code": "class BaseOrmProvider(ABC):\n    def __init__(self, db_type: str = 'postgresql', config_params: dict = None, async_mode: bool = False, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.async_mode = async_mode\n        if async_mode:\n            config_factory = AsyncConfigFactory(db_type)\n        else:\n            config_factory = ConfigFactory(db_type)\n        self.engine_url = config_factory.get_config().get_engine_url()\n        if async_mode:\n            self.engine = create_async_engine(self.engine_url)\n        else:\n            self.engine = create_engine(self.engine_url)\n\n    def drop_all(self):\n        # Implementation for dropping all tables\n        pass"
        },
        {
            "key_id": 73,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/get_db",
            "imports": [
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession",
                "from contextlib import asynccontextmanager"
            ],
            "code": "class BaseOrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: dict = None, async_mode: bool = False, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.async_mode = async_mode\n        if async_mode:\n            config_factory = AsyncConfigFactory(db_type)\n        else:\n            config_factory = ConfigFactory(db_type)\n        self.engine_url = config_factory.get_config().get_engine_url()\n        if async_mode:\n            self.engine = create_async_engine(self.engine_url)\n        else:\n            self.engine = create_engine(self.engine_url)\n\n    @abstractmethod\n    def get_db(self):\n        raise NotImplementedError('Subclasses must implement get_db method')"
        },
        {
            "key_id": 75,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/create_all",
            "imports": [
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from sqlalchemy.future import select"
            ],
            "code": "class AsyncOrmProvider:\n    async def create_all(self):\n        async with AsyncSession(self.engine) as session:\n            async with session.begin():\n                # Assuming an operation that creates tables\n                await session.execute(select(1))\n            await session.commit()"
        },
        {
            "key_id": 76,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/drop_all",
            "imports": [
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from sqlalchemy.future import select"
            ],
            "code": "class AsyncOrmProvider:\n    async def drop_all(self):\n        async with AsyncSession(self.engine) as session:\n            async with session.begin():\n                # Assuming an operation that drops tables\n                await session.execute(select(1))\n            await session.commit()"
        },
        {
            "key_id": 77,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/get_db",
            "imports": [
                "from contextlib import asynccontextmanager",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncOrmProvider:\n    @asynccontextmanager\n    async def get_db(self):\n        async with self.AsyncSessionLocal() as session:\n            yield session"
        },
        {
            "key_id": 80,
            "fqn": "nest/core/database/odm_config.py/MongoDBConfig/get_engine_url",
            "imports": [],
            "code": "class MongoDBConfig(BaseProvider, ConfigFactoryBase):\n    def get_engine_url(self) -> str:\n        if self.srv:\n            return f'mongodb+srv://{self.user}:{self.password}@{self.host}/{self.db_name}'\n        else:\n            return f'mongodb://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 82,
            "fqn": "nest/core/database/odm_config.py/ConfigFactory/get_config",
            "imports": [
                "from nest.core.database.odm_config import MongoDBConfig"
            ],
            "code": "def get_config(self):\n    if self.db_type == 'mongodb':\n        return MongoDBConfig()\n    else:\n        raise ValueError(f'Unsupported database type: {self.db_type}')"
        },
        {
            "key_id": 84,
            "fqn": "nest/core/database/orm_config.py/PostgresConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f'postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 86,
            "fqn": "nest/core/database/orm_config.py/MySQLConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f'mysql+pymysql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 88,
            "fqn": "nest/core/database/orm_config.py/SQLiteConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f'sqlite:///{self.db_name}'"
        },
        {
            "key_id": 90,
            "fqn": "nest/core/database/orm_config.py/AsyncSQLiteConfig/get_engine_url",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "def get_engine_url(self) -> str:\n    return f'sqlite+aiosqlite:///{self.db_name}'"
        },
        {
            "key_id": 92,
            "fqn": "nest/core/database/orm_config.py/AsyncPostgresConfig/get_engine_url",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncPostgresConfig(BaseConfig):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        super().__init__(host, db_name, user, password, port)\n        self.engine_url = f'postgresql+asyncpg://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    def get_engine_url(self) -> str:\n        return self.engine_url"
        },
        {
            "key_id": 94,
            "fqn": "nest/core/database/orm_config.py/AsyncMySQLConfig/get_engine_url",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncMySQLConfig(BaseConfig):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        super().__init__(host, db_name, user, password, port)\n        self.engine_url = f'mysql+aiomysql://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    def get_engine_url(self) -> str:\n        return self.engine_url"
        },
        {
            "key_id": 96,
            "fqn": "nest/core/database/orm_config.py/ConfigFactory/get_config",
            "imports": [
                "from .orm_config import AsyncPostgresConfig",
                "from .orm_config import AsyncMySQLConfig",
                "from .orm_config import AsyncSQLiteConfig"
            ],
            "code": "class ConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n        self.config = None\n        if db_type == 'sqlite':\n            self.config = AsyncSQLiteConfig('database.db')\n        elif db_type == 'postgresql':\n            self.config = AsyncPostgresConfig(host='localhost', db_name='test_db', user='user', password='password', port=5432)\n        elif db_type == 'mysql':\n            self.config = AsyncMySQLConfig(host='localhost', db_name='test_db', user='user', password='password', port=3306)\n\n    def get_config(self):\n        return self.config"
        },
        {
            "key_id": 98,
            "fqn": "nest/core/database/orm_config.py/AsyncConfigFactory/get_config",
            "imports": [
                "from .orm_config import AsyncPostgresConfig",
                "from .orm_config import AsyncMySQLConfig",
                "from .orm_config import AsyncSQLiteConfig"
            ],
            "code": "class AsyncConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n        self.config = None\n        if db_type == 'sqlite':\n            self.config = AsyncSQLiteConfig('database.db')\n        elif db_type == 'postgresql':\n            self.config = AsyncPostgresConfig(host='localhost', db_name='test_db', user='user', password='password', port=5432)\n        elif db_type == 'mysql':\n            self.config = AsyncMySQLConfig(host='localhost', db_name='test_db', user='user', password='password', port=3306)\n\n    def get_config(self):\n        return self.config"
        }
    ]
}