[
    {
        "fqn_list": "alembic_postgresql_enum/alembic_env.py",
        "new_code": "## alembic_env.py\nfrom logging.config import fileConfig\nfrom sqlalchemy import engine_from_config, pool\nfrom alembic import context\nfrom enum_handler import EnumHandler\nimport os\nimport sys\n\nfrom myapp.mymodel import Base\ntarget_metadata = Base.metadata\n\nconfig = context.config\n\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\nclass AlembicEnv:\n    @staticmethod\n    def configure() -> None:\n        pass\n\n    @staticmethod\n    def run_migrations_online() -> None:\n        connectable = engine_from_config(\n            config.get_section(config.config_ini_section),\n            prefix='sqlalchemy.',\n            poolclass=pool.NullPool,\n        )\n\n        enum_handler = EnumHandler()\n\n        with connectable.connect() as connection:\n            context.configure(\n                connection=connection,\n                target_metadata=target_metadata,\n                process_revision_directives=enum_handler.process_revision_directives,\n                **config.get_section('alembic:env')\n            )\n\n            with context.begin_transaction():\n                enum_handler.detect_new_enums()\n                enum_handler.detect_enum_changes()\n                enum_handler.remove_unused_enums()\n                context.run_migrations()\n\n    @staticmethod\n    def run_migrations_offline() -> None:\n        url = config.get_main_option(\"sqlalchemy.url\")\n        context.configure(\n            url=url,\n            target_metadata=target_metadata,\n            process_revision_directives=EnumHandler.process_revision_directives,\n            literal_binds=True,\n            dialect_opts={\"paramstyle\": \"named\"},\n            **config.get_section('alembic:env')\n        )\n\n        enum_handler = EnumHandler()\n\n        with context.begin_transaction():\n            enum_handler.detect_new_enums()\n            enum_handler.detect_enum_changes()\n            enum_handler.remove_unused_enums()\n            context.run_migrations()\n\nif context.is_offline_mode():\n    AlembicEnv.run_migrations_offline()\nelse:\n    AlembicEnv.run_migrations_online()"
    },
    {
        "fqn_list": "alembic_postgresql_enum/enum_handler.py",
        "new_code": "## enum_handler.py\nfrom typing import List\nfrom sqlalchemy import MetaData, inspect\nfrom migration_operations import MigrationOperations\nfrom utils import Utils\n\nclass EnumHandler:\n    def __init__(self, engine, metadata: MetaData):\n        self.engine = engine\n        self.metadata = metadata\n        self.migration_operations = MigrationOperations(engine)\n        self.utils = Utils()\n\n    def detect_new_enums(self) -> List[str]:\n        model_enums = self.utils.get_model_enums(self.metadata)\n        db_enums = self.utils.get_db_enums(self.engine)\n        new_enums = list(set(model_enums) - set(db_enums))\n        return new_enums\n\n    def detect_enum_changes(self) -> List[str]:\n        model_enums = self.utils.get_model_enums(self.metadata)\n        db_enums = self.utils.get_db_enums(self.engine)\n        changed_enums = []\n        for enum_name, model_values in model_enums.items():\n            if enum_name in db_enums:\n                db_values = db_enums[enum_name]\n                if set(model_values) != set(db_values):\n                    changed_enums.append(enum_name)\n        return changed_enums\n\n    def remove_unused_enums(self) -> List[str]:\n        model_enums = self.utils.get_model_enums(self.metadata)\n        db_enums = self.utils.get_db_enums(self.engine)\n        unused_enums = list(set(db_enums) - set(model_enums))\n        \n        inspector = inspect(self.engine)\n        used_enums = set()\n        for table_name in inspector.get_table_names():\n            for column in inspector.get_columns(table_name):\n                if column['type'].__visit_name__ == 'ENUM':\n                    used_enums.add(column['type'].name)\n        unused_enums = [enum for enum in unused_enums if enum not in used_enums]\n        \n        return unused_enums\n\n    def process_revision_directives(self, context, revision, directives):\n        new_enums = self.detect_new_enums()\n        for enum_name in new_enums:\n            enum_values = self.utils.get_model_enum_values(enum_name, self.metadata)\n            self.migration_operations.add_enum(enum_name, values=enum_values)\n\n        changed_enums = self.detect_enum_changes()\n        for enum_name in changed_enums:\n            enum_values = self.utils.get_model_enum_values(enum_name, self.metadata)\n            self.migration_operations.alter_enum(enum_name, values=enum_values)\n\n        unused_enums = self.remove_unused_enums()\n        for enum_name in unused_enums:\n            self.migration_operations.drop_enum(enum_name)"
    },
    {
        "fqn_list": "alembic_postgresql_enum/main.py",
        "new_code": "## main.py\nimport os\nfrom alembic_env import AlembicEnv\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import sessionmaker\nfrom myapp.mymodel import Base\n\ndef main():\n    DATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql+psycopg2://user:password@localhost/dbname\")\n    \n    try:\n        engine = create_engine(DATABASE_URL)\n        Session = sessionmaker(bind=engine)\n        session = Session()\n        Base.metadata.create_all(engine)\n        AlembicEnv.configure()\n        if AlembicEnv.is_offline_mode():\n            AlembicEnv.run_migrations_offline()\n        else:\n            AlembicEnv.run_migrations_online()\n    except SQLAlchemyError as e:\n        print(f\"An error occurred while setting up the database: {e}\")\n    finally:\n        if 'session' in locals():\n            session.close()\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "fqn_list": "alembic_postgresql_enum/migration_operations.py",
        "new_code": "## migration_operations.py\nfrom sqlalchemy import create_engine, text\nfrom sqlalchemy.exc import ProgrammingError\nfrom typing import List\n\nclass MigrationOperations:\n    def __init__(self, engine):\n        self.engine = engine\n\n    def add_enum(self, enum_name: str, values: List[str]) -> None:\n        enum_values = \"', '\".join(values)\n        create_enum_query = f\"CREATE TYPE {enum_name} AS ENUM ('{enum_values}');\"\n        with self.engine.connect() as conn:\n            conn.execute(text(create_enum_query))\n\n    def alter_enum(self, enum_name: str, values: List[str]) -> None:\n        with self.engine.connect() as conn:\n            for value in values:\n                add_value_query = f\"ALTER TYPE {enum_name} ADD VALUE IF NOT EXISTS '{value}';\"\n                try:\n                    conn.execute(text(add_value_query))\n                except ProgrammingError as e:\n                    print(f\"Value '{value}' already exists in enum '{enum_name}'. Exception: {e}\")\n\n    def drop_enum(self, enum_name: str) -> None:\n        drop_enum_query = f\"DROP TYPE IF EXISTS {enum_name};\"\n        with self.engine.connect() as conn:\n            conn.execute(text(drop_enum_query))"
    },
    {
        "fqn_list": "alembic_postgresql_enum/utils.py",
        "new_code": "## utils.py\nfrom typing import Dict, List, Set\nfrom sqlalchemy import MetaData, Enum\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.sql import sqltypes\n\nclass Utils:\n    @staticmethod\n    def get_model_enums(metadata: MetaData) -> Dict[str, List[str]]:\n        enums = {}\n        for table in metadata.tables.values():\n            for column in table.columns:\n                if isinstance(column.type, Enum):\n                    enums[column.type.name] = list(column.type.enums)\n        return enums\n\n    @staticmethod\n    def get_db_enums(engine: Engine) -> Dict[str, List[str]]:\n        enums = {}\n        with engine.connect() as conn:\n            result = conn.execute(\"SELECT t.typname as enum_name, \"\n                                  \"       e.enumlabel as enum_value \"\n                                  \"FROM pg_type t \"\n                                  \"JOIN pg_enum e ON t.oid = e.enumtypid \"\n                                  \"JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\")\n            for row in result:\n                if row['enum_name'] in enums:\n                    enums[row['enum_name']].append(row['enum_value'])\n                else:\n                    enums[row['enum_name']] = [row['enum_value']]\n        return enums\n\n    @staticmethod\n    def get_enum_diff(old_enum: List[str], new_enum: List[str]) -> Dict[str, Set[str]]:\n        old_set, new_set = set(old_enum), set(new_enum)\n        return {\n            'added': new_set - old_set,\n            'removed': old_set - new_set\n        }\n\n    @staticmethod\n    def get_unused_enums(db_enums: Dict[str, List[str]], model_enums: Dict[str, List[str]]) -> List[str]:\n        unused_enums = list(set(db_enums.keys()) - set(model_enums.keys()))\n        return unused_enums"
    }
]
