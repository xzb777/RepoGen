{
    "ufomerge": {
        "generated code": "## main.py\nimport argparse\nfrom ufoLib2 import Font\nfrom ufomerge import UfoMerge  # Assuming ufomerge.py now contains the UfoMerge class\nfrom cli import CLI  # Assuming cli.py now contains the CLI class\n\nclass Main:\n    def __init__(self):\n        self.cli = CLI()\n        self.ufomerge = UfoMerge()\n\n    def main(self):\n        arguments = self.cli.parse_arguments()\n\n        self.ufomerge.load_font(arguments['font_a'], arguments['font_b'])\n        self.ufomerge.merge_fonts(\n            output_path=arguments['output'],\n            glyphs=arguments['glyphs'],\n            unicodes=[int(u, 16) for u in arguments['unicodes']],\n            exclude_glyphs=arguments['exclude_glyphs'],\n            replace_existing=arguments['replace_existing']\n        )\n\nif __name__ == \"__main__\":\n    main_instance = Main()\n    main_instance.main()\n\n## ufomerge.py\nfrom typing import List\nfrom ufoLib2 import Font\nfrom font_operations import FontOperations\nfrom utils import Utils\n\nclass UfoMerge:\n    def __init__(self):\n        self.font_a = None\n        self.font_b = None\n\n    def merge_fonts(self, output_path: str, glyphs: List[str], unicodes: List[int], exclude_glyphs: List[str], replace_existing: bool = False) -> None:\n        \"\"\"\n        Merges two fonts into a new font file based on specified glyphs, unicodes, and exclusion criteria.\n\n        :param output_path: Path to save the merged font.\n        :param glyphs: List of glyph names to include in the merge.\n        :param unicodes: List of Unicode codepoints to include in the merge.\n        :param exclude_glyphs: List of glyph names to exclude from the merge.\n        :param replace_existing: Whether to replace glyphs in the target font if they already exist.\n        \"\"\"\n        if not self.font_a or not self.font_b:\n            print(\"Fonts not loaded.\")\n            return\n\n        merged_font = Font()\n        glyphs_to_merge = []\n\n        if glyphs:\n            glyphs_to_merge.extend(glyphs)\n        if unicodes:\n            glyphs_to_merge.extend(Utils.filter_glyphs_by_codepoints(self.font_a, unicodes))\n            glyphs_to_merge.extend(Utils.filter_glyphs_by_codepoints(self.font_b, unicodes))\n\n        # Remove excluded glyphs from the list\n        glyphs_to_merge = [glyph for glyph in glyphs_to_merge if glyph not in exclude_glyphs]\n\n        # Copy glyphs from both fonts to the new merged font with consideration for replace_existing flag\n        for glyph_name in glyphs_to_merge:\n            if replace_existing or glyph_name not in merged_font:\n                FontOperations.copy_glyphs(self.font_a, merged_font, [glyph_name])\n                FontOperations.copy_glyphs(self.font_b, merged_font, [glyph_name])\n\n        # Handle kerning and lib entries merging\n        FontOperations.handle_kerning(merged_font, self.font_a)\n        FontOperations.handle_kerning(merged_font, self.font_b)\n        FontOperations.merge_lib_entries(merged_font, self.font_a)\n        FontOperations.merge_lib_entries(merged_font, self.font_b)\n\n        # Save the merged font\n        merged_font.save(output_path)\n        print(f\"Merged font saved to {output_path}\")\n\n    def subset_font(self, font: Font, glyphs: List[str]) -> Font:\n        \"\"\"\n        Creates a subset of the given font, including only the specified glyphs.\n\n        :param font: The source ufoLib2.Font object.\n        :param glyphs: A list of glyph names to include in the subset.\n        :return: A new ufoLib2.Font object containing only the specified glyphs.\n        \"\"\"\n        subset_font = Font()\n        FontOperations.copy_glyphs(font, subset_font, glyphs)\n        return subset_font\n\n    def load_font(self, font_path_a: str, font_path_b: str) -> None:\n        \"\"\"\n        Loads two font files into the UfoMerge instance.\n\n        :param font_path_a: Path to the first font file.\n        :param font_path_b: Path to the second font file.\n        \"\"\"\n        try:\n            self.font_a = Font.open(font_path_a)\n            self.font_b = Font.open(font_path_b)\n            print(f\"Fonts loaded: {font_path_a} and {font_path_b}\")\n        except FileNotFoundError as e:\n            print(f\"File not found: {e}\")\n        except IOError as e:\n            print(f\"Error reading file: {e}\")\n        except Exception as e:\n            print(f\"Unexpected error loading fonts: {e}\")\n\n## utils.py\nimport typing\nfrom ufoLib2 import Font\nfrom typing import List\n\nclass Utils:\n    @staticmethod\n    def read_glyphs_file(file_path: str) -> List[str]:\n        \"\"\"\n        Reads a file containing glyph names, one per line, and returns a list of glyph names.\n\n        :param file_path: Path to the file containing glyph names.\n        :return: A list of glyph names.\n        \"\"\"\n        glyph_names = []\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                glyph_names = [line.strip() for line in file if line.strip()]\n        except FileNotFoundError:\n            print(f\"File not found: {file_path}\")\n        except ValueError as e:\n            print(f\"Invalid format in {file_path}: {e}\")\n        return glyph_names\n\n    @staticmethod\n    def read_codepoints_file(file_path: str) -> List[int]:\n        \"\"\"\n        Reads a file containing Unicode codepoints in hexadecimal format, one per line, and returns a list of codepoints.\n\n        :param file_path: Path to the file containing Unicode codepoints.\n        :return: A list of codepoints.\n        \"\"\"\n        codepoints = []\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                for line in file:\n                    line = line.strip()\n                    if line:\n                        try:\n                            codepoint = int(line, 16)\n                            codepoints.append(codepoint)\n                        except ValueError:\n                            print(f\"Invalid codepoint in file {file_path}: {line}\")\n        except FileNotFoundError:\n            print(f\"File not found: {file_path}\")\n        except ValueError as e:\n            print(f\"Error reading {file_path}: {e}\")\n        return codepoints\n\n    @staticmethod\n    def filter_glyphs_by_codepoints(font: Font, codepoints: List[int]) -> List[str]:\n        \"\"\"\n        Filters glyphs in a font by a list of Unicode codepoints and returns the names of matching glyphs.\n\n        :param font: The ufoLib2.Font object to filter.\n        :param codepoints: A list of Unicode codepoints.\n        :return: A list of glyph names matching the codepoints.\n        \"\"\"\n        codepoints_set = set(codepoints)\n        matching_glyphs = [glyph.name for glyph in font if glyph.unicode in codepoints_set]\n        return matching_glyphs\n\n## font_operations.py\nfrom typing import List\nfrom ufoLib2 import Font\nfrom ufoLib2.objects import Glyph\n\nclass FontOperations:\n    @staticmethod\n    def copy_glyphs(source_font: Font, target_font: Font, glyphs: List[str]) -> None:\n        \"\"\"\n        Copies glyphs from a source font to a target font, ensuring no duplicates are created.\n        Aggregates warnings and prints them at the end for efficiency.\n\n        :param source_font: The source ufoLib2.Font object.\n        :param target_font: The target ufoLib2.Font object.\n        :param glyphs: A list of glyph names to be copied.\n        \"\"\"\n        warnings = []\n        for glyph_name in glyphs:\n            if glyph_name in source_font:\n                glyph = source_font[glyph_name].copy()\n                if glyph_name in target_font:\n                    warnings.append(f\"Glyph '{glyph_name}' already exists in target font. Skipping to avoid duplicates.\")\n                else:\n                    target_font.addGlyph(glyph)\n            else:\n                warnings.append(f\"Glyph '{glyph_name}' not found in source font.\")\n        if warnings:\n            print(\"\\n\".join(warnings))\n\n    @staticmethod\n    def handle_kerning(target_font: Font, source_font: Font) -> None:\n        \"\"\"\n        Merges kerning information from a source font into a target font, with a sophisticated conflict resolution strategy.\n\n        :param target_font: The target ufoLib2.Font object.\n        :param source_font: The source ufoLib2.Font object.\n        \"\"\"\n        for pair, value in source_font.kerning.items():\n            if pair in target_font.kerning:\n                # Implementing a sophisticated conflict resolution strategy\n                # For demonstration, choosing the higher value\n                target_font.kerning[pair] = max(value, target_font.kerning[pair])\n            else:\n                target_font.kerning[pair] = value\n\n    @staticmethod\n    def merge_lib_entries(target_font: Font, source_font: Font) -> None:\n        \"\"\"\n        Merges lib entries from a source font into a target font, with enhanced conflict resolution.\n\n        :param target_font: The target ufoLib2.Font object.\n        :param source_font: The source ufoLib2.Font object.\n        \"\"\"\n        for key, value in source_font.lib.items():\n            if key not in target_font.lib:\n                target_font.lib[key] = value\n            else:\n                # Enhanced conflict resolution\n                if isinstance(target_font.lib[key], list) and isinstance(value, list):\n                    target_font.lib[key].extend(value)\n                else:\n                    print(f\"Lib entry '{key}' conflict: existing type {type(target_font.lib[key])}, new type {type(value)}. Manual resolution required.\")\n\n## cli.py\nimport argparse\nfrom typing import Dict\nfrom ufomerge import UfoMerge\n\nclass CLI:\n    @staticmethod\n    def parse_arguments() -> Dict[str, str]:\n        \"\"\"\n        Parses command-line arguments and returns them as a dictionary.\n\n        :return: A dictionary of command-line arguments.\n        \"\"\"\n        parser = argparse.ArgumentParser(description=\"Merge two UFO fonts into one.\")\n        parser.add_argument(\"--font-a\", type=str, required=True, help=\"Path to the first font file.\")\n        parser.add_argument(\"--font-b\", type=str, required=True, help=\"Path to the second font file.\")\n        parser.add_argument(\"--output\", type=str, required=True, help=\"Path to save the merged font.\")\n        parser.add_argument(\"--glyphs\", type=str, nargs='*', default=[], help=\"List of glyph names to include in the merge.\")\n        parser.add_argument(\"--unicodes\", type=str, nargs='*', default=[], help=\"List of Unicode codepoints to include in the merge.\")\n        parser.add_argument(\"--exclude-glyphs\", type=str, nargs='*', default=[], help=\"List of glyph names to exclude from the merge.\")\n        parser.add_argument(\"--replace-existing\", action='store_true', help=\"Replace glyphs in the target font if they already exist.\")\n\n        args = parser.parse_args()\n        return vars(args)\n\n    @staticmethod\n    def display_help() -> None:\n        \"\"\"\n        Displays help information for the command-line interface.\n        \"\"\"\n        print(\"Usage: ufomerge --font-a PATH --font-b PATH --output PATH [options]\")\n        print(\"Options:\")\n        print(\"  --glyphs [GLYPHS]          List of glyph names to include in the merge.\")\n        print(\"  --unicodes [UNICODES]      List of Unicode codepoints to include in the merge.\")\n        print(\"  --exclude-glyphs [GLYPHS]  List of glyph names to exclude from the merge.\")\n        print(\"  --replace-existing         Replace glyphs in the target font if they already exist.\")\n        print(\"  --help                     Show this help message and exit.\")\n\nif __name__ == \"__main__\":\n    cli = CLI()\n    arguments = cli.parse_arguments()\n\n    ufomerge = UfoMerge()\n    ufomerge.load_font(arguments['font_a'], arguments['font_b'])\n    ufomerge.merge_fonts(\n        output_path=arguments['output'],\n        glyphs=arguments['glyphs'],\n        unicodes=[int(u, 16) for u in arguments['unicodes']],\n        exclude_glyphs=arguments['exclude_glyphs'],\n        replace_existing=arguments['replace_existing']\n    )\n\n",
        "design": {
            "0": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/_deduplicate_class_defs",
                "class": null,
                "signature": "def _deduplicate_class_defs(class_name_references: dict[str, list[ast.GlyphClassName]]) -> list[ast.GlyphClassDefinition]:"
            },
            "1": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/LayoutSubsetter/subset",
                "class": "ufomerge/layout.py.LayoutSubsetter",
                "signature": "def subset(self, fea: ast.FeatureFile):"
            },
            "2": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/LayoutSubsetVisitor/__init__",
                "class": "ufomerge/layout.py.LayoutSubsetVisitor",
                "signature": "def __init__(self, glyphset):"
            },
            "3": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, mcd, *args, **kwargs):"
            },
            "4": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "5": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "6": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "7": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "8": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "9": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "10": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "11": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "12": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "13": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "14": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/_ignore_pos_sub",
                "class": null,
                "signature": "def _ignore_pos_sub(visitor, st, *args, **kwargs):"
            },
            "15": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "16": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "17": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, block, *args, **kwargs):"
            },
            "18": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "19": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "20": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(_visitor, st, *args, **kwargs):"
            },
            "21": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(_visitor, st, *args, **kwargs):"
            },
            "22": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(_visitor, st, *args, **kwargs):"
            },
            "23": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(_visitor, st, *args, **kwargs):"
            },
            "24": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(_visitor, st, *args, **kwargs):"
            },
            "25": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/LayoutClosureVisitor/__init__",
                "class": "ufomerge/layout.py.LayoutClosureVisitor",
                "signature": "def __init__(self, incoming_glyphset: Dict[str, bool], glyphset: Set[str]):"
            },
            "26": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "27": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "28": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "29": {
                "relative_path": "ufomerge/layout.py",
                "fqn_list": "ufomerge/layout.py/visit",
                "class": null,
                "signature": "def visit(visitor, st, *args, **kwargs):"
            },
            "30": {
                "relative_path": "ufomerge/utils.py",
                "fqn_list": "ufomerge/utils.py/filter_glyphs",
                "class": null,
                "signature": "def filter_glyphs(glyphs: Iterable[str], glyphset: Set[str]) -> list[str]:"
            },
            "31": {
                "relative_path": "ufomerge/utils.py",
                "fqn_list": "ufomerge/utils.py/filter_glyph_mapping",
                "class": null,
                "signature": "def filter_glyph_mapping(glyphs: Mapping[str, Any], glyphset: Set[str]) -> dict[str, Any]:"
            },
            "32": {
                "relative_path": "ufomerge/utils.py",
                "fqn_list": "ufomerge/utils.py/filter_sequence",
                "class": null,
                "signature": "def filter_sequence(slots: Iterable, glyphset: Set[str], class_name_references: Optional[Dict[str, List[ast.GlyphClassName]]] = None) -> list[list[str]]:"
            },
            "33": {
                "relative_path": "ufomerge/utils.py",
                "fqn_list": "ufomerge/utils.py/filter_glyph_container",
                "class": null,
                "signature": "def filter_glyph_container(container: Any, glyphset: Set[str], class_name_references: Optional[Dict[str, List[ast.GlyphClassName]]] = None) -> Any:"
            },
            "34": {
                "relative_path": "ufomerge/utils.py",
                "fqn_list": "ufomerge/utils.py/has_any_empty_slots",
                "class": null,
                "signature": "def has_any_empty_slots(sequence: list) -> bool:"
            },
            "35": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/__post_init__",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def __post_init__(self):"
            },
            "36": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/merge",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def merge(self):"
            },
            "37": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/close_components",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def close_components(self, glyph: str):"
            },
            "38": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/filter_glyphs_incoming",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def filter_glyphs_incoming(self, glyphs: Iterable[str]) -> list[str]:"
            },
            "39": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/add_language_systems",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def add_language_systems(self, incoming_languagesystems):"
            },
            "40": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/merge_kerning",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def merge_kerning(self):"
            },
            "41": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/merge_set",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def merge_set(self, name, glyph, create_if_not_in_ufo1 = False):"
            },
            "42": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/UFOMerger/merge_dict",
                "class": "ufomerge/__init__.py.UFOMerger",
                "signature": "def merge_dict(self, name, glyph, create_if_not_in_ufo1 = False):"
            },
            "43": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/merge_ufos",
                "class": null,
                "signature": "def merge_ufos(ufo1: Font, ufo2: Font, glyphs: Iterable[str] = None, exclude_glyphs: Iterable[str] = None, codepoints: Iterable[int] = None, layout_handling: str = \"subset\", existing_handling: str = \"replace\", include_dir: Path | None = None, original_glyphlist: Iterable[str] | None = None) -> None:"
            },
            "44": {
                "relative_path": "ufomerge/__init__.py",
                "fqn_list": "ufomerge/__init__.py/subset_ufo",
                "class": null,
                "signature": "def subset_ufo(ufo: Font, glyphs: Iterable[str] = None, exclude_glyphs: Iterable[str] = None, codepoints: Iterable[int] = None, layout_handling: str = \"subset\", include_dir: Path | None = None, original_glyphlist: Iterable[str] | None = None) -> Font:"
            }
        }
    },
    "translategram": {
        "generated code": "## main.py\n\nimport logging\nfrom telegram.ext import CommandHandler, MessageHandler, Filters\nfrom adapters.telegram_bot_adapter import TelegramBotAdapter\nfrom translator import Translator\nfrom cache_manager import CacheManager\nfrom services import TranslationServiceFactory, GoogleTranslate, DeepLTranslate\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass Main:\n    def __init__(self, token: str):\n        \"\"\"\n        Initializes the main application with the necessary components.\n\n        Args:\n            token (str): The token for the Telegram bot.\n        \"\"\"\n        # Initialize the translation service factory and register services\n        service_factory = TranslationServiceFactory()\n        service_factory.register_service('Google', GoogleTranslate)\n        service_factory.register_service('DeepL', DeepLTranslate)\n\n        # Initialize the cache manager\n        cache_manager = CacheManager(maxsize=1024, ttl=300)\n\n        # Initialize the translator with the cache manager and service factory\n        translator = Translator(cache_manager=cache_manager, service_factory=service_factory)\n\n        # Initialize the Telegram bot adapter with the token and translator\n        self.telegram_bot_adapter = TelegramBotAdapter(token=token, translator=translator)\n\n    def start_bot(self):\n        \"\"\"\n        Starts the Telegram bot to receive and handle messages.\n        \"\"\"\n        self.telegram_bot_adapter.receive_message()\n\nif __name__ == \"__main__\":\n    # Example usage\n    TOKEN = \"your_telegram_bot_token_here\"\n    main_app = Main(token=TOKEN)\n    main_app.start_bot()\n\n## cache_manager.py\n\nfrom typing import Optional, Dict\nfrom cachetools import TTLCache\n\nclass CacheManager:\n    \"\"\"\n    Manages caching for translations to optimize API calls. This class uses a TTLCache\n    from cachetools for caching translations with a time-to-live (TTL) policy.\n    \"\"\"\n\n    def __init__(self, maxsize: int = 1024, ttl: int = 300) -> None:\n        \"\"\"\n        Initializes the CacheManager with a TTLCache.\n\n        Args:\n            maxsize (int): The maximum size of the cache (number of items).\n            ttl (int): Time-to-live in seconds for each cache item.\n        \"\"\"\n        self.cache: TTLCache[str, str] = TTLCache(maxsize=maxsize, ttl=ttl)\n\n    def get_cached_translation(self, text: str, target_lang: str) -> Optional[str]:\n        \"\"\"\n        Retrieves a translation from the cache if available.\n\n        Args:\n            text (str): The original text to translate.\n            target_lang (str): The target language for the translation.\n\n        Returns:\n            Optional[str]: The cached translation if available, otherwise None.\n        \"\"\"\n        cache_key = f\"{text}_{target_lang}\"\n        return self.cache.get(cache_key)\n\n    def cache_translation(self, text: str, target_lang: str, translation: str) -> None:\n        \"\"\"\n        Caches a translation with a specific key based on the original text and target language.\n\n        Args:\n            text (str): The original text that was translated.\n            target_lang (str): The target language of the translation.\n            translation (str): The translated text to cache.\n        \"\"\"\n        cache_key = f\"{text}_{target_lang}\"\n        self.cache[cache_key] = translation\n\n## translator.py\n\nfrom typing import Optional\nimport logging\nfrom cache_manager import CacheManager\nfrom services import TranslationServiceFactory\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass Translator:\n    \"\"\"\n    Handles translation logic, interacting with CacheManager and translation services.\n    \"\"\"\n\n    def __init__(self, cache_manager: CacheManager, service_factory: TranslationServiceFactory) -> None:\n        \"\"\"\n        Initializes the Translator with a CacheManager and a TranslationServiceFactory.\n\n        Args:\n            cache_manager (CacheManager): An instance of CacheManager for caching translations.\n            service_factory (TranslationServiceFactory): A factory for creating translation service instances.\n        \"\"\"\n        self.cache_manager = cache_manager\n        self.service_factory = service_factory\n\n    def translate(self, text: str, target_lang: str, service: str = 'Google') -> Optional[str]:\n        \"\"\"\n        Translates a given text into the target language using the specified translation service.\n        It first checks the cache for an existing translation before querying the translation service.\n\n        Args:\n            text (str): The text to be translated.\n            target_lang (str): The target language code (e.g., 'en' for English).\n            service (str): The name of the translation service to use (default: 'Google').\n\n        Returns:\n            Optional[str]: The translated text if successful, None otherwise.\n        \"\"\"\n        # Check the cache first\n        cached_translation = self.cache_manager.get_cached_translation(text, target_lang)\n        if cached_translation:\n            return cached_translation\n\n        # If not in cache, use the translation service\n        try:\n            translation_service = self.service_factory.get_service(service)\n            translated_text = translation_service.translate(text, target_lang)\n            # Cache the new translation\n            self.cache_manager.cache_translation(text, target_lang, translated_text)\n            return translated_text\n        except Exception as e:  # Catching a more general exception\n            logger.error(f\"Translation service error: {e}\")\n            return None\n\n## adapters/telegram_bot_adapter.py\n\nfrom telegram import Bot, Update\nfrom telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext\nfrom typing import Callable, Dict, Any\nimport logging\n\n# Import Translator with a relative import to avoid circular imports\nfrom ..translator import Translator\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass TelegramBotAdapter:\n    \"\"\"\n    This class provides methods to interact with the Telegram bot, including\n    sending messages and handling incoming messages with translation.\n    \"\"\"\n\n    def __init__(self, token: str, translator: Translator):\n        \"\"\"\n        Initializes the TelegramBotAdapter with the necessary token and a Translator instance.\n\n        Args:\n            token (str): The token for the Telegram bot, used for authentication.\n            translator (Translator): An instance of the Translator class for translating messages.\n        \"\"\"\n        self.token = token\n        self.translator = translator\n        self.bot = Bot(token)\n        self.updater = Updater(token, use_context=True)\n        self.dispatcher = self.updater.dispatcher\n        self._setup_handlers()\n\n    def _setup_handlers(self) -> None:\n        \"\"\"\n        Sets up command and message handlers for the bot.\n        \"\"\"\n        start_handler = CommandHandler('start', self._start)\n        message_handler = MessageHandler(Filters.text & ~Filters.command, self._handle_message)\n\n        self.dispatcher.add_handler(start_handler)\n        self.dispatcher.add_handler(message_handler)\n\n    def _start(self, update: Update, context: CallbackContext) -> None:\n        \"\"\"\n        Handles the /start command sent to the Telegram bot.\n\n        Args:\n            update (Update): The update instance representing the incoming update.\n            context (CallbackContext): The context of the callback.\n        \"\"\"\n        update.message.reply_text('Welcome to Translategram! Send me a text to translate.')\n\n    def _handle_message(self, update: Update, context: CallbackContext) -> None:\n        \"\"\"\n        Handles incoming messages that are not commands by translating them.\n\n        Args:\n            update (Update): The update instance representing the incoming update.\n            context (CallbackContext): The context of the callback.\n        \"\"\"\n        text = update.message.text\n        # Example target language and service are hardcoded for demonstration purposes\n        target_lang = 'en'\n        service = 'Google'\n        try:\n            translated_text = self.translator.translate(text, target_lang=target_lang, service=service)\n            if translated_text:\n                update.message.reply_text(f'Translated text: {translated_text}')\n            else:\n                update.message.reply_text('Sorry, the translation could not be completed.')\n        except Exception as e:\n            logger.error(f\"Translation error: {e}\")\n            update.message.reply_text('Sorry, the translation could not be completed.')\n\n    def send_message(self, chat_id: int, text: str) -> None:\n        \"\"\"\n        Sends a message to a specified chat ID through the Telegram bot.\n\n        Args:\n            chat_id (int): The chat ID to send the message to.\n            text (str): The text of the message to be sent.\n        \"\"\"\n        self.bot.send_message(chat_id=chat_id, text=text)\n\n    def receive_message(self) -> None:\n        \"\"\"\n        Starts the bot and listens for incoming messages, handling them with\n        the defined handlers.\n        \"\"\"\n        self.updater.start_polling()\n\n    def stop_bot(self) -> None:\n        \"\"\"\n        Stops the bot and polling.\n        \"\"\"\n        self.updater.stop()\n\nif __name__ == \"__main__\":\n    logger.info(\"This module is not intended to be run directly.\")\n\n## adapters/__init__.py\n\n\"\"\"\nThis module initializes the adapter components of the Translategram application,\nspecifically focusing on the Telegram bot interaction. It provides an interface\nfor sending and receiving messages through a Telegram bot, leveraging the\npython-telegram-bot library. It integrates with the Translator module to\ntranslate received messages.\n\"\"\"\n\nfrom typing import Dict, Any\nfrom telegram import Bot, Update\nfrom telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext\n# Import the Translator module for message translation\nfrom translator import Translator\n\nclass TelegramBotAdapter:\n    \"\"\"\n    This class provides methods to interact with the Telegram bot, including\n    sending messages and handling incoming messages with translation.\n    \"\"\"\n\n    def __init__(self, token: str, translator: Translator):\n        \"\"\"\n        Initializes the TelegramBotAdapter with the necessary token and a Translator instance.\n\n        Args:\n            token (str): The token for the Telegram bot, used for authentication.\n            translator (Translator): An instance of the Translator class for translating messages.\n        \"\"\"\n        self.token = token\n        self.translator = translator\n        self.bot = Bot(token)\n        self.updater = Updater(token, use_context=True)\n        self.dispatcher = self.updater.dispatcher\n\n    def send_message(self, chat_id: int, text: str) -> None:\n        \"\"\"\n        Sends a message to a specified chat ID through the Telegram bot.\n\n        Args:\n            chat_id (int): The chat ID to send the message to.\n            text (str): The text of the message to be sent.\n        \"\"\"\n        self.bot.send_message(chat_id=chat_id, text=text)\n\n    def receive_message(self) -> None:\n        \"\"\"\n        Starts the bot and listens for incoming messages, handling them with\n        the defined handlers.\n        \"\"\"\n        # Define a command handler and a message handler\n        start_handler = CommandHandler('start', self.start)\n        message_handler = MessageHandler(Filters.text & ~Filters.command, self.handle_message)\n\n        # Add handlers to the dispatcher\n        self.dispatcher.add_handler(start_handler)\n        self.dispatcher.add_handler(message_handler)\n\n        # Start the bot\n        self.updater.start_polling()\n\n    def start(self, update: Update, context: CallbackContext) -> None:\n        \"\"\"\n        Handles the /start command sent to the Telegram bot.\n\n        Args:\n            update (Update): The update instance representing the incoming update.\n            context (CallbackContext): The context of the callback.\n        \"\"\"\n        update.message.reply_text('Welcome to Translategram! Send me a text to translate.')\n\n    def handle_message(self, update: Update, context: CallbackContext) -> None:\n        \"\"\"\n        Handles incoming messages that are not commands by translating them.\n\n        Args:\n            update (Update): The update instance representing the incoming update.\n            context (CallbackContext): The context of the callback.\n        \"\"\"\n        text = update.message.text\n        try:\n            # Translate the text using the Translator module\n            translated_text = self.translator.translate(text, target_lang='en', service='Google')  # Example target language and service\n            update.message.reply_text(f'Translated text: {translated_text}')\n        except Exception as e:\n            update.message.reply_text('Sorry, the translation could not be completed.')\n            # Log the error for debugging purposes\n            print(f\"Translation error: {e}\")\n\n# Ensure that this module can be imported without executing any code immediately\nif __name__ == \"__main__\":\n    print(\"This module is not intended to be run directly.\")\n\n## services/google_translate.py\n\n\"\"\"\nThis module implements the Google Cloud Translation API integration for the Translategram application.\nIt provides functionality to translate text using Google's translation service.\n\"\"\"\n\nfrom typing import Dict\nimport requests\nfrom requests.exceptions import HTTPError, ConnectionError\n\nclass TranslationServiceError(Exception):\n    \"\"\"Exception raised for errors in the translation service.\"\"\"\n    pass\n\nclass GoogleTranslate:\n    \"\"\"\n    A class to handle translations using the Google Cloud Translation API.\n    \"\"\"\n\n    def __init__(self, api_key: str) -> None:\n        \"\"\"\n        Initializes the GoogleTranslate instance with the necessary API key.\n\n        Args:\n            api_key (str): The API key for accessing the Google Cloud Translation API.\n        \"\"\"\n        self.api_key = api_key\n        self.base_url = \"https://translation.googleapis.com/language/translate/v2\"\n\n    def translate(self, text: str, target_lang: str) -> str:\n        \"\"\"\n        Translates a given text into the target language using the Google Cloud Translation API.\n\n        Args:\n            text (str): The text to be translated.\n            target_lang (str): The target language code (e.g., 'en' for English).\n\n        Returns:\n            str: The translated text.\n\n        Raises:\n            TranslationServiceError: If the translation request fails, the API returns an error, or parsing fails.\n        \"\"\"\n        params: Dict[str, str] = {\n            \"q\": text,\n            \"target\": target_lang,\n            \"key\": self.api_key\n        }\n        try:\n            response = requests.get(self.base_url, params=params)\n            response.raise_for_status()  # Raises HTTPError for HTTP errors\n            response_data = response.json()\n            translations = response_data.get(\"data\", {}).get(\"translations\", [])\n            if translations:\n                translated_text = translations[0].get(\"translatedText\", \"\")\n                if translated_text:\n                    return translated_text\n                else:\n                    raise TranslationServiceError(\"No translated text found in the response.\")\n            else:\n                raise TranslationServiceError(\"No translations found in the response.\")\n        except (HTTPError, ConnectionError) as e:\n            raise TranslationServiceError(f\"Network or HTTP error occurred: {str(e)}\")\n        except ValueError as e:\n            raise TranslationServiceError(f\"Failed to parse response JSON: {str(e)}\")\n\n# Note: Example usage and testing should be done outside of production code to avoid executing it upon module import.\n\n## services/deepl_translate.py\n\n\"\"\"\nThis module implements the DeepL API integration for the Translategram application.\nIt provides functionality to translate text using DeepL's translation service.\n\"\"\"\n\nfrom typing import Dict\nimport requests\nfrom requests.exceptions import HTTPError, ConnectionError\nimport logging\n\n# Set up basic logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass TranslationServiceError(Exception):\n    \"\"\"Exception raised for errors in the translation service.\"\"\"\n    pass\n\nclass DeepLTranslate:\n    \"\"\"\n    A class to handle translations using the DeepL API.\n    \"\"\"\n\n    def __init__(self, auth_key: str = \"default_auth_key\") -> None:\n        \"\"\"\n        Initializes the DeepLTranslate instance with the necessary authentication key.\n\n        Args:\n            auth_key (str): The authentication key for accessing the DeepL API.\n        \"\"\"\n        self.auth_key = auth_key\n        self.base_url = \"https://api.deepl.com/v2/translate\"\n\n    def translate(self, text: str, target_lang: str) -> str:\n        \"\"\"\n        Translates a given text into the target language using the DeepL API.\n\n        Args:\n            text (str): The text to be translated.\n            target_lang (str): The target language code (e.g., 'EN' for English).\n\n        Returns:\n            str: The translated text.\n\n        Raises:\n            TranslationServiceError: If the translation request fails, the API returns an error, or parsing fails.\n        \"\"\"\n        params: Dict[str, str] = {\n            \"auth_key\": self.auth_key,\n            \"text\": text,\n            \"target_lang\": target_lang\n        }\n        try:\n            response = requests.post(self.base_url, data=params)\n            response.raise_for_status()  # Raises HTTPError for HTTP errors\n            response_data = response.json()\n            translations = response_data.get(\"translations\", [])\n            if translations:\n                translated_text = translations[0].get(\"text\", \"\")\n                if translated_text:\n                    return translated_text\n                else:\n                    raise TranslationServiceError(\"No translated text found in the response.\")\n            else:\n                raise TranslationServiceError(\"No translations found in the response.\")\n        except (HTTPError, ConnectionError) as e:\n            logger.error(f\"Network or HTTP error occurred: {e}\")\n            raise TranslationServiceError(f\"Network or HTTP error occurred: {str(e)}\")\n        except (ValueError, KeyError, TypeError) as e:\n            logger.error(f\"Failed to parse response JSON or access expected data: {e}\")\n            raise TranslationServiceError(f\"Failed to parse response JSON or access expected data: {str(e)}\")\n\n## services/__init__.py\n\n\"\"\"\nThis module initializes the translation service components of the Translategram application.\nIt provides a unified interface for different translation services such as Google Cloud Translation API\nand DeepL API. This allows for easy addition of new translation services in the future.\n\"\"\"\n\nfrom typing import Any, Dict, Callable\nfrom .google_translate import GoogleTranslate\nfrom .deepl_translate import DeepLTranslate\n\nclass TranslationServiceFactory:\n    \"\"\"\n    A factory class to create instances of translation services based on the service name.\n    Utilizes a registration mechanism to allow for easy addition of new services.\n    \"\"\"\n\n    _services: Dict[str, Callable] = {}\n\n    def register_service(self, name: str, constructor: Callable) -> None:\n        \"\"\"\n        Registers a new translation service.\n\n        Args:\n            name (str): The name of the translation service.\n            constructor (Callable): The constructor of the translation service.\n        \"\"\"\n        self._services[name] = constructor\n\n    def get_service(self, name: str) -> Any:\n        \"\"\"\n        Creates an instance of a registered translation service.\n\n        Args:\n            name (str): The name of the translation service to create.\n\n        Returns:\n            An instance of the requested translation service.\n\n        Raises:\n            ValueError: If the requested service is not registered.\n        \"\"\"\n        if name in self._services:\n            return self._services[name]()\n        else:\n            raise ValueError(f\"Service {name} not registered\")\n\n# Example of how to register services\n# Assuming this code is executed in an initialization phase of the application\nservice_factory = TranslationServiceFactory()\nservice_factory.register_service('Google', GoogleTranslate)\nservice_factory.register_service('DeepL', DeepLTranslate)\n\n",
        "design": {
            "0": {
                "relative_path": "translategram/translategram/translator_services.py",
                "fqn_list": "translategram/translategram/translator_services.py/MtranslateTranslatorService/__init__",
                "class": "translategram/translategram/translator_services.py.MtranslateTranslatorService",
                "signature": "def __init__(self) -> None:"
            },
            "1": {
                "relative_path": "translategram/translategram/cache.py",
                "fqn_list": "translategram/translategram/cache.py/PickleCache/__init__",
                "class": "translategram/translategram/cache.py.PickleCache",
                "signature": "def __init__(self, obj: object, filename: str = \"translation.data\") -> None:"
            },
            "2": {
                "relative_path": "translategram/translategram/cache.py",
                "fqn_list": "translategram/translategram/cache.py/PickleCache/__del__",
                "class": "translategram/translategram/cache.py.PickleCache",
                "signature": "def __del__(self) -> None:"
            },
            "3": {
                "relative_path": "translategram/translategram/translator.py",
                "fqn_list": "translategram/translategram/translator.py/Translator/__init__",
                "class": "translategram/translategram/translator.py.Translator",
                "signature": "def __init__(self, translator_service: TranslatorService, cache_system: Union[Type[Cache], None] = None) -> None:"
            },
            "4": {
                "relative_path": "translategram/translategram/translator.py",
                "fqn_list": "translategram/translategram/translator.py/Translator/handler_translator",
                "class": "translategram/translategram/translator.py.Translator",
                "signature": "def handler_translator(self, message: str, source_lang: str) -> Callable[\n        [Callable[..., object]], Callable[[Any, Any, str], Coroutine[Any, Any, Any]]\n    ]:"
            },
            "5": {
                "relative_path": "translategram/translategram/translator.py",
                "fqn_list": "translategram/translategram/translator.py/Translator/dynamic_handler_translator",
                "class": "translategram/translategram/translator.py.Translator",
                "signature": "def dynamic_handler_translator(self, message_func: Callable[[str, Any], str], source_lang: str = \"auto\") -> Callable[\n        [Callable[..., object]], Callable[[Any, Any], Coroutine[Any, Any, Any]]\n    ]:"
            },
            "6": {
                "relative_path": "translategram/python_telegram_bot_translator/adapter.py",
                "fqn_list": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/__init__",
                "class": "translategram/python_telegram_bot_translator/adapter.py.PythonTelegramBotAdapter",
                "signature": "def __init__(self, translator_service: Type[TranslatorService], cache_system: Union[Type[Cache], None] = None) -> None:"
            },
            "7": {
                "relative_path": "translategram/python_telegram_bot_translator/adapter.py",
                "fqn_list": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/handler_translator",
                "class": "translategram/python_telegram_bot_translator/adapter.py.PythonTelegramBotAdapter",
                "signature": "def handler_translator(self, message: str, source_lang: str = \"auto\") -> Callable[\n        [Callable[[Any, Any, str], object]],\n        Callable[[Any, Any, str], Coroutine[Any, Any, Any]],\n    ]:"
            },
            "8": {
                "relative_path": "translategram/python_telegram_bot_translator/adapter.py",
                "fqn_list": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/dynamic_handler_translator",
                "class": "translategram/python_telegram_bot_translator/adapter.py.PythonTelegramBotAdapter",
                "signature": "def dynamic_handler_translator(self, message_func: Callable[[str, Any], str], source_lang: str = \"auto\") -> Callable[\n        [Callable[..., object]], Callable[[Any, Any], Coroutine[Any, Any, Any]]\n    ]:"
            }
        }
    },
    "sphecerix": {
        "generated code": "## main.py\nimport numpy as np\nfrom utils import Utils\nfrom rotation import Rotation\nfrom visualization import Visualization\n\nclass Examples:\n    @staticmethod\n    def demo_rotation():\n        angle = np.pi / 4  # 45 degrees in radians\n        axis = [0, 0, 1]  # Z-axis\n        l, m, n = 2, 1, -1  # Quantum numbers\n        rotated_harmonics = Rotation.rotate_harmonics(angle, axis, l, m, n)\n        print(f\"Rotated harmonics: {rotated_harmonics}\")\n\n    @staticmethod\n    def demo_visualization():\n        # Spherical Harmonic Visualization\n        phi, theta = np.mgrid[0:2*np.pi:100j, 0:np.pi:50j]\n        values = np.sin(theta)**2 * np.cos(phi)\n        harmonic_data = (phi, theta, values)\n        Visualization.plot_spherical_harmonic(harmonic_data)\n\n        # Atomic Orbital Visualization\n        x, y, z = np.mgrid[-1:1:20j, -1:1:20j, -1:1:20j]\n        values = np.sin(np.pi*x) * np.sin(np.pi*y) * np.sin(np.pi*z)\n        orbital_data = (x.flatten(), y.flatten(), z.flatten(), values.flatten())\n        Visualization.plot_atomic_orbital(orbital_data)\n\nif __name__ == \"__main__\":\n    Examples.demo_rotation()\n    Examples.demo_visualization()\n\n## visualization.py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nclass Visualization:\n    @staticmethod\n    def plot_spherical_harmonic(harmonic_data: np.ndarray) -> None:\n        \"\"\"\n        Plot spherical harmonic data on a 3D sphere.\n\n        Parameters:\n        harmonic_data (np.ndarray): The spherical harmonic data to plot, expected to be\n                                    an array of shape (phi, theta, values) where phi and theta\n                                    are meshgrid arrays of angles in radians and values are the\n                                    corresponding spherical harmonic values at each (phi, theta).\n\n        Returns:\n        None\n        \"\"\"\n        phi, theta, values = harmonic_data\n        # Convert to Cartesian coordinates for plotting\n        x = np.abs(values) * np.sin(theta) * np.cos(phi)\n        y = np.abs(values) * np.sin(theta) * np.sin(phi)\n        z = np.abs(values) * np.cos(theta)\n\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n        ax.plot_surface(x, y, z, facecolors=plt.cm.viridis(values / np.max(values)))\n        ax.set_title('Spherical Harmonic')\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n        plt.show()\n\n    @staticmethod\n    def plot_atomic_orbital(orbital_data: np.ndarray) -> None:\n        \"\"\"\n        Plot atomic orbital data on a 3D grid.\n\n        Parameters:\n        orbital_data (np.ndarray): The atomic orbital data to plot, expected to be\n                                   an array of shape (x, y, z, values) where x, y, z are\n                                   meshgrid arrays of coordinates and values are the\n                                   corresponding atomic orbital values at each (x, y, z).\n\n        Returns:\n        None\n        \"\"\"\n        x, y, z, values = orbital_data\n        # Normalize values for color mapping\n        norm = plt.Normalize(values.min(), values.max())\n        colors = plt.cm.viridis(norm(values))\n\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n        ax.scatter(x, y, z, c=colors, marker='o')\n        ax.set_title('Atomic Orbital')\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_zlabel('Z')\n        plt.show()\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example data for spherical harmonic\n    phi, theta = np.mgrid[0:2*np.pi:100j, 0:np.pi:50j]\n    values = np.sin(theta)**2 * np.cos(phi)\n    harmonic_data = (phi, theta, values)\n    Visualization.plot_spherical_harmonic(harmonic_data)\n\n    # Example data for atomic orbital\n    x, y, z = np.mgrid[-1:1:20j, -1:1:20j, -1:1:20j]\n    values = np.sin(np.pi*x) * np.sin(np.pi*y) * np.sin(np.pi*z)\n    orbital_data = (x.flatten(), y.flatten(), z.flatten(), values.flatten())\n    Visualization.plot_atomic_orbital(orbital_data)\n\n## rotation.py\nimport numpy as np\nfrom utils import Utils  # Import the Utils class for calculating the Wigner D matrix\n\nclass Rotation:\n    def __init__(self):\n        \"\"\"\n        The Rotation class doesn't require initialization of member variables at this point,\n        as its primary function is to perform operations using static methods from the Utils class.\n        \"\"\"\n        pass\n\n    @staticmethod\n    def rotate_harmonics(angle: float, axis: list, l: int, m: int, n: int) -> np.ndarray:\n        \"\"\"\n        Rotate spherical harmonics using the Wigner D matrix.\n\n        Parameters:\n        angle (float): Rotation angle in radians.\n        axis (list): Rotation axis as a list of three floats.\n        l (int): Total angular momentum quantum number.\n        m (int): Magnetic quantum number, initial state.\n        n (int): Magnetic quantum number, final state.\n\n        Returns:\n        np.ndarray: The rotated spherical harmonics as an array.\n        \"\"\"\n        # Validate the axis\n        if len(axis) != 3:\n            raise ValueError(\"Axis must be a list of three floats.\")\n        if not all(isinstance(x, (float, int)) for x in axis):\n            raise ValueError(\"Axis values must be floats or ints.\")\n\n        # Normalize the axis to ensure it's a unit vector\n        axis = np.array(axis)\n        norm = np.linalg.norm(axis)\n        if norm == 0:\n            raise ValueError(\"Axis vector cannot be zero.\")\n        axis_normalized = axis / norm\n\n        # Calculate the Wigner D matrix for the given quantum numbers and rotation angle\n        wigner_d_matrix = Utils.calculate_wigner_d_matrix(l, m, n, angle)\n\n        # Here, we should apply the Wigner D matrix to the spherical harmonics.\n        # This example assumes a placeholder function for obtaining spherical harmonics,\n        # which should be replaced with the actual implementation.\n        harmonics = Rotation.get_spherical_harmonics(l, m)  # Placeholder function\n        rotated_harmonics = np.dot(wigner_d_matrix, harmonics)  # Apply rotation\n\n        return rotated_harmonics\n\n    @staticmethod\n    def get_spherical_harmonics(l: int, m: int) -> np.ndarray:\n        \"\"\"\n        Placeholder function to obtain spherical harmonics.\n        This should be replaced with the actual implementation.\n\n        Parameters:\n        l (int): Total angular momentum quantum number.\n        m (int): Magnetic quantum number.\n\n        Returns:\n        np.ndarray: Spherical harmonics for the given quantum numbers.\n        \"\"\"\n        # Placeholder implementation - returns a dummy array\n        return np.array([l, m, 1.0])  # This should be replaced with actual spherical harmonics\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example values for rotation\n    angle = np.pi / 4  # 45 degrees in radians\n    axis = [0, 0, 1]  # Z-axis\n    l, m, n = 2, 1, -1  # Quantum numbers\n\n    # Perform the rotation\n    rotated_harmonics = Rotation.rotate_harmonics(angle, axis, l, m, n)\n    print(f\"Rotated harmonics: {rotated_harmonics}\")\n\n## utils.py\nimport numpy as np\n\nclass Utils:\n    @staticmethod\n    def calculate_wigner_d_matrix(l: int, m: int, n: int, beta: float) -> np.ndarray:\n        \"\"\"\n        Calculate the Wigner D matrix for given quantum numbers and rotation angle.\n\n        Parameters:\n        l (int): Total angular momentum quantum number.\n        m (int): Magnetic quantum number, initial state.\n        n (int): Magnetic quantum number, final state.\n        beta (float): Rotation angle in radians.\n\n        Returns:\n        np.ndarray: The calculated Wigner D matrix element.\n        \"\"\"\n        # Factorial function for convenience\n        def factorial(x):\n            return np.math.factorial(x)\n\n        # Ensure valid quantum numbers\n        if not (abs(m) <= l and abs(n) <= l):\n            raise ValueError(\"Invalid quantum numbers for Wigner D matrix calculation.\")\n\n        # Calculate the Wigner d-matrix element using the formula\n        # d^l_{mn}(beta) = sqrt((l+m)!(l-m)!(l+n)!(l-n)!) * sum_s ( (-1)^s * \n        #                   [cos(beta/2)]^(2l+m-n-2s) * [-sin(beta/2)]^(n-m+2s) /\n        #                   (s!(l+m-s)!(l-n-s)!(n-m+s)!) )\n        # where the sum is over all s such that the factorial arguments are non-negative.\n        d_matrix_element = 0\n        for s in range(max(0, m-n), min(l+m, l-n)+1):\n            term = ((-1)**s * (np.cos(beta/2)**(2*l + m - n - 2*s)) *\n                    (np.sin(beta/2)**(n - m + 2*s)) /\n                    (factorial(s) * factorial(l+m-s) * factorial(l-n-s) * factorial(n-m+s)))\n            d_matrix_element += term\n\n        # The Wigner D matrix is a single element for the specified m, n, so we return it directly\n        return d_matrix_element\n\n# Example usage\nif __name__ == \"__main__\":\n    # Calculate a specific Wigner D matrix element\n    l, m, n, beta = 2, 1, -1, np.pi / 4  # Example values\n    wigner_d_element = Utils.calculate_wigner_d_matrix(l, m, n, beta)\n    print(f\"Wigner D matrix element for l={l}, m={m}, n={n}, beta={beta}: {wigner_d_element}\")\n\n## examples.py\nimport numpy as np\nfrom rotation import Rotation\nfrom visualization import Visualization\n\nclass Examples:\n    @staticmethod\n    def demo_rotation(angle: float = np.pi / 4, axis: list = [0, 0, 1], l: int = 2, m: int = 1, n: int = -1) -> None:\n        \"\"\"\n        Demonstrates the rotation of spherical harmonics.\n\n        Parameters:\n        angle (float): Rotation angle in radians. Default is \u03c0/4.\n        axis (list): Rotation axis as a list of three floats. Default is the Z-axis.\n        l (int): Total angular momentum quantum number. Default is 2.\n        m (int): Magnetic quantum number, initial state. Default is 1.\n        n (int): Magnetic quantum number, final state. Default is -1.\n        \"\"\"\n        rotated_harmonics = Rotation.rotate_harmonics(angle, axis, l, m, n)\n        print(f\"Rotated harmonics for l={l}, m={m}, n={n}, angle={angle}, axis={axis}: {rotated_harmonics}\")\n\n    @staticmethod\n    def demo_visualization() -> None:\n        \"\"\"\n        Demonstrates the visualization of spherical harmonics and atomic orbitals.\n        \"\"\"\n        # Spherical Harmonic Visualization\n        phi, theta = np.mgrid[0:2*np.pi:100j, 0:np.pi:50j]\n        values = np.sin(theta)**2 * np.cos(phi)\n        harmonic_data = (phi, theta, values)\n        Visualization.plot_spherical_harmonic(harmonic_data)\n\n        # Atomic Orbital Visualization\n        x, y, z = np.mgrid[-1:1:20j, -1:1:20j, -1:1:20j]\n        values = np.sin(np.pi*x) * np.sin(np.pi*y) * np.sin(np.pi*z)\n        orbital_data = (x.flatten(), y.flatten(), z.flatten(), values.flatten())\n        Visualization.plot_atomic_orbital(orbital_data)\n\nif __name__ == \"__main__\":\n    Examples.demo_rotation()\n    Examples.demo_visualization()\n\n",
        "design": {
            "0": {
                "relative_path": "sphecerix/matrixplot.py",
                "fqn_list": "sphecerix/matrixplot.py/visualize_matrices",
                "class": null,
                "signature": "def visualize_matrices(symops, numcols = 3, highlight_groups = None, filename = None, figsize = (7,5), xlabelrot = 0):"
            },
            "1": {
                "relative_path": "sphecerix/matrixplot.py",
                "fqn_list": "sphecerix/matrixplot.py/plot_highlight_groups",
                "class": null,
                "signature": "def plot_highlight_groups(axh, groups, mat):"
            },
            "2": {
                "relative_path": "sphecerix/matrixplot.py",
                "fqn_list": "sphecerix/matrixplot.py/plot_matrix",
                "class": null,
                "signature": "def plot_matrix(ax, mat, bfs, title = None, xlabelrot = 0):"
            },
            "3": {
                "relative_path": "sphecerix/molecule.py",
                "fqn_list": "sphecerix/molecule.py/Molecule/__init__",
                "class": "sphecerix/molecule.py.Molecule",
                "signature": "def __init__(self, _name = 'unknown'):"
            },
            "4": {
                "relative_path": "sphecerix/molecule.py",
                "fqn_list": "sphecerix/molecule.py/Molecule/__str__",
                "class": "sphecerix/molecule.py.Molecule",
                "signature": "def __str__(self):"
            },
            "5": {
                "relative_path": "sphecerix/molecule.py",
                "fqn_list": "sphecerix/molecule.py/Molecule/add_atom",
                "class": "sphecerix/molecule.py.Molecule",
                "signature": "def add_atom(self, atom, x, y, z, unit = 'bohr'):"
            },
            "6": {
                "relative_path": "sphecerix/molecule.py",
                "fqn_list": "sphecerix/molecule.py/Molecule/build_basis",
                "class": "sphecerix/molecule.py.Molecule",
                "signature": "def build_basis(self, molset):"
            },
            "7": {
                "relative_path": "sphecerix/atomic_wave_functions.py",
                "fqn_list": "sphecerix/atomic_wave_functions.py/wffield",
                "class": null,
                "signature": "def wffield(n, l, m, d, npts):"
            },
            "8": {
                "relative_path": "sphecerix/atomic_wave_functions.py",
                "fqn_list": "sphecerix/atomic_wave_functions.py/wffield_l",
                "class": null,
                "signature": "def wffield_l(n, l, d, npts):"
            },
            "9": {
                "relative_path": "sphecerix/atomic_wave_functions.py",
                "fqn_list": "sphecerix/atomic_wave_functions.py/wfcart",
                "class": null,
                "signature": "def wfcart(n, l, m, x, y, z):"
            },
            "10": {
                "relative_path": "sphecerix/atomic_wave_functions.py",
                "fqn_list": "sphecerix/atomic_wave_functions.py/wf",
                "class": null,
                "signature": "def wf(n, l, m, r, theta, phi):"
            },
            "11": {
                "relative_path": "sphecerix/atomic_wave_functions.py",
                "fqn_list": "sphecerix/atomic_wave_functions.py/angular",
                "class": null,
                "signature": "def angular(l, m, theta, phi):"
            },
            "12": {
                "relative_path": "sphecerix/atomic_wave_functions.py",
                "fqn_list": "sphecerix/atomic_wave_functions.py/radial",
                "class": null,
                "signature": "def radial(n, l, r):"
            },
            "13": {
                "relative_path": "sphecerix/wignerd.py",
                "fqn_list": "sphecerix/wignerd.py/tesseral_wigner_D",
                "class": null,
                "signature": "def tesseral_wigner_D(l, Robj):"
            },
            "14": {
                "relative_path": "sphecerix/wignerd.py",
                "fqn_list": "sphecerix/wignerd.py/tesseral_wigner_D_mirror",
                "class": null,
                "signature": "def tesseral_wigner_D_mirror(l, normal):"
            },
            "15": {
                "relative_path": "sphecerix/wignerd.py",
                "fqn_list": "sphecerix/wignerd.py/tesseral_wigner_D_improper",
                "class": null,
                "signature": "def tesseral_wigner_D_improper(l, Robj):"
            },
            "16": {
                "relative_path": "sphecerix/wignerd.py",
                "fqn_list": "sphecerix/wignerd.py/wigner_D",
                "class": null,
                "signature": "def wigner_D(l, Robj):"
            },
            "17": {
                "relative_path": "sphecerix/wignerd.py",
                "fqn_list": "sphecerix/wignerd.py/wigner_d",
                "class": null,
                "signature": "def wigner_d(l, beta):"
            },
            "18": {
                "relative_path": "sphecerix/wignerd.py",
                "fqn_list": "sphecerix/wignerd.py/wigner_d_element_euler_angles",
                "class": null,
                "signature": "def wigner_d_element_euler_angles(l, m1, m2, beta):"
            },
            "19": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/SymmetryOperations/__init__",
                "class": "sphecerix/symmetry_operations.py.SymmetryOperations",
                "signature": "def __init__(self, mol):"
            },
            "20": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/SymmetryOperations/add",
                "class": "sphecerix/symmetry_operations.py.SymmetryOperations",
                "signature": "def add(self, name, label = None, vec = None, angle = None):"
            },
            "21": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/SymmetryOperations/run",
                "class": "sphecerix/symmetry_operations.py.SymmetryOperations",
                "signature": "def run(self):"
            },
            "22": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Operation/__init__",
                "class": "sphecerix/symmetry_operations.py.Operation",
                "signature": "def __init__(self, name):"
            },
            "23": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Operation/set_atomic_id",
                "class": "sphecerix/symmetry_operations.py.Operation",
                "signature": "def set_atomic_id(self, idx):"
            },
            "24": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Identity/__init__",
                "class": "sphecerix/symmetry_operations.py.Identity",
                "signature": "def __init__(self):"
            },
            "25": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Identity/get_matrix",
                "class": "sphecerix/symmetry_operations.py.Identity",
                "signature": "def get_matrix(self):"
            },
            "26": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Identity/get_wigner_matrix",
                "class": "sphecerix/symmetry_operations.py.Identity",
                "signature": "def get_wigner_matrix(self, l):"
            },
            "27": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Inversion/__init__",
                "class": "sphecerix/symmetry_operations.py.Inversion",
                "signature": "def __init__(self):"
            },
            "28": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Inversion/get_matrix",
                "class": "sphecerix/symmetry_operations.py.Inversion",
                "signature": "def get_matrix(self):"
            },
            "29": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Inversion/get_wigner_matrix",
                "class": "sphecerix/symmetry_operations.py.Inversion",
                "signature": "def get_wigner_matrix(self, l):"
            },
            "30": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Rotation/__init__",
                "class": "sphecerix/symmetry_operations.py.Rotation",
                "signature": "def __init__(self, label, axis, angle):"
            },
            "31": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Rotation/get_matrix",
                "class": "sphecerix/symmetry_operations.py.Rotation",
                "signature": "def get_matrix(self):"
            },
            "32": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Rotation/get_wigner_matrix",
                "class": "sphecerix/symmetry_operations.py.Rotation",
                "signature": "def get_wigner_matrix(self, l):"
            },
            "33": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Mirror/__init__",
                "class": "sphecerix/symmetry_operations.py.Mirror",
                "signature": "def __init__(self, label, normal):"
            },
            "34": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Mirror/get_matrix",
                "class": "sphecerix/symmetry_operations.py.Mirror",
                "signature": "def get_matrix(self):"
            },
            "35": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/Mirror/get_wigner_matrix",
                "class": "sphecerix/symmetry_operations.py.Mirror",
                "signature": "def get_wigner_matrix(self, l):"
            },
            "36": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/ImproperRotation/__init__",
                "class": "sphecerix/symmetry_operations.py.ImproperRotation",
                "signature": "def __init__(self, label, axis, angle):"
            },
            "37": {
                "relative_path": "sphecerix/symmetry_operations.py",
                "fqn_list": "sphecerix/symmetry_operations.py/ImproperRotation/get_matrix",
                "class": "sphecerix/symmetry_operations.py.ImproperRotation",
                "signature": "def get_matrix(self):"
            },
            "38": {
                "relative_path": "sphecerix/tesseral.py",
                "fqn_list": "sphecerix/tesseral.py/tesseral_transformation",
                "class": null,
                "signature": "def tesseral_transformation(l):"
            },
            "39": {
                "relative_path": "sphecerix/tesseral.py",
                "fqn_list": "sphecerix/tesseral.py/permutation_sh_car",
                "class": null,
                "signature": "def permutation_sh_car():"
            },
            "40": {
                "relative_path": "sphecerix/basis_functions.py",
                "fqn_list": "sphecerix/basis_functions.py/BasisFunction/__init__",
                "class": "sphecerix/basis_functions.py.BasisFunction",
                "signature": "def __init__(self, n, l, m):"
            },
            "41": {
                "relative_path": "sphecerix/basis_functions.py",
                "fqn_list": "sphecerix/basis_functions.py/BasisFunction/__get_name",
                "class": "sphecerix/basis_functions.py.BasisFunction",
                "signature": "def __get_name(self):"
            },
            "42": {
                "relative_path": "sphecerix/basis_functions.py",
                "fqn_list": "sphecerix/basis_functions.py/BasisFunction/__get_type",
                "class": "sphecerix/basis_functions.py.BasisFunction",
                "signature": "def __get_type(self):"
            },
            "43": {
                "relative_path": "docs/conf.py",
                "fqn_list": "docs/conf.py/setup",
                "class": null,
                "signature": "def setup(app):"
            },
            "44": {
                "relative_path": "examples/fz3_rotation.py",
                "fqn_list": "examples/fz3_rotation.py/main",
                "class": null,
                "signature": "def main():"
            },
            "45": {
                "relative_path": "examples/ethylene.py",
                "fqn_list": "examples/ethylene.py/main",
                "class": null,
                "signature": "def main():"
            },
            "46": {
                "relative_path": "examples/dz2_rotation.py",
                "fqn_list": "examples/dz2_rotation.py/main",
                "class": null,
                "signature": "def main():"
            },
            "47": {
                "relative_path": "examples/nh3.py",
                "fqn_list": "examples/nh3.py/main",
                "class": null,
                "signature": "def main():"
            }
        }
    },
    "postgres-tq": {
        "generated code": "## main.py\nfrom flask import Flask\nfrom api import add_task, retry_task, complete_task, lease_task, handle_exception\n\napp = Flask(__name__)\n\n# Register API endpoints\napp.add_url_rule('/add_task', view_func=add_task, methods=['POST'])\napp.add_url_rule('/retry_task/<task_id>', view_func=retry_task, methods=['POST'])\napp.add_url_rule('/complete_task/<task_id>', view_func=complete_task, methods=['POST'])\napp.add_url_rule('/lease_task', view_func=lease_task, methods=['GET'])\n\n# Register error handler\napp.register_error_handler(Exception, handle_exception)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n## api.py\nfrom flask import Flask, request, jsonify\nfrom task_queue import TaskQueue\nimport psycopg2\n\napp = Flask(__name__)\ntask_queue = TaskQueue()\n\ndef make_response(message=None, data=None, status=200):\n    \"\"\"Generate a JSON response with a standard structure.\"\"\"\n    response = {\"message\": message}\n    if data is not None:\n        response[\"data\"] = data\n    return jsonify(response), status\n\ndef validate_task_data(task_data):\n    \"\"\"Validates the task data to ensure it contains required keys.\"\"\"\n    required_keys = ['type', 'details']\n    return all(key in task_data for key in required_keys)\n\n@app.errorhandler(Exception)\ndef handle_exception(e):\n    \"\"\"Handle exceptions based on their type.\"\"\"\n    if isinstance(e, psycopg2.DatabaseError):\n        response = {\"error\": \"Database error occurred\"}\n        status_code = 500\n    elif isinstance(e, KeyError):\n        response = {\"error\": \"Invalid data provided\"}\n        status_code = 400\n    else:\n        response = {\"error\": str(e)}\n        status_code = 500\n    return jsonify(response), status_code\n\n@app.route('/add_task', methods=['POST'])\ndef add_task():\n    \"\"\"\n    API endpoint to add a task to the queue.\n    Expects a JSON payload with task data.\n    \"\"\"\n    task_data = request.json\n    if not task_data or not validate_task_data(task_data):\n        return make_response(message=\"Invalid task data\", status=400)\n    task_id = task_queue.add_task(task_data)\n    return make_response(message=\"Task added successfully\", data={\"task_id\": task_id})\n\n@app.route('/retry_task/<task_id>', methods=['POST'])\ndef retry_task(task_id: str):\n    \"\"\"\n    API endpoint to retry a specific task.\n    \"\"\"\n    result = task_queue.retry_task(task_id)\n    if result:\n        return make_response(message=f\"Task {task_id} retried successfully\")\n    else:\n        return make_response(message=\"Failed to retry task\", status=400)\n\n@app.route('/complete_task/<task_id>', methods=['POST'])\ndef complete_task(task_id: str):\n    \"\"\"\n    API endpoint to mark a task as completed.\n    \"\"\"\n    result = task_queue.complete_task(task_id)\n    if result:\n        return make_response(message=f\"Task {task_id} completed successfully\")\n    else:\n        return make_response(message=\"Failed to complete task\", status=400)\n\n@app.route('/lease_task', methods=['GET'])\ndef lease_task():\n    \"\"\"\n    API endpoint to lease a task for processing.\n    \"\"\"\n    task = task_queue.lease_task()\n    if task:\n        return make_response(message=\"Task leased successfully\", data={\"task\": task})\n    else:\n        return make_response(message=\"No task available for leasing\", status=404)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n## db.py\nimport logging\nimport time\n\ntry:\n    import psycopg2\n    from psycopg2.extras import RealDictCursor\nexcept ImportError:\n    raise ImportError(\"psycopg2 is required for this module. Please install it using pip.\")\n\nfrom config import Config\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\nclass DB:\n    \"\"\"\n    Handles database connections and query execution.\n    Utilizes psycopg2 for PostgreSQL interaction.\n    \"\"\"\n    def __init__(self):\n        self.connection = None\n        self.connect()\n\n    def connect(self, attempts=3, delay=5):\n        \"\"\"\n        Establishes a database connection using credentials from Config, with retry logic.\n\n        Args:\n            attempts (int): Number of connection attempts before giving up.\n            delay (int): Delay in seconds between connection attempts.\n        \"\"\"\n        attempt = 0\n        while attempt < attempts:\n            try:\n                self.connection = psycopg2.connect(\n                    dbname=Config.db_credentials['dbname'],\n                    user=Config.db_credentials['user'],\n                    password=Config.db_credentials['password'],\n                    host=Config.db_credentials['host'],\n                    port=Config.db_credentials['port']\n                )\n                self.connection.autocommit = True\n                logging.info(\"Database connection established successfully.\")\n                return\n            except psycopg2.DatabaseError as e:\n                logging.error(f\"Attempt {attempt+1} failed: {e}\")\n                time.sleep(delay)  # Wait for a few seconds before retrying\n                attempt += 1\n                if attempt == attempts:\n                    logging.critical(\"All attempts to connect to the database have failed.\")\n                    raise e\n\n    def execute_query(self, query: str, params=None, fetch=False, commit=False):\n        \"\"\"\n        Executes a given SQL query with optional parameters and transaction control.\n\n        Args:\n            query (str): The SQL query to execute.\n            params (tuple, optional): Parameters to pass to the SQL query. Defaults to None.\n            fetch (bool, optional): Whether to fetch results. Defaults to False.\n            commit (bool, optional): Whether to commit the transaction. Defaults to False.\n\n        Returns:\n            list | None: The fetched results if fetch is True, otherwise None.\n        \"\"\"\n        try:\n            with self.connection.cursor(cursor_factory=RealDictCursor) as cursor:\n                cursor.execute(query, params)\n                if fetch:\n                    return cursor.fetchall()\n                if commit:\n                    self.connection.commit()\n        except psycopg2.Error as e:\n            logging.error(f\"Failed to execute query: {e}\")\n            if commit:\n                self.connection.rollback()\n            raise e\n\n## config.py\nimport os\n\nclass Config:\n    \"\"\"\n    Configuration class to hold database credentials and table name.\n    Reads values from environment variables with defaults for development.\n    \"\"\"\n    db_credentials = {\n        'dbname': os.getenv('DB_NAME', 'postgres'),\n        'user': os.getenv('DB_USER', 'postgres'),\n        'password': os.getenv('DB_PASSWORD', 'password'),\n        'host': os.getenv('DB_HOST', 'localhost'),\n        'port': int(os.getenv('DB_PORT', 5432))  # Ensure port is an integer\n    }\n    table_name = os.getenv('TABLE_NAME', 'task_queue')\n\n## task_queue.py\nimport logging\nfrom typing import Dict, Optional\nfrom db import DB\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\nclass TaskQueue:\n    \"\"\"\n    Manages task queue operations such as adding, retrying, completing, and leasing tasks.\n    Interacts with the database to execute task-related queries.\n    \"\"\"\n\n    def __init__(self):\n        self.db = DB()\n\n    def add_task(self, task_data: Dict) -> str:\n        \"\"\"\n        Adds a new task to the queue.\n\n        Args:\n            task_data (Dict): The task data to be added.\n\n        Returns:\n            str: The ID of the added task.\n        \"\"\"\n        query = \"INSERT INTO task_queue (data, status) VALUES (%s, %s) RETURNING id;\"\n        params = (task_data, 'pending')\n        try:\n            task_id = self.db.execute_query(query, params=params, fetch=True)\n            logging.info(f\"Task added with ID: {task_id[0]['id']}\")\n            return task_id[0]['id']\n        except Exception as e:\n            logging.error(f\"Failed to add task: {e}\")\n            raise\n\n    def retry_task(self, task_id: str) -> bool:\n        \"\"\"\n        Retries a specified task by resetting its status.\n\n        Args:\n            task_id (str): The ID of the task to retry.\n\n        Returns:\n            bool: True if the task status was successfully reset, False otherwise.\n        \"\"\"\n        query = \"UPDATE task_queue SET status = %s WHERE id = %s;\"\n        params = ('pending', task_id)\n        try:\n            self.db.execute_query(query, params=params)\n            logging.info(f\"Task {task_id} retried.\")\n            return True\n        except Exception as e:\n            logging.error(f\"Failed to retry task {task_id}: {e}\")\n            return False\n\n    def complete_task(self, task_id: str) -> bool:\n        \"\"\"\n        Marks a specified task as completed.\n\n        Args:\n            task_id (str): The ID of the task to mark as completed.\n\n        Returns:\n            bool: True if the task was successfully marked as completed, False otherwise.\n        \"\"\"\n        query = \"UPDATE task_queue SET status = %s WHERE id = %s;\"\n        params = ('completed', task_id)\n        try:\n            self.db.execute_query(query, params=params)\n            logging.info(f\"Task {task_id} completed.\")\n            return True\n        except Exception as e:\n            logging.error(f\"Failed to complete task {task_id}: {e}\")\n            return False\n\n    def lease_task(self) -> Optional[Dict]:\n        \"\"\"\n        Leases a task by setting its status to 'in_progress'.\n\n        Returns:\n            Optional[Dict]: The leased task data, or None if no task is available.\n        \"\"\"\n        query = \"UPDATE task_queue SET status = %s WHERE status = %s RETURNING id, data;\"\n        params = ('in_progress', 'pending')\n        try:\n            task = self.db.execute_query(query, params=params, fetch=True)\n            if task:\n                logging.info(f\"Task {task[0]['id']} leased.\")\n                return {'id': task[0]['id'], 'data': task[0]['data']}\n            else:\n                logging.info(\"No task available for leasing.\")\n                return None\n        except Exception as e:\n            logging.error(f\"Failed to lease task: {e}\")\n            return None\n\n",
        "design": {
            "0": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/__init__",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def __init__(self, dsn: str, queue_name: str, table_name: str = \"task_queue\", reset: bool = False, create_table: bool = False, ttl_zero_callback: Optional[\n            Callable[[UUID, Optional[str]], None]\n        ] = None):"
            },
            "1": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/connect",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def connect(self) -> None:"
            },
            "2": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/_create_queue_table",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def _create_queue_table(self) -> None:"
            },
            "3": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/__len__",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def __len__(self) -> int:"
            },
            "4": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/add",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def add(self, task: Dict[str, Any], lease_timeout: float, ttl: int = 3) -> str:"
            },
            "5": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/get",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def get(self) -> Tuple[Optional[Dict[str, Any]], Optional[UUID]]:"
            },
            "6": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/complete",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def complete(self, task_id: Optional[UUID]) -> None:"
            },
            "7": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/is_empty",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def is_empty(self) -> bool:"
            },
            "8": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/check_expired_leases",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def check_expired_leases(self) -> None:"
            },
            "9": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/get_updated_expired_task",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def get_updated_expired_task(self, task_id: UUID) -> Tuple[Optional[str], Optional[int]]:"
            },
            "10": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/_serialize",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def _serialize(self, task: Any) -> str:"
            },
            "11": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/_deserialize",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def _deserialize(self, blob: str) -> Any:"
            },
            "12": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/reschedule",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def reschedule(self, task_id: Optional[UUID]) -> None:"
            },
            "13": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/_reset",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def _reset(self) -> None:"
            },
            "14": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/prune_completed_tasks",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def prune_completed_tasks(self, before: int) -> None:"
            },
            "15": {
                "relative_path": "postgrestq/task_queue.py",
                "fqn_list": "postgrestq/task_queue.py/TaskQueue/__iter__",
                "class": "postgrestq/task_queue.py.TaskQueue",
                "signature": "def __iter__(self) -> Iterator[Tuple[Optional[Dict[str, Any]], Optional[UUID]]]:"
            }
        }
    },
    "cpu_simulator": {
        "generated code": "## main.py\nimport numpy as np\nimport pygame\nfrom typing import List, Dict\n\n# Importing utility functions from utils.py (assuming utils.py exists and contains these functions)\nfrom utils import binary_to_decimal, decimal_to_binary\n# Importing Assembler, CPU, and UI classes from their respective files\nfrom assembler import Assembler\nfrom cpu import CPU\nfrom ui import UI\n\nclass Main:\n    def __init__(self):\n        self.assembler = Assembler()\n        self.cpu = CPU()\n        self.ui = UI()\n\n    def run(self):\n        # Example assembly code\n        assembly_code = \"\"\"\n        LOAD R1, 10\n        ADD R2, R1\n        SUB R3, R2\n        \"\"\"\n        program = self.assembler.assemble(assembly_code)\n        self.cpu.load_program(program)\n        for instruction in program:\n            self.cpu.execute_instruction(instruction)\n        cpu_state = {\"R1\": self.cpu.registers[1], \"R2\": self.cpu.registers[2], \"R3\": self.cpu.registers[3]}\n        game_state = {\"PlayerX\": 100, \"PlayerY\": 150, \"Score\": 200}  # Placeholder for actual game state\n        while self.ui.handle_events():\n            self.ui.render(cpu_state, game_state)\n\nif __name__ == \"__main__\":\n    main = Main()\n    main.run()\n\n## ui.py\nimport pygame\nfrom typing import Dict\n\nclass UI:\n    \"\"\"\n    UI class for rendering the CPU state and game state.\n    \"\"\"\n\n    def __init__(self, width: int = 800, height: int = 600):\n        \"\"\"\n        Initializes the UI with a default window size.\n\n        Args:\n        - width (int): The width of the window, default is 800 pixels.\n        - height (int): The height of the window, default is 600 pixels.\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.screen = None\n        self.font = None\n        self.initialize_pygame()\n\n    def initialize_pygame(self):\n        \"\"\"\n        Initializes pygame and sets up the window and font.\n        \"\"\"\n        pygame.init()\n        self.screen = pygame.display.set_mode((self.width, self.height))\n        pygame.display.set_caption(\"CPU Simulator and Maze Game\")\n        self.font = pygame.font.SysFont(\"Arial\", 24)\n\n    def render_cpu_state(self, cpu_state: Dict[str, int]):\n        \"\"\"\n        Renders the CPU state on the window.\n\n        Args:\n        - cpu_state (Dict[str, int]): The current state of the CPU, including registers and flags.\n        \"\"\"\n        cpu_text_y = 10\n        for key, value in cpu_state.items():\n            text_surface = self.font.render(f\"{key}: {value}\", True, (255, 255, 255))\n            self.screen.blit(text_surface, (10, cpu_text_y))\n            cpu_text_y += 30\n\n    def render_game_state(self, game_state: Dict[str, int], start_y: int):\n        \"\"\"\n        Renders the game state on the window.\n\n        Args:\n        - game_state (Dict[str, int]): The current state of the game, including player position and maze layout.\n        - start_y (int): The starting y position for rendering the game state.\n        \"\"\"\n        game_text_y = start_y\n        for key, value in game_state.items():\n            text_surface = self.font.render(f\"{key}: {value}\", True, (255, 255, 255))\n            self.screen.blit(text_surface, (10, game_text_y))\n            game_text_y += 30\n\n    def render(self, cpu_state: Dict[str, int], game_state: Dict[str, int]):\n        \"\"\"\n        Renders the CPU state and game state on the window.\n\n        Args:\n        - cpu_state (Dict[str, int]): The current state of the CPU, including registers and flags.\n        - game_state (Dict[str, int]): The current state of the game, including player position and maze layout.\n        \"\"\"\n        self.screen.fill((0, 0, 0))  # Clear screen with black\n        self.render_cpu_state(cpu_state)\n        self.render_game_state(game_state, cpu_text_y + 10)\n        pygame.display.flip()\n\n    def handle_events(self):\n        \"\"\"\n        Handles pygame events, including window close events and keyboard inputs.\n        \"\"\"\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                self.close()\n                return False\n            # Example for handling arrow keys\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT:\n                    # Handle left arrow key press\n                    pass\n                elif event.key == pygame.K_RIGHT:\n                    # Handle right arrow key press\n                    pass\n                # Add more conditions for other keys as needed\n        return True\n\n    def close(self):\n        \"\"\"\n        Closes the pygame window and quits.\n        \"\"\"\n        pygame.quit()\n\n# Example usage\nif __name__ == \"__main__\":\n    ui = UI()\n    cpu_state_example = {\"PC\": 1, \"ACC\": 10, \"R1\": 5}\n    game_state_example = {\"PlayerX\": 100, \"PlayerY\": 150, \"Score\": 200}\n    try:\n        while True:\n            if not ui.handle_events():\n                break\n            ui.render(cpu_state_example, game_state_example)\n    finally:\n        ui.close()\n\n## game.py\nimport pygame\nfrom typing import Dict, Tuple\nfrom ui import UI\n\nclass Maze:\n    \"\"\"\n    Maze class to manage the maze structure and player movement.\n    \"\"\"\n    def __init__(self, size: Tuple[int, int] = (10, 10), start_pos: Tuple[int, int] = (0, 0)):\n        self.size = size\n        self.start_pos = start_pos\n        self.player_pos = start_pos\n        self.maze_structure = self._generate_maze()\n\n    def _generate_maze(self) -> Dict[Tuple[int, int], bool]:\n        \"\"\"\n        Generates a simple maze structure. This is a placeholder for a more complex maze generation algorithm.\n\n        Returns:\n        Dict[Tuple[int, int], bool]: A dictionary representing the maze where keys are positions and values indicate if the position is a wall (True) or not (False).\n        \"\"\"\n        # For simplicity, this example will just create an empty maze with no walls\n        # Future implementation should replace this with a proper maze generation algorithm\n        maze = {(x, y): False for x in range(self.size[0]) for y in range(self.size[1])}\n        return maze\n\n    def move_player(self, direction: str):\n        \"\"\"\n        Moves the player in the specified direction if possible, checking for walls.\n\n        Args:\n        - direction (str): The direction to move the player ('UP', 'DOWN', 'LEFT', 'RIGHT').\n        \"\"\"\n        x, y = self.player_pos\n        new_pos = {\n            'UP': (x, max(y - 1, 0)),\n            'DOWN': (x, min(y + 1, self.size[1] - 1)),\n            'LEFT': (max(x - 1, 0), y),\n            'RIGHT': (min(x + 1, self.size[0] - 1), y)\n        }.get(direction, self.player_pos)\n\n        # Check for wall collision\n        if not self.maze_structure.get(new_pos, True):  # Default to True to prevent moving into non-existent cells\n            self.player_pos = new_pos\n\n    def get_player_position(self) -> Tuple[int, int]:\n        \"\"\"\n        Returns the current position of the player.\n\n        Returns:\n        Tuple[int, int]: The current position of the player.\n        \"\"\"\n        return self.player_pos\n\nclass Game:\n    \"\"\"\n    Game class to manage the game state and interactions, including integration with a CPU simulator.\n    \"\"\"\n    def __init__(self, ui: UI, cpu_state: Dict[str, int] = None):\n        self.ui = ui\n        self.maze = Maze()\n        self.running = False\n        self.cpu_state = cpu_state if cpu_state is not None else {}\n\n    def start(self):\n        \"\"\"\n        Starts the game loop.\n        \"\"\"\n        self.running = True\n        while self.running:\n            self.handle_events()\n            self.update()\n            self.render()\n\n    def handle_events(self):\n        \"\"\"\n        Handles game events, including player movement and quitting the game.\n        \"\"\"\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                self.running = False\n            elif event.type == pygame.KEYDOWN:\n                self.process_keydown(event.key)\n\n    def process_keydown(self, key):\n        \"\"\"\n        Processes keydown events to move the player.\n\n        Args:\n        - key: The key that was pressed.\n        \"\"\"\n        direction_map = {\n            pygame.K_UP: 'UP',\n            pygame.K_DOWN: 'DOWN',\n            pygame.K_LEFT: 'LEFT',\n            pygame.K_RIGHT: 'RIGHT'\n        }\n        if key in direction_map:\n            self.maze.move_player(direction_map[key])\n\n    def update(self):\n        \"\"\"\n        Updates the game state. Placeholder for future game logic.\n        \"\"\"\n        pass\n\n    def render(self):\n        \"\"\"\n        Renders the game state along with the CPU state if available.\n        \"\"\"\n        game_state = {\n            \"Player Position\": self.maze.get_player_position()\n        }\n        self.ui.render(self.cpu_state, game_state)\n\n# Example usage\nif __name__ == \"__main__\":\n    ui = UI()\n    cpu_state_example = {\"PC\": 1, \"ACC\": 10, \"R1\": 5}  # Example CPU state\n    game = Game(ui, cpu_state_example)\n    game.start()\n\n## utils.py\n\ndef binary_to_decimal(binary: str) -> int:\n    \"\"\"\n    Converts a binary string to a decimal integer.\n\n    Args:\n    - binary (str): The binary string to convert.\n\n    Returns:\n    int: The decimal representation of the binary string.\n    \"\"\"\n    try:\n        return int(binary, 2)\n    except ValueError:\n        raise ValueError(\"Invalid binary string\")\n\ndef decimal_to_binary(decimal: int) -> str:\n    \"\"\"\n    Converts a decimal integer to a binary string.\n\n    Args:\n    - decimal (int): The decimal integer to convert.\n\n    Returns:\n    str: The binary string representation of the decimal integer.\n    \"\"\"\n    if decimal < 0:\n        raise ValueError(\"Decimal must be a non-negative integer\")\n    return bin(decimal)[2:]\n\n## assembler.py\nfrom typing import List\nfrom utils import binary_to_decimal, decimal_to_binary\n\nclass Assembler:\n    \"\"\"\n    Assembler class to convert assembly code into machine code.\n    Utilizes utility functions from utils.py for binary and decimal conversions.\n    \"\"\"\n\n    def __init__(self):\n        self.opcode_mapping = {\n            \"LOAD\": self._handle_load,\n            \"ADD\": self._handle_add,\n            \"SUB\": self._handle_sub\n        }\n\n    def assemble(self, code: str) -> List[str]:\n        \"\"\"\n        Converts assembly code into a list of machine code instructions.\n\n        Args:\n        - code (str): The assembly code to convert.\n\n        Returns:\n        List[str]: The machine code instructions as a list of binary strings.\n        \"\"\"\n        machine_code = []\n        lines = code.split('\\n')\n        for line in lines:\n            if not line.strip() or line.startswith('#'):  # Ignore empty lines and comments\n                continue\n            instruction = self._parse_instruction(line.strip())\n            machine_code.append(instruction)\n        return machine_code\n\n    def _parse_instruction(self, instruction: str) -> str:\n        \"\"\"\n        Parses a single assembly instruction to its machine code representation.\n\n        Args:\n        - instruction (str): The assembly instruction to parse.\n\n        Returns:\n        str: The binary string representation of the machine code instruction.\n        \"\"\"\n        parts = instruction.split()\n        opcode = parts[0].upper()\n        if opcode in self.opcode_mapping:\n            return self.opcode_mapping[opcode](parts)\n        else:\n            raise ValueError(f\"Unsupported instruction: {opcode}\")\n\n    def _handle_load(self, parts: List[str]) -> str:\n        self._validate_instruction_parts(parts, 3)\n        register = self._validate_register(parts[1])\n        value = parts[2]\n        return f'0001{decimal_to_binary(int(register)):04b}{decimal_to_binary(int(value)):08b}'\n\n    def _handle_add(self, parts: List[str]) -> str:\n        self._validate_instruction_parts(parts, 3)\n        reg_dest = self._validate_register(parts[1])\n        reg_src = self._validate_register(parts[2])\n        return f'0010{decimal_to_binary(int(reg_dest)):04b}{decimal_to_binary(int(reg_src)):04b}0000'\n\n    def _handle_sub(self, parts: List[str]) -> str:\n        self._validate_instruction_parts(parts, 3)\n        reg_dest = self._validate_register(parts[1])\n        reg_src = self._validate_register(parts[2])\n        return f'0011{decimal_to_binary(int(reg_dest)):04b}{decimal_to_binary(int(reg_src)):04b}0000'\n\n    def _validate_instruction_parts(self, parts: List[str], expected_parts: int):\n        if len(parts) != expected_parts:\n            raise ValueError(f\"Expected {expected_parts} parts, got {len(parts)}\")\n\n    def _validate_register(self, register: str) -> str:\n        if not register.startswith('R') or not register[1:].isdigit():\n            raise ValueError(f\"Invalid register format: {register}\")\n        return register[1:]\n\n# Example usage\nif __name__ == \"__main__\":\n    assembler = Assembler()\n    assembly_code = \"\"\"\n    LOAD R1, 10\n    ADD R2, R1\n    SUB R3, R2\n    \"\"\"\n    machine_code = assembler.assemble(assembly_code)\n    print(machine_code)\n\n## cpu.py\nimport numpy as np\nfrom typing import List\nfrom utils import binary_to_decimal\n\nclass CPU:\n    \"\"\"\n    CPU class to execute instructions and manage the state of registers and memory.\n    \"\"\"\n\n    def __init__(self):\n        # Initialize registers and memory using numpy arrays for efficient manipulation.\n        # Default size for demonstration: 8 registers, 256 bytes of memory.\n        self.registers = np.zeros(8, dtype=np.uint8)\n        self.memory = np.zeros(256, dtype=np.uint8)\n\n    def load_program(self, program: List[str]) -> None:\n        \"\"\"\n        Loads a program into memory.\n\n        Args:\n        - program (List[str]): The program to load, represented as a list of binary strings.\n        \"\"\"\n        for address, instruction in enumerate(program):\n            if address < len(self.memory):\n                self.memory[address] = binary_to_decimal(instruction)\n            else:\n                raise MemoryError(\"Program size exceeds available memory\")\n\n    def execute_instruction(self, instruction: str) -> None:\n        \"\"\"\n        Executes a single instruction.\n\n        Args:\n        - instruction (str): The binary string representation of the instruction to execute.\n        \"\"\"\n        opcode = instruction[:4]\n        if opcode == '0001':  # LOAD\n            self._execute_load(instruction)\n        elif opcode == '0010':  # ADD\n            self._execute_add(instruction)\n        elif opcode == '0011':  # SUB\n            self._execute_sub(instruction)\n        else:\n            raise ValueError(f\"Unsupported opcode: {opcode}\")\n\n    def _execute_load(self, instruction: str) -> None:\n        \"\"\"\n        Executes a LOAD instruction.\n\n        Args:\n        - instruction (str): The binary string representation of the LOAD instruction.\n        \"\"\"\n        reg = binary_to_decimal(instruction[4:8])\n        value = binary_to_decimal(instruction[8:])\n        self.registers[reg] = value\n\n    def _execute_add(self, instruction: str) -> None:\n        \"\"\"\n        Executes an ADD instruction.\n\n        Args:\n        - instruction (str): The binary string representation of the ADD instruction.\n        \"\"\"\n        reg_dest = binary_to_decimal(instruction[4:8])\n        reg_src = binary_to_decimal(instruction[8:12])\n        sum_result = self.registers[reg_dest] + self.registers[reg_src]\n        if sum_result > 255:\n            print(f\"Warning: Overflow detected in ADD operation for register R{reg_dest}\")\n        self.registers[reg_dest] = sum_result % 256\n\n    def _execute_sub(self, instruction: str) -> None:\n        \"\"\"\n        Executes a SUB instruction.\n\n        Args:\n        - instruction (str): The binary string representation of the SUB instruction.\n        \"\"\"\n        reg_dest = binary_to_decimal(instruction[4:8])\n        reg_src = binary_to_decimal(instruction[8:12])\n        difference = self.registers[reg_dest] - self.registers[reg_src]\n        if difference < 0:\n            print(f\"Warning: Underflow detected in SUB operation for register R{reg_dest}\")\n        self.registers[reg_dest] = difference % 256\n\n# Example usage\nif __name__ == \"__main__\":\n    cpu = CPU()\n    program = [\n        '0001000000001010',  # LOAD R0, 10\n        '0001000100001011',  # LOAD R1, 11\n        '0010000100000000',  # ADD R1, R0\n        '0011001000010001',  # SUB R2, R1\n    ]\n    cpu.load_program(program)\n    for instruction in program:\n        cpu.execute_instruction(instruction)\n    print(\"Registers after execution:\", cpu.registers)\n\n",
        "design": {
            "0": {
                "relative_path": "src/run.py",
                "fqn_list": "src/run.py/write_to_input",
                "class": null,
                "signature": "def write_to_input():"
            },
            "1": {
                "relative_path": "src/run.py",
                "fqn_list": "src/run.py/read_from_output",
                "class": null,
                "signature": "def read_from_output(value):"
            },
            "2": {
                "relative_path": "src/assembler.py",
                "fqn_list": "src/assembler.py/get_labels",
                "class": null,
                "signature": "def get_labels(file) -> dict:"
            },
            "3": {
                "relative_path": "src/assembler.py",
                "fqn_list": "src/assembler.py/immediate_values",
                "class": null,
                "signature": "def immediate_values(line, labels):"
            },
            "4": {
                "relative_path": "src/assembler.py",
                "fqn_list": "src/assembler.py/copy_instructions",
                "class": null,
                "signature": "def copy_instructions(line):"
            },
            "5": {
                "relative_path": "src/assembler.py",
                "fqn_list": "src/assembler.py/operate_instructions",
                "class": null,
                "signature": "def operate_instructions(line):"
            },
            "6": {
                "relative_path": "src/assembler.py",
                "fqn_list": "src/assembler.py/jump_instructions",
                "class": null,
                "signature": "def jump_instructions(line):"
            },
            "7": {
                "relative_path": "src/assembler.py",
                "fqn_list": "src/assembler.py/assemble_binary",
                "class": null,
                "signature": "def assemble_binary(filename: str):"
            },
            "8": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/__init__",
                "class": "src/games/maze.py.Robot",
                "signature": "def __init__(self, initial_pos = [1,1], initial_dir = 'up', delay = 0):"
            },
            "9": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/event_check",
                "class": "src/games/maze.py.Robot",
                "signature": "def event_check(self):"
            },
            "10": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/move_forward",
                "class": "src/games/maze.py.Robot",
                "signature": "def move_forward(self):"
            },
            "11": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/turn_left",
                "class": "src/games/maze.py.Robot",
                "signature": "def turn_left(self):"
            },
            "12": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/turn_right",
                "class": "src/games/maze.py.Robot",
                "signature": "def turn_right(self):"
            },
            "13": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/move",
                "class": "src/games/maze.py.Robot",
                "signature": "def move(self, instruction):"
            },
            "14": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/get_front_cell",
                "class": "src/games/maze.py.Robot",
                "signature": "def get_front_cell(self):"
            },
            "15": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/Robot/get_front_cell_bit",
                "class": "src/games/maze.py.Robot",
                "signature": "def get_front_cell_bit(self):"
            },
            "16": {
                "relative_path": "src/games/maze.py",
                "fqn_list": "src/games/maze.py/draw",
                "class": null,
                "signature": "def draw(robot):"
            },
            "17": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/HalfAdder/__init__",
                "class": "src/hardware/basic_components.py.HalfAdder",
                "signature": "def __init__(self, input1: bool, input2: bool):"
            },
            "18": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/HalfAdder/sum",
                "class": "src/hardware/basic_components.py.HalfAdder",
                "signature": "def sum(self) -> bool:"
            },
            "19": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/HalfAdder/carry",
                "class": "src/hardware/basic_components.py.HalfAdder",
                "signature": "def carry(self) -> bool:"
            },
            "20": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/FullAdder/__init__",
                "class": "src/hardware/basic_components.py.FullAdder",
                "signature": "def __init__(self, input1: bool, input2: bool, carry_in: bool):"
            },
            "21": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/FullAdder/sum",
                "class": "src/hardware/basic_components.py.FullAdder",
                "signature": "def sum(self):"
            },
            "22": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/FullAdder/carry",
                "class": "src/hardware/basic_components.py.FullAdder",
                "signature": "def carry(self):"
            },
            "23": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Adder/__init__",
                "class": "src/hardware/basic_components.py.Adder",
                "signature": "def __init__(self, input1: list[bool], input2: list[bool], carry_in: bool = False):"
            },
            "24": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Adder/sum",
                "class": "src/hardware/basic_components.py.Adder",
                "signature": "def sum(self) -> list[bool]:"
            },
            "25": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Adder/carry_out",
                "class": "src/hardware/basic_components.py.Adder",
                "signature": "def carry_out(self) -> bool:"
            },
            "26": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/HalfSubtractor/__init__",
                "class": "src/hardware/basic_components.py.HalfSubtractor",
                "signature": "def __init__(self, input1: bool, input2: bool):"
            },
            "27": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/HalfSubtractor/diff",
                "class": "src/hardware/basic_components.py.HalfSubtractor",
                "signature": "def diff(self) -> bool:"
            },
            "28": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/HalfSubtractor/borrow",
                "class": "src/hardware/basic_components.py.HalfSubtractor",
                "signature": "def borrow(self) -> bool:"
            },
            "29": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/FullSubtractor/__init__",
                "class": "src/hardware/basic_components.py.FullSubtractor",
                "signature": "def __init__(self, input1: bool, input2: bool, borrow_in: bool):"
            },
            "30": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/FullSubtractor/diff",
                "class": "src/hardware/basic_components.py.FullSubtractor",
                "signature": "def diff(self):"
            },
            "31": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/FullSubtractor/borrow",
                "class": "src/hardware/basic_components.py.FullSubtractor",
                "signature": "def borrow(self):"
            },
            "32": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Subtractor/__init__",
                "class": "src/hardware/basic_components.py.Subtractor",
                "signature": "def __init__(self, input1: list[bool], input2: list[bool], borrow_in: bool = False):"
            },
            "33": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Subtractor/diff",
                "class": "src/hardware/basic_components.py.Subtractor",
                "signature": "def diff(self) -> list[bool]:"
            },
            "34": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Subtractor/borrow_out",
                "class": "src/hardware/basic_components.py.Subtractor",
                "signature": "def borrow_out(self) -> bool:"
            },
            "35": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Mux/__init__",
                "class": "src/hardware/basic_components.py.Mux",
                "signature": "def __init__(self, input1: bool, input2: bool, sel: bool):"
            },
            "36": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Mux/output",
                "class": "src/hardware/basic_components.py.Mux",
                "signature": "def output(self) -> bool:"
            },
            "37": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Mux8Bit/__init__",
                "class": "src/hardware/basic_components.py.Mux8Bit",
                "signature": "def __init__(self, input1: list[bool], input2: list[bool], sel: bool):"
            },
            "38": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Mux8Bit/output",
                "class": "src/hardware/basic_components.py.Mux8Bit",
                "signature": "def output(self) -> list[bool]:"
            },
            "39": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/AddSub/__init__",
                "class": "src/hardware/basic_components.py.AddSub",
                "signature": "def __init__(self, input1: list[bool], input2: list[bool], operation: bool):"
            },
            "40": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/AddSub/output",
                "class": "src/hardware/basic_components.py.AddSub",
                "signature": "def output(self) -> list[bool]:"
            },
            "41": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/AddSub/overflow",
                "class": "src/hardware/basic_components.py.AddSub",
                "signature": "def overflow(self) -> bool:"
            },
            "42": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/AddSub/borrow_out",
                "class": "src/hardware/basic_components.py.AddSub",
                "signature": "def borrow_out(self) -> bool:"
            },
            "43": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Decoder/__init__",
                "class": "src/hardware/basic_components.py.Decoder",
                "signature": "def __init__(self, input: list[bool]):"
            },
            "44": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Decoder/output",
                "class": "src/hardware/basic_components.py.Decoder",
                "signature": "def output(self) -> list[bool]:"
            },
            "45": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Control/__init__",
                "class": "src/hardware/basic_components.py.Control",
                "signature": "def __init__(self, input: list[bool]):"
            },
            "46": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Control/output",
                "class": "src/hardware/basic_components.py.Control",
                "signature": "def output(self) -> list[bool]:"
            },
            "47": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Comparison/__init__",
                "class": "src/hardware/basic_components.py.Comparison",
                "signature": "def __init__(self, control: list[bool], byte: list[bool]):"
            },
            "48": {
                "relative_path": "src/hardware/basic_components.py",
                "fqn_list": "src/hardware/basic_components.py/Comparison/out",
                "class": "src/hardware/basic_components.py.Comparison",
                "signature": "def out(self) -> bool:"
            },
            "49": {
                "relative_path": "src/hardware/registers.py",
                "fqn_list": "src/hardware/registers.py/Registers/__init__",
                "class": "src/hardware/registers.py.Registers",
                "signature": "def __init__(self):"
            },
            "50": {
                "relative_path": "src/hardware/registers.py",
                "fqn_list": "src/hardware/registers.py/Registers/read",
                "class": "src/hardware/registers.py.Registers",
                "signature": "def read(self):"
            },
            "51": {
                "relative_path": "src/hardware/registers.py",
                "fqn_list": "src/hardware/registers.py/Registers/write",
                "class": "src/hardware/registers.py.Registers",
                "signature": "def write(self, data):"
            },
            "52": {
                "relative_path": "src/hardware/registers.py",
                "fqn_list": "src/hardware/registers.py/Registers/write_to_register",
                "class": "src/hardware/registers.py.Registers",
                "signature": "def write_to_register(self, register, data):"
            },
            "53": {
                "relative_path": "src/hardware/alu.py",
                "fqn_list": "src/hardware/alu.py/ALU/__init__",
                "class": "src/hardware/alu.py.ALU",
                "signature": "def __init__(self, input1: list[bool], input2: list[bool], control1: bool, control2: bool):"
            },
            "54": {
                "relative_path": "src/hardware/alu.py",
                "fqn_list": "src/hardware/alu.py/ALU/out",
                "class": "src/hardware/alu.py.ALU",
                "signature": "def out(self):"
            },
            "55": {
                "relative_path": "src/hardware/alu.py",
                "fqn_list": "src/hardware/alu.py/ALU/zero",
                "class": "src/hardware/alu.py.ALU",
                "signature": "def zero(self):"
            },
            "56": {
                "relative_path": "src/hardware/alu.py",
                "fqn_list": "src/hardware/alu.py/ALU/negative",
                "class": "src/hardware/alu.py.ALU",
                "signature": "def negative(self):"
            },
            "57": {
                "relative_path": "src/hardware/alu.py",
                "fqn_list": "src/hardware/alu.py/ALU/overflow",
                "class": "src/hardware/alu.py.ALU",
                "signature": "def overflow(self):"
            },
            "58": {
                "relative_path": "src/hardware/alu.py",
                "fqn_list": "src/hardware/alu.py/ALU/carry_out",
                "class": "src/hardware/alu.py.ALU",
                "signature": "def carry_out(self):"
            },
            "59": {
                "relative_path": "src/hardware/gates.py",
                "fqn_list": "src/hardware/gates.py/and_",
                "class": null,
                "signature": "def and_(*args) -> int:"
            },
            "60": {
                "relative_path": "src/hardware/gates.py",
                "fqn_list": "src/hardware/gates.py/or_",
                "class": null,
                "signature": "def or_(*args) -> int:"
            },
            "61": {
                "relative_path": "src/hardware/gates.py",
                "fqn_list": "src/hardware/gates.py/not_",
                "class": null,
                "signature": "def not_(*args) -> int:"
            },
            "62": {
                "relative_path": "src/hardware/gates.py",
                "fqn_list": "src/hardware/gates.py/nor",
                "class": null,
                "signature": "def nor(*args) -> int:"
            },
            "63": {
                "relative_path": "src/hardware/gates.py",
                "fqn_list": "src/hardware/gates.py/nand",
                "class": null,
                "signature": "def nand(*args) -> int:"
            },
            "64": {
                "relative_path": "src/hardware/gates.py",
                "fqn_list": "src/hardware/gates.py/xor",
                "class": null,
                "signature": "def xor(a: bool, b: bool) -> int:"
            },
            "65": {
                "relative_path": "src/hardware/gates.py",
                "fqn_list": "src/hardware/gates.py/xnor",
                "class": null,
                "signature": "def xnor(a: bool, b: bool) -> int:"
            },
            "66": {
                "relative_path": "src/hardware/cpu.py",
                "fqn_list": "src/hardware/cpu.py/CPU/__init__",
                "class": "src/hardware/cpu.py.CPU",
                "signature": "def __init__(self, program, verbose = True):"
            },
            "67": {
                "relative_path": "src/hardware/cpu.py",
                "fqn_list": "src/hardware/cpu.py/CPU/run",
                "class": "src/hardware/cpu.py.CPU",
                "signature": "def run(self, write_to_input: callable = None, read_from_output: callable = None):"
            },
            "68": {
                "relative_path": "src/hardware/cpu.py",
                "fqn_list": "src/hardware/cpu.py/Cycle/__init__",
                "class": "src/hardware/cpu.py.Cycle",
                "signature": "def __init__(self, cpu, program_instruction_byte):"
            },
            "69": {
                "relative_path": "src/hardware/cpu.py",
                "fqn_list": "src/hardware/cpu.py/Cycle/execute",
                "class": "src/hardware/cpu.py.Cycle",
                "signature": "def execute(self):"
            }
        }
    },
    "django-pony-express": {
        "generated code": "## main.py\nimport os\nimport sys\nfrom django.core.wsgi import get_wsgi_application\nfrom django.urls import path\nfrom django.conf import settings\nfrom views import SendEmailView\n\n# Helper function to convert environment variables to boolean\ndef str_to_bool(value):\n    return value.lower() in ('true', '1', 't')\n\n# Define settings for Django project\nsettings.configure(\n    DEBUG=str_to_bool(os.environ.get('DEBUG', 'True')),\n    SECRET_KEY=os.environ.get('SECRET_KEY', 'your_secret_key'),\n    ROOT_URLCONF=__name__,\n    EMAIL_BACKEND='django.core.mail.backends.smtp.EmailBackend',\n    EMAIL_HOST=os.environ.get('EMAIL_HOST', 'smtp.example.com'),\n    EMAIL_PORT=int(os.environ.get('EMAIL_PORT', 587)),\n    EMAIL_USE_TLS=str_to_bool(os.environ.get('EMAIL_USE_TLS', 'True')),\n    EMAIL_HOST_USER=os.environ.get('EMAIL_HOST_USER', 'your_email@example.com'),\n    EMAIL_HOST_PASSWORD=os.environ.get('EMAIL_HOST_PASSWORD', 'your_email_password'),\n    DEFAULT_FROM_EMAIL=os.environ.get('DEFAULT_FROM_EMAIL', 'webmaster@localhost'),\n)\n\n# Define URL patterns\nurlpatterns = [\n    path('send-email/', SendEmailView.as_view(), name='send_email'),\n]\n\napplication = get_wsgi_application()\n\nif __name__ == \"__main__\":\n    from django.core.management import execute_from_command_line\n\n    execute_from_command_line(sys.argv)\n\n## models.py\nfrom django.db import models, DatabaseError\nfrom django.utils import timezone\nimport logging\n\n# Configure logger for this module\nlogger = logging.getLogger(__name__)\n\nclass EmailModel(models.Model):\n    \"\"\"\n    Represents an email entity with recipient, subject, content, and the time it was sent.\n    This model is used to store email information in the database.\n    \"\"\"\n    recipient = models.EmailField()\n    subject = models.CharField(max_length=255)\n    content = models.TextField()\n    sent_at = models.DateTimeField(default=timezone.now)\n\n    def save_email(self) -> bool:\n        \"\"\"\n        Attempts to save the email instance to the database.\n        Logs an error and returns False if the save operation fails.\n        \n        Returns:\n            bool: True if the email was saved successfully, False otherwise.\n        \"\"\"\n        try:\n            self.save()\n            return True\n        except DatabaseError as e:\n            logger.error(f\"Failed to save email due to a database error: {e}\")\n            return False\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the EmailModel instance, including the recipient and subject.\n        \n        Returns:\n            str: A string representation of the email.\n        \"\"\"\n        return f\"Email to {self.recipient}: {self.subject}\"\n\n## views.py\nimport json\nfrom django.views import View\nfrom django.http import JsonResponse, HttpResponseBadRequest\nfrom django.core.exceptions import ValidationError\nfrom .emails import TemplateEmail, PlainTextEmail\nimport logging\n\n# Configure logger for this module\nlogger = logging.getLogger(__name__)\n\nclass SendEmailView(View):\n    \"\"\"\n    A view that handles email sending requests. It supports both templated and plain text emails.\n    \"\"\"\n\n    def post(self, request):\n        \"\"\"\n        Handles POST requests to send emails. Expects JSON input with email details.\n\n        Args:\n            request (HttpRequest): The HTTP request object containing email data.\n\n        Returns:\n            JsonResponse: A response object with the status of the email sending operation.\n        \"\"\"\n        try:\n            email_data = self._parse_request(request)\n            email_handler = self._initialize_email_handler(email_data)\n            success = email_handler.send_email(\n                recipients=email_data['recipients_list'],\n                subject=email_data['subject'],\n                content=email_data['content']\n            )\n\n            if success:\n                return JsonResponse({'status': 'success', 'message': 'Email sent successfully.'}, status=200)\n            else:\n                return JsonResponse({'status': 'error', 'message': 'Failed to send email.'}, status=500)\n\n        except json.JSONDecodeError:\n            return JsonResponse({'status': 'error', 'message': 'Invalid JSON format.'}, status=400)\n        except ValidationError as e:\n            return HttpResponseBadRequest({'status': 'error', 'message': str(e)})\n        except Exception as e:\n            logger.error(f'An unexpected error occurred: {str(e)}')\n            return JsonResponse({'status': 'error', 'message': f'An unexpected error occurred: {str(e)}'}, status=500)\n\n    def _parse_request(self, request):\n        \"\"\"\n        Parses the HTTP request to extract email data.\n\n        Args:\n            request (HttpRequest): The HTTP request object.\n\n        Returns:\n            dict: A dictionary containing parsed email data.\n        \"\"\"\n        email_data = json.loads(request.body.decode('utf-8'))\n        email_type = email_data.get('type', 'plain')  # default to plain text email\n        recipients = email_data.get('recipients')\n        subject = email_data.get('subject')\n        content = email_data.get('content', '')  # content is optional for templated emails\n        template_name = email_data.get('template_name', '')  # only used for templated emails\n\n        # Validate required fields\n        if not recipients or not subject:\n            raise ValidationError(\"Missing required email fields.\")\n\n        # Convert recipients string to list\n        recipients_list = recipients.split(',')\n\n        return {\n            'type': email_type,\n            'recipients_list': recipients_list,\n            'subject': subject,\n            'content': content,\n            'template_name': template_name\n        }\n\n    def _initialize_email_handler(self, email_data):\n        \"\"\"\n        Initializes the appropriate email handler based on the email type.\n\n        Args:\n            email_data (dict): A dictionary containing email data.\n\n        Returns:\n            EmailHandler: An instance of TemplateEmail or PlainTextEmail.\n        \"\"\"\n        if email_data['type'] == 'template':\n            return TemplateEmail(template_name=email_data['template_name'], context=email_data)\n        else:\n            return PlainTextEmail(context={'content': email_data['content']})\n\n## emails.py\nfrom django.core.mail import send_mail\nfrom django.template.loader import render_to_string\nfrom .models import EmailModel\nfrom django.conf import settings\nimport logging\n\n# Configure logger for this module\nlogger = logging.getLogger(__name__)\n\n# Ensure settings.DEFAULT_FROM_EMAIL is properly configured or provide a default\nDEFAULT_FROM_EMAIL = getattr(settings, 'DEFAULT_FROM_EMAIL', 'default@example.com')\n\nclass EmailHandler:\n    \"\"\"\n    Base class for handling email operations. This class provides the basic structure for sending emails.\n    \"\"\"\n    def __init__(self, template_name: str = \"\", context: dict = None):\n        self.template_name = template_name\n        self.context = context if context is not None else {}\n\n    def send_email(self, recipients: list, subject: str, content: str) -> bool:\n        \"\"\"\n        Sends an email to the specified recipients. Should be overridden by subclasses.\n\n        Args:\n            recipients (list): A list of email addresses to send the email to.\n            subject (str): The subject of the email.\n            content (str): The content of the email.\n\n        Returns:\n            bool: True if the email was sent successfully, False otherwise.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def save_email_to_db(self, recipients, subject, content) -> bool:\n        \"\"\"\n        Saves the email information to the database.\n\n        Args:\n            recipients (list): A list of email addresses to send the email to.\n            subject (str): The subject of the email.\n            content (str): The content of the email.\n\n        Returns:\n            bool: True if the email information was saved successfully, False otherwise.\n        \"\"\"\n        try:\n            EmailModel(recipient=\", \".join(recipients), subject=subject, content=content).save_email()\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to save email to database due to: {e}\")\n            return False\n\nclass TemplateEmail(EmailHandler):\n    \"\"\"\n    Handles sending templated emails. Inherits from EmailHandler and overrides the send_email method.\n    \"\"\"\n    def render_template(self) -> str:\n        \"\"\"\n        Renders the email template with the provided context.\n\n        Returns:\n            str: The rendered template as a string.\n        \"\"\"\n        return render_to_string(self.template_name, self.context)\n\n    def send_email(self, recipients: list, subject: str, content: str = \"\") -> bool:\n        \"\"\"\n        Sends a templated email to the specified recipients.\n\n        Args:\n            recipients (list): A list of email addresses to send the email to.\n            subject (str): The subject of the email.\n            content (str): The content of the email. This is optional for templated emails.\n\n        Returns:\n            bool: True if the email was sent successfully, False otherwise.\n        \"\"\"\n        content = self.render_template()\n        try:\n            send_mail(subject, content, DEFAULT_FROM_EMAIL, recipients, html_message=content)\n            logger.info(f\"Templated email sent successfully to {recipients}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to send templated email due to: {e}\")\n            return False\n\nclass PlainTextEmail(EmailHandler):\n    \"\"\"\n    Handles sending plain text emails. Inherits from EmailHandler and overrides the send_email method.\n    \"\"\"\n    def render_plain_text(self) -> str:\n        \"\"\"\n        Returns the plain text content. This is a placeholder for potential future enhancements.\n\n        Returns:\n            str: The plain text content.\n        \"\"\"\n        return self.context.get(\"content\", \"\")\n\n    def send_email(self, recipients: list, subject: str, content: str) -> bool:\n        \"\"\"\n        Sends a plain text email to the specified recipients.\n\n        Args:\n            recipients (list): A list of email addresses to send the email to.\n            subject (str): The subject of the email.\n            content (str): The content of the email.\n\n        Returns:\n            bool: True if the email was sent successfully, False otherwise.\n        \"\"\"\n        try:\n            send_mail(subject, content, DEFAULT_FROM_EMAIL, recipients)\n            logger.info(f\"Plain text email sent successfully to {recipients}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to send plain text email due to: {e}\")\n            return False\n\n",
        "design": {
            "0": {
                "relative_path": "manage.py",
                "fqn_list": "manage.py/main",
                "class": null,
                "signature": "def main():"
            },
            "1": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/__init__",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def __init__(self, recipient_email_list: Union[list, tuple, QuerySet] = None, **kwargs) -> None:"
            },
            "2": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/is_valid",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def is_valid(self, raise_exception: bool = True) -> bool:"
            },
            "3": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/get_recipient_list",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def get_recipient_list(self) -> list:"
            },
            "4": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/get_email_from_recipient",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def get_email_from_recipient(self, recipient) -> str:"
            },
            "5": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/get_context_data",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def get_context_data(self) -> dict:"
            },
            "6": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/has_errors",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def has_errors(self) -> bool:"
            },
            "7": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/errors",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def errors(self) -> list:"
            },
            "8": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailServiceFactory/process",
                "class": "django_pony_express/services/base.py.BaseEmailServiceFactory",
                "signature": "def process(self, raise_exception: bool = True) -> int:"
            },
            "9": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/__init__",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def __init__(self, recipient_email_list: Optional[Union[list, tuple, str]] = None, context_data: Optional[dict] = None, attachment_list: Optional[list] = None, **kwargs) -> None:"
            },
            "10": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/_get_logger",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def _get_logger(self) -> logging.Logger:"
            },
            "11": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_context_data",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_context_data(self) -> dict:"
            },
            "12": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_subject",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_subject(self) -> str:"
            },
            "13": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_from_email",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_from_email(self) -> str:"
            },
            "14": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_cc_emails",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_cc_emails(self) -> list:"
            },
            "15": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_bcc_emails",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_bcc_emails(self) -> list:"
            },
            "16": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_reply_to_emails",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_reply_to_emails(self) -> list:"
            },
            "17": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_translation",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_translation(self) -> Union[str, None]:"
            },
            "18": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/get_attachments",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def get_attachments(self) -> list:"
            },
            "19": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/_add_attachments",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def _add_attachments(self, msg: EmailMultiAlternatives):"
            },
            "20": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/_build_mail_object",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def _build_mail_object(self) -> EmailMultiAlternatives:"
            },
            "21": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/is_valid",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def is_valid(self, raise_exception: bool = True) -> bool:"
            },
            "22": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/has_errors",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def has_errors(self) -> bool:"
            },
            "23": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/errors",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def errors(self) -> list:"
            },
            "24": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/_send_and_log_email",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def _send_and_log_email(self, msg: EmailMultiAlternatives) -> bool:"
            },
            "25": {
                "relative_path": "django_pony_express/services/base.py",
                "fqn_list": "django_pony_express/services/base.py/BaseEmailService/process",
                "class": "django_pony_express/services/base.py.BaseEmailService",
                "signature": "def process(self, raise_exception: bool = True) -> bool:"
            },
            "26": {
                "relative_path": "django_pony_express/services/asynchronous/thread.py",
                "fqn_list": "django_pony_express/services/asynchronous/thread.py/ThreadEmailService/process",
                "class": "django_pony_express/services/asynchronous/thread.py.ThreadEmailService",
                "signature": "def process(self, raise_exception: bool = True) -> None:"
            }
        }
    },
    "reverse_argparse": {
        "generated code": "## main.py\nimport argparse\nfrom reverse_argparse import Namespace, ReverseArgumentParser\n\ndef setup_argument_parser():\n    \"\"\"\n    Sets up and returns an ArgumentParser instance with predefined arguments.\n    \n    :return: Configured argparse.ArgumentParser instance.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Example parser\")\n    parser.add_argument('--name', type=str, help='Your name')\n    parser.add_argument('--verbose', action='store_true', help='Increase output verbosity')\n    parser.add_argument('--debug', action='count', default=0, help='Debug level')\n    parser.add_argument('age', type=int, help='Your age')\n    return parser\n\ndef simulate_parsed_arguments():\n    \"\"\"\n    Simulates and returns parsed arguments as a Namespace object.\n    \n    :return: Namespace object with simulated parsed arguments.\n    \"\"\"\n    return Namespace({'name': 'Alex', 'age': 30, 'verbose': True, 'debug': 2})\n\ndef main():\n    # Setup ArgumentParser\n    parser = setup_argument_parser()\n\n    # Simulate parsed arguments\n    parsed_args = simulate_parsed_arguments()\n\n    # Initialize ReverseArgumentParser with the existing ArgumentParser instance\n    reverse_parser = ReverseArgumentParser(parser)\n\n    # Generate command line string\n    command_line = reverse_parser.reverse_parse(parsed_args)\n    print(command_line)\n\nif __name__ == \"__main__\":\n    main()\n\n## reverse_argparse.py\nimport argparse\nfrom typing import Any, Dict, List\n\nclass Namespace:\n    \"\"\"\n    A simple Namespace class to hold attributes as a dictionary.\n    \"\"\"\n    def __init__(self, attributes: Dict[str, Any]):\n        self.attributes = attributes\n\nclass ReverseArgumentParser:\n    \"\"\"\n    A class to reverse parse command line arguments from a Namespace object back into a command line string.\n    \"\"\"\n    def __init__(self, parser: argparse.ArgumentParser):\n        \"\"\"\n        Initializes the ReverseArgumentParser with an existing argparse.ArgumentParser instance.\n        \n        :param parser: An instance of argparse.ArgumentParser.\n        \"\"\"\n        self.parser = parser\n\n    def reverse_parse(self, args: Namespace) -> str:\n        \"\"\"\n        Takes a Namespace object containing parsed arguments and generates the corresponding command line invocation.\n        \n        :param args: A Namespace object containing parsed arguments.\n        :return: A string representing the command line invocation.\n        \"\"\"\n        command_line = []\n        for action in self._get_all_actions():\n            if hasattr(args, action.dest):\n                value = getattr(args, action.dest)\n                default = action.default if action.default is not None else argparse.SUPPRESS\n                if value == default:\n                    continue  # Skip adding to command line if value is default\n                if isinstance(action, argparse._StoreTrueAction) and value:\n                    command_line.append(action.option_strings[0])\n                elif isinstance(action, argparse._StoreFalseAction) and not value:\n                    command_line.append(action.option_strings[0])\n                elif isinstance(action, argparse._CountAction):\n                    command_line.extend([action.option_strings[0]] * value)\n                elif isinstance(action, argparse._AppendAction) or action.nargs in ('+', '*'):\n                    for val in value:\n                        command_line.extend([action.option_strings[0], str(val)])\n                else:\n                    if action.option_strings:\n                        command_line.append(action.option_strings[0])\n                        if not isinstance(action, argparse._StoreConstAction):\n                            command_line.append(str(value))\n                    else:\n                        command_line.append(str(value))\n        return ' '.join(command_line)\n\n    def _get_all_actions(self) -> List[argparse.Action]:\n        \"\"\"\n        Retrieves all actions registered with the parser, including positional and optional arguments.\n        \n        :return: A list of argparse.Action objects.\n        \"\"\"\n        return self.parser._actions\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create an ArgumentParser instance\n    parser = argparse.ArgumentParser(description=\"Example parser\")\n    parser.add_argument('--name', type=str, help='Your name')\n    parser.add_argument('--verbose', action='store_true', help='Increase output verbosity')\n    parser.add_argument('--debug', action='count', default=0, help='Debug level')\n    parser.add_argument('age', type=int, help='Your age')\n\n    # Simulate parsed arguments\n    parsed_args = Namespace({'name': 'Alex', 'age': 30, 'verbose': True, 'debug': 2})\n\n    # Initialize ReverseArgumentParser with the existing ArgumentParser instance\n    reverse_parser = ReverseArgumentParser(parser)\n\n    # Generate command line string\n    command_line = reverse_parser.reverse_parse(parsed_args)\n    print(command_line)\n\n",
        "design": {
            "0": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/__init__",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def __init__(self, parser: ArgumentParser, namespace: Namespace, indent: int = 4):"
            },
            "1": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_args",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_args(self) -> None:"
            },
            "2": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_action(self, action: Action) -> None:"
            },
            "3": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_arg_is_default_and_help_is_suppressed",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _arg_is_default_and_help_is_suppressed(self, action: Action) -> bool:"
            },
            "4": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/get_effective_command_line_invocation",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def get_effective_command_line_invocation(self) -> str:"
            },
            "5": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/get_pretty_command_line_invocation",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def get_pretty_command_line_invocation(self) -> str:"
            },
            "6": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_get_long_option_strings",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _get_long_option_strings(self, option_strings: Sequence[str]) -> List[str]:"
            },
            "7": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_get_short_option_strings",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _get_short_option_strings(self, option_strings: Sequence[str]) -> List[str]:"
            },
            "8": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_get_option_string",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _get_option_string(self, action: Action, prefer_short: bool = False) -> str:"
            },
            "9": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_append_list_of_list_of_args",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _append_list_of_list_of_args(self, args: List[List[str]]) -> None:"
            },
            "10": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_append_list_of_args",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _append_list_of_args(self, args: List[str]) -> None:"
            },
            "11": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_append_arg",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _append_arg(self, arg: str) -> None:"
            },
            "12": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_indent_str",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _indent_str(self) -> str:"
            },
            "13": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_store_action(self, action: Action) -> None:"
            },
            "14": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_const_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_store_const_action(self, action: Action) -> None:"
            },
            "15": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_true_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_store_true_action(self, action: Action) -> None:"
            },
            "16": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_false_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_store_false_action(self, action: Action) -> None:"
            },
            "17": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_append_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_append_action(self, action: Action) -> None:"
            },
            "18": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_append_const_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_append_const_action(self, action: Action) -> None:"
            },
            "19": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_count_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_count_action(self, action: Action) -> None:"
            },
            "20": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_sub_parsers_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_sub_parsers_action(self, action: Action) -> None:"
            },
            "21": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_extend_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_extend_action(self, action: Action) -> None:"
            },
            "22": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_boolean_optional_action",
                "class": "reverse_argparse/reverse_argparse.py.ReverseArgumentParser",
                "signature": "def _unparse_boolean_optional_action(self, action: Action) -> None:"
            },
            "23": {
                "relative_path": "reverse_argparse/reverse_argparse.py",
                "fqn_list": "reverse_argparse/reverse_argparse.py/quote_arg_if_necessary",
                "class": null,
                "signature": "def quote_arg_if_necessary(arg: str) -> str:"
            }
        }
    },
    "constrainedlr": {
        "generated code": "## main.py\nimport numpy as np\nfrom sklearn.base import BaseEstimator, RegressorMixin\nfrom scipy.optimize import minimize\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import make_regression\n\nclass Utils:\n    @staticmethod\n    def validate_constraints(constraints: dict) -> bool:\n        if not isinstance(constraints, dict):\n            raise ValueError(\"Constraints must be a dictionary.\")\n        \n        for key, value in constraints.items():\n            if not isinstance(key, int):\n                raise ValueError(\"Constraint keys must be integers representing coefficient indices.\")\n            if value not in ['positive', 'negative']:\n                raise ValueError(\"Constraint values must be either 'positive' or 'negative'.\")\n        \n        return True\n\n    @staticmethod\n    def apply_constraints(coef: np.ndarray, constraints: dict) -> np.ndarray:\n        if not Utils.validate_constraints(constraints):\n            raise ValueError(\"Invalid constraints provided.\")\n        \n        for index, constraint in constraints.items():\n            if constraint == 'positive' and coef[index] < 0:\n                coef[index] = np.nextafter(0, 1)\n            elif constraint == 'negative' and coef[index] > 0:\n                coef[index] = np.nextafter(0, -1)\n        \n        return coef\n\nclass ConstrainedLinearRegression(BaseEstimator, RegressorMixin):\n    def __init__(self, constraints: dict = None):\n        self.constraints = constraints if constraints is not None else {}\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -> None:\n        if not Utils.validate_constraints(self.constraints):\n            raise ValueError(\"Invalid constraints provided.\")\n\n        def objective_function(coef, X, y):\n            predictions = X.dot(coef[:-1]) + coef[-1]\n            return np.mean((predictions - y) ** 2)\n\n        initial_coef = np.zeros(X.shape[1] + 1)\n        bounds = [(None, None)] * X.shape[1] + [(None, None)]\n\n        for index, constraint in self.constraints.items():\n            if constraint == 'positive':\n                bounds[index] = (0, None)\n            elif constraint == 'negative':\n                bounds[index] = (None, 0)\n\n        result = minimize(objective_function, initial_coef, args=(X, y), bounds=bounds, method='SLSQP')\n        self.coef_ = result.x[:-1]\n        self.intercept_ = result.x[-1]\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        return X.dot(self.coef_) + self.intercept_\n\n    def get_feature_names_out(self) -> list:\n        return [f\"feature_{i}\" for i in range(len(self.coef_))]\n\ndef main():\n    X, y = make_regression(n_samples=100, n_features=3, noise=0.1, random_state=42)\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n    constraints = {0: 'positive', 1: 'negative'}\n    clr = ConstrainedLinearRegression(constraints=constraints)\n    clr.fit(X_train, y_train)\n    predictions = clr.predict(X_test)\n    print(\"Coefficients:\", clr.coef_)\n    print(\"Intercept:\", clr.intercept_)\n    print(\"First few predictions:\", predictions[:5])\n\nif __name__ == \"__main__\":\n    main()\n\n## constrained_linear_regression.py\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom sklearn.base import BaseEstimator, RegressorMixin\nfrom utils import Utils\n\nclass ConstrainedLinearRegression(BaseEstimator, RegressorMixin):\n    def __init__(self, constraints: dict = None):\n        \"\"\"\n        Initializes the ConstrainedLinearRegression model with optional constraints.\n\n        Parameters:\n        - constraints: dict\n            A dictionary where keys are the indices of the coefficients and values are the constraints\n            ('positive' or 'negative').\n        \"\"\"\n        self.constraints = constraints if constraints is not None else {}\n        self.coef_ = None\n        self.intercept_ = None\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -> None:\n        \"\"\"\n        Fits the ConstrainedLinearRegression model to the data.\n\n        Parameters:\n        - X: numpy.ndarray\n            The input data.\n        - y: numpy.ndarray\n            The target values.\n        \"\"\"\n        if not Utils.validate_constraints(self.constraints):\n            raise ValueError(\"Invalid constraints provided.\")\n\n        def objective_function(coef, X, y):\n            predictions = X.dot(coef[:-1]) + coef[-1]\n            return np.mean((predictions - y) ** 2)\n\n        # Initialize coefficients respecting constraints\n        initial_coef = np.zeros(X.shape[1] + 1)  # Including intercept\n        for index, constraint in self.constraints.items():\n            if constraint == 'positive':\n                initial_coef[index] = np.nextafter(0, 1)  # Smallest positive float\n            elif constraint == 'negative':\n                initial_coef[index] = np.nextafter(0, -1)  # Smallest negative float\n\n        bounds = [(None, None)] * X.shape[1] + [(None, None)]  # No bounds for coefficients and intercept by default\n\n        # Apply bounds based on constraints\n        for index, constraint in self.constraints.items():\n            if constraint == 'positive':\n                bounds[index] = (0, None)\n            elif constraint == 'negative':\n                bounds[index] = (None, 0)\n\n        result = minimize(objective_function, initial_coef, args=(X, y), bounds=bounds, method='SLSQP')\n        self.coef_ = result.x[:-1]\n        self.intercept_ = result.x[-1]\n\n    def predict(self, X: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Predicts target values using the fitted model.\n\n        Parameters:\n        - X: numpy.ndarray\n            The input data.\n\n        Returns:\n        - numpy.ndarray\n            The predicted values.\n        \"\"\"\n        return X.dot(self.coef_) + self.intercept_\n\n    def get_feature_names_out(self) -> list:\n        \"\"\"\n        Returns the feature names for the output.\n\n        Returns:\n        - list\n            A list of feature names.\n        \"\"\"\n        return [f\"feature_{i}\" for i in range(len(self.coef_))]\n\nimport numpy as np\n\nclass Utils:\n    @staticmethod\n    def validate_constraints(constraints: dict) -> bool:\n        \"\"\"\n        Validates the constraints provided for the linear regression model.\n        Ensures that constraints are in the correct format and do not conflict.\n\n        Parameters:\n        - constraints: dict\n            A dictionary where keys are the indices of the coefficients and values are the constraints\n            (either 'positive' or 'negative').\n\n        Returns:\n        - bool\n            True if the constraints are valid, False otherwise.\n        \"\"\"\n        if not isinstance(constraints, dict):\n            raise ValueError(\"Constraints must be a dictionary.\")\n        \n        constraint_counts = {}\n        for key, value in constraints.items():\n            if not isinstance(key, int):\n                raise ValueError(\"Constraint keys must be integers representing coefficient indices.\")\n            if value not in ['positive', 'negative']:\n                raise ValueError(\"Constraint values must be either 'positive' or 'negative'.\")\n            # Detect conflicting constraints\n            if key in constraint_counts:\n                if constraint_counts[key] != value:\n                    raise ValueError(f\"Conflicting constraints for coefficient {key}.\")\n            else:\n                constraint_counts[key] = value\n        \n        return True\n\n    @staticmethod\n    def apply_constraints(coef: np.ndarray, constraints: dict) -> np.ndarray:\n        \"\"\"\n        Applies the constraints to the coefficients of the linear regression model.\n\n        Parameters:\n        - coef: numpy.ndarray\n            The coefficients of the linear regression model.\n        - constraints: dict\n            A dictionary where keys are the indices of the coefficients and values are the constraints\n            (either 'positive' or 'negative').\n\n        Returns:\n        - numpy.ndarray\n            The coefficients after applying the constraints.\n        \"\"\"\n        if not Utils.validate_constraints(constraints):\n            raise ValueError(\"Invalid constraints provided.\")\n        \n        for index, constraint in constraints.items():\n            if constraint == 'positive' and coef[index] < 0:\n                coef[index] = np.nextafter(0, 1)  # Smallest positive float\n            elif constraint == 'negative' and coef[index] > 0:\n                coef[index] = np.nextafter(0, -1)  # Smallest negative float\n        \n        return coef\n\n## examples.py\nimport numpy as np\nfrom constrained_linear_regression import ConstrainedLinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import make_regression\n\ndef main():\n    # Generate a synthetic regression dataset\n    X, y = make_regression(n_samples=100, n_features=3, noise=0.1, random_state=42)\n    \n    # Split the dataset into training and testing sets\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n    \n    # Define constraints for the model: \n    # Let's assume we want the first coefficient to be positive and the second to be negative\n    constraints = {0: 'positive', 1: 'negative'}\n    \n    # Initialize the ConstrainedLinearRegression model with constraints\n    clr = ConstrainedLinearRegression(constraints=constraints)\n    \n    # Fit the model to the training data\n    clr.fit(X_train, y_train)\n    \n    # Predict the target values for the test set\n    predictions = clr.predict(X_test)\n    \n    # Print the coefficients and intercept of the model\n    print(\"Coefficients:\", clr.coef_)\n    print(\"Intercept:\", clr.intercept_)\n    \n    # Print the first few predictions\n    print(\"First few predictions:\", predictions[:5])\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "design": {
            "0": {
                "relative_path": "constrainedlr/model.py",
                "fqn_list": "constrainedlr/model.py/ConstrainedLinearRegression/__init__",
                "class": "constrainedlr/model.py.ConstrainedLinearRegression",
                "signature": "def __init__(self, fit_intercept: bool = True, alpha: float = 0.0):"
            },
            "1": {
                "relative_path": "constrainedlr/model.py",
                "fqn_list": "constrainedlr/model.py/ConstrainedLinearRegression/fit",
                "class": "constrainedlr/model.py.ConstrainedLinearRegression",
                "signature": "def fit(self, X: Union[np.ndarray, pd.DataFrame], y: np.ndarray, sample_weight: Optional[np.ndarray] = None, coefficients_sign_constraints: Optional[dict] = None, coefficients_range_constraints: Optional[dict] = None, intercept_sign_constraint: Union[int, str] = 0, coefficients_sum_constraint: Optional[float] = None) -> \"ConstrainedLinearRegression\":"
            },
            "2": {
                "relative_path": "constrainedlr/model.py",
                "fqn_list": "constrainedlr/model.py/ConstrainedLinearRegression/predict",
                "class": "constrainedlr/model.py.ConstrainedLinearRegression",
                "signature": "def predict(self, X: Union[np.ndarray, pd.DataFrame]) -> np.ndarray:"
            },
            "3": {
                "relative_path": "constrainedlr/model.py",
                "fqn_list": "constrainedlr/model.py/ConstrainedLinearRegression/get_feature_names_out",
                "class": "constrainedlr/model.py.ConstrainedLinearRegression",
                "signature": "def get_feature_names_out(self) -> np.ndarray[str]:"
            },
            "4": {
                "relative_path": "constrainedlr/validation.py",
                "fqn_list": "constrainedlr/validation.py/validate_constraint_features_all_strings_or_all_int",
                "class": null,
                "signature": "def validate_constraint_features_all_strings_or_all_int(constraints: dict) -> None:"
            },
            "5": {
                "relative_path": "constrainedlr/validation.py",
                "fqn_list": "constrainedlr/validation.py/get_clean_feature_names_from_pipeline",
                "class": null,
                "signature": "def get_clean_feature_names_from_pipeline(feature_names: list[str]) -> list[str]:"
            },
            "6": {
                "relative_path": "constrainedlr/validation.py",
                "fqn_list": "constrainedlr/validation.py/validate_feature_names_in_constraints",
                "class": null,
                "signature": "def validate_feature_names_in_constraints(constraints: dict, feature_names: list[str]) -> None:"
            },
            "7": {
                "relative_path": "constrainedlr/validation.py",
                "fqn_list": "constrainedlr/validation.py/convert_feature_names_to_indices",
                "class": null,
                "signature": "def convert_feature_names_to_indices(constraints: dict, feature_names_in_: np.ndarray[str]) -> dict:"
            },
            "8": {
                "relative_path": "constrainedlr/validation.py",
                "fqn_list": "constrainedlr/validation.py/validate_coefficients_sign_constraints",
                "class": null,
                "signature": "def validate_coefficients_sign_constraints(coefficients_sign_constraints: Optional[dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> dict:"
            },
            "9": {
                "relative_path": "constrainedlr/validation.py",
                "fqn_list": "constrainedlr/validation.py/validate_intercept_sign_constraint",
                "class": null,
                "signature": "def validate_intercept_sign_constraint(intercept_sign_constraint: Union[int, str]) -> int:"
            },
            "10": {
                "relative_path": "constrainedlr/validation.py",
                "fqn_list": "constrainedlr/validation.py/validate_coefficients_range_constraints",
                "class": null,
                "signature": "def validate_coefficients_range_constraints(coefficients_range_constraints: Optional[dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> dict:"
            }
        }
    },
    "maccarone": {
        "generated code": "## main.py\nimport sys\nfrom maccarone_cli import MaccaroneCLI\nfrom maccarone_vscode import MaccaroneVSCode\n\nclass Main:\n    @staticmethod\n    def main():\n        \"\"\"\n        The entry point of the application. It determines the mode of operation based on command line arguments\n        and either activates the CLI or the VS Code extension backend.\n        \"\"\"\n        if len(sys.argv) > 1:\n            # If there are command line arguments, assume CLI mode\n            cli = MaccaroneCLI()\n            cli.run_cli(sys.argv[1:])\n        else:\n            # If no command line arguments, assume VS Code extension mode\n            MaccaroneVSCode.activate_extension()\n\nif __name__ == \"__main__\":\n    Main.main()\n\n## config_manager.py\nimport os\nfrom typing import Dict, Tuple\nfrom dotenv import load_dotenv\n\nclass ConfigManager:\n    \"\"\"\n    Manages loading and saving of configuration using python-dotenv.\n    This class handles the application configuration by loading environment variables from a .env file\n    and saving updates back to the same file, ensuring not to overwrite unrelated configurations.\n    \"\"\"\n\n    @staticmethod\n    def load_config() -> Dict[str, str]:\n        \"\"\"\n        Loads the configuration from a .env file into the application's environment variables.\n        Returns a dictionary containing the configuration keys and values.\n        \"\"\"\n        try:\n            load_dotenv()  # Load the environment variables from the .env file\n        except Exception as e:\n            print(f\"Warning: Failed to load .env file: {e}\")\n        \n        config_keys = [\n            \"OPENAI_API_KEY\",  # OpenAI API key for authentication\n        ]\n\n        config = {key: os.getenv(key, \"\") for key in config_keys}  # Load config values into a dictionary\n\n        return config\n\n    @staticmethod\n    def save_config(config: Dict[str, str]) -> None:\n        \"\"\"\n        Updates the .env file with the given configuration without overwriting other existing variables.\n        \"\"\"\n        try:\n            existing_config = {}\n            if os.path.exists('.env'):\n                with open('.env', 'r') as env_file:\n                    for line in env_file:\n                        if '=' in line:\n                            key, value = line.strip().split('=', 1)\n                            existing_config[key] = value\n            existing_config.update(config)\n            with open('.env', 'w') as env_file:\n                for key, value in existing_config.items():\n                    env_file.write(f\"{key}={value}\\n\")\n        except IOError as e:\n            print(f\"Error saving configuration to .env file: {e}\")\n\n    @staticmethod\n    def validate_config(config: Dict[str, str]) -> Tuple[bool, list]:\n        \"\"\"\n        Validates the given configuration dictionary to ensure all required keys are present and not empty.\n        Returns a tuple containing a boolean indicating if the configuration is valid, and a list of missing or empty keys.\n        \"\"\"\n        required_keys = [\"OPENAI_API_KEY\"]\n        missing_or_empty_keys = [key for key in required_keys if not config.get(key)]\n\n        if missing_or_empty_keys:\n            print(f\"Configuration validation failed: {', '.join(missing_or_empty_keys)} are missing or empty.\")\n            return False, missing_or_empty_keys\n        return True, []\n\n## openai_integration.py\nimport openai\nfrom typing import Optional\nfrom config_manager import ConfigManager\n\nclass OpenAIIntegrationError(Exception):\n    \"\"\"Custom exception class for OpenAI Integration errors.\"\"\"\n    pass\n\nclass OpenAIIntegration:\n    \"\"\"\n    Manages communication with OpenAI API using API key stored in config_manager.py.\n    This class is responsible for generating and updating code blocks through the OpenAI API.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the OpenAIIntegration with the API key loaded from the configuration.\n        \"\"\"\n        config = ConfigManager.load_config()\n        self.api_key: str = config.get(\"OPENAI_API_KEY\", \"\")\n        if not self.api_key:\n            raise OpenAIIntegrationError(\"OpenAI API key is missing in the configuration.\")\n        openai.api_key = self.api_key\n\n    def generate_code(self, prompt: str, max_tokens: int = 100) -> str:\n        \"\"\"\n        Generates code based on the given prompt using the OpenAI API.\n\n        :param prompt: The prompt to generate code for.\n        :param max_tokens: The maximum number of tokens to generate. Default is 100.\n        :return: The generated code block as a string.\n        :raises OpenAIIntegrationError: If an error occurs during code generation.\n        \"\"\"\n        try:\n            response = openai.Completion.create(\n                engine=\"davinci-codex\",\n                prompt=prompt,\n                max_tokens=max_tokens,\n                temperature=0.5,\n                top_p=1.0,\n                frequency_penalty=0.0,\n                presence_penalty=0.0,\n                stop=[\"#\"]\n            )\n            return response.choices[0].text.strip()\n        except Exception as e:\n            raise OpenAIIntegrationError(f\"Error generating code: {e}\")\n\n    def update_code(self, prompt: str, code_block: str, max_tokens: int = 100) -> str:\n        \"\"\"\n        Updates a given code block based on the prompt using the OpenAI API.\n\n        :param prompt: The prompt describing how to update the code.\n        :param code_block: The initial code block to update.\n        :param max_tokens: The maximum number of tokens to generate for the update. Default is 100.\n        :return: The updated code block as a string.\n        :raises OpenAIIntegrationError: If an error occurs during code update.\n        \"\"\"\n        full_prompt = f\"{prompt}\\n\\n###\\n\\n{code_block}\\n###\"\n        try:\n            response = openai.Edit.create(\n                engine=\"davinci-codex\",\n                input=full_prompt,\n                instruction=prompt,\n                temperature=0.5,\n                top_p=1.0,\n                n=1,\n                max_tokens=max_tokens\n            )\n            return response.choices[0].text.strip()\n        except Exception as e:\n            raise OpenAIIntegrationError(f\"Error updating code: {e}\")\n\n## maccarone_vscode.py\nimport json\nimport os\nfrom flask import Flask, request, jsonify\nfrom ai_manager import AIManager\n\napp = Flask(__name__)\n\nclass MaccaroneVSCode:\n    \"\"\"\n    VS Code extension backend, uses AIManager to create new AI-managed code blocks.\n    This class provides an HTTP interface for the VS Code extension to interact with the AIManager.\n    \"\"\"\n    ai_manager = AIManager()\n\n    @staticmethod\n    @app.route('/create_code_block', methods=['POST'])\n    def create_code_block():\n        \"\"\"\n        HTTP endpoint for creating a new AI-managed code block.\n        Expects a JSON payload with a 'prompt' key.\n        \"\"\"\n        data = request.get_json(force=True, silent=True)\n        if data is None:\n            return jsonify({'error': 'Invalid JSON payload'}), 400\n\n        prompt = data.get('prompt', '')\n        max_tokens = data.get('max_tokens', 150)  # Default max_tokens value set to 150\n\n        if not prompt:\n            return jsonify({'error': 'Prompt is required'}), 400\n\n        try:\n            result = MaccaroneVSCode.ai_manager.create_code_block(prompt, max_tokens)\n            if result is not None:\n                return jsonify({'code_block': result}), 200\n            else:\n                return jsonify({'error': 'Failed to generate code block'}), 500\n        except Exception as e:\n            return jsonify({'error': str(e)}), 500\n\nif __name__ == \"__main__\":\n    debug_mode = os.environ.get('FLASK_DEBUG', 'false').lower() in ['true', '1']\n    port = int(os.environ.get('PORT', 5000))\n    app.run(debug=debug_mode, port=port, host='0.0.0.0')\n\n## maccarone_cli.py\nimport argparse\nfrom typing import List\nfrom ai_manager import AIManager\n\nclass MaccaroneCLI:\n    \"\"\"\n    CLI interface for the Maccarone application. It uses the AIManager to update code blocks based on command line inputs.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the CLI interface and prepares the argument parser.\n        \"\"\"\n        self.parser = argparse.ArgumentParser(description=\"Maccarone CLI for managing AI-generated code blocks.\")\n        self._setup_arguments()\n\n    def _setup_arguments(self):\n        \"\"\"\n        Sets up the command line arguments for the CLI.\n        \"\"\"\n        self.parser.add_argument(\n            '--create',\n            type=str,\n            help='Prompt for creating a new code block.',\n            default=\"\"\n        )\n        self.parser.add_argument(\n            '--update',\n            type=str,\n            help='Prompt for updating an existing code block.',\n            default=\"\"\n        )\n        self.parser.add_argument(\n            '--code',\n            type=str,\n            help='The initial code block to update. Required if --update is used.',\n            default=\"\"\n        )\n        self.parser.add_argument(\n            '--max_tokens',\n            type=int,\n            help='Maximum number of tokens to generate or update.',\n            default=150\n        )\n\n    def run_cli(self, arguments: List[str]) -> None:\n        \"\"\"\n        Parses the given command line arguments and executes the CLI logic accordingly.\n\n        :param arguments: The list of command line arguments.\n        \"\"\"\n        args = self.parser.parse_args(arguments)\n        ai_manager = AIManager()\n\n        if args.create:\n            result = ai_manager.create_code_block(args.create, args.max_tokens)\n            if result is not None:\n                print(\"Generated Code Block:\\n\", result)\n            else:\n                print(\"Failed to generate code block.\")\n        elif args.update and args.code:\n            result = ai_manager.update_code_block(args.update, args.code, args.max_tokens)\n            if result is not None:\n                print(\"Updated Code Block:\\n\", result)\n            else:\n                print(\"Failed to update code block.\")\n        else:\n            print(\"No valid operation specified. Use --create to generate a new code block or --update with --code to update an existing one.\")\n\nif __name__ == \"__main__\":\n    import sys\n    cli = MaccaroneCLI()\n    cli.run_cli(sys.argv[1:])\n\n## ai_manager.py\nfrom typing import Optional\nfrom openai_integration import OpenAIIntegration, OpenAIIntegrationError\n\nclass AIManager:\n    \"\"\"\n    Responsible for creating and updating AI-managed code blocks; interacts with openai_integration.py to generate and update code.\n    This class encapsulates the logic for interacting with the OpenAI API to manage code blocks within the project.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the AIManager with an instance of OpenAIIntegration to handle API communications.\n        \"\"\"\n        self.openai_integration = OpenAIIntegration()\n\n    def create_code_block(self, prompt: str, max_tokens: int = 150) -> Optional[str]:\n        \"\"\"\n        Creates a new code block based on the given prompt using the OpenAI API.\n\n        :param prompt: The prompt to generate code for.\n        :param max_tokens: The maximum number of tokens to generate for the code block. Default is 150.\n        :return: The generated code block as a string, or None if an error occurs.\n        \"\"\"\n        try:\n            return self.openai_integration.generate_code(prompt, max_tokens)\n        except OpenAIIntegrationError as e:\n            print(f\"Error creating code block: {e}\")\n            return None\n\n    def update_code_block(self, prompt: str, code_block: str, max_tokens: int = 150) -> Optional[str]:\n        \"\"\"\n        Updates an existing code block based on the given prompt and initial code block using the OpenAI API.\n\n        :param prompt: The prompt describing how to update the code.\n        :param code_block: The initial code block to update.\n        :param max_tokens: The maximum number of tokens to generate for the update. Default is 150.\n        :return: The updated code block as a string, or None if an error occurs.\n        \"\"\"\n        try:\n            return self.openai_integration.update_code(prompt, code_block, max_tokens)\n        except OpenAIIntegrationError as e:\n            print(f\"Error updating code block: {e}\")\n            return None\n\n",
        "design": {
            "0": {
                "relative_path": "examples/file_sizes_ext.py",
                "fqn_list": "examples/file_sizes_ext.py/main",
                "class": null,
                "signature": "def main(path: str, extension: str | None):"
            },
            "1": {
                "relative_path": "examples/add.py",
                "fqn_list": "examples/add.py/add_two_numbers",
                "class": null,
                "signature": "def add_two_numbers(x, y):"
            },
            "2": {
                "relative_path": "examples/fizzbuzz.py",
                "fqn_list": "examples/fizzbuzz.py/main",
                "class": null,
                "signature": "def main(n: int):"
            },
            "3": {
                "relative_path": "examples/todo.py",
                "fqn_list": "examples/todo.py/Todo/__init__",
                "class": "examples/todo.py.Todo",
                "signature": "def __init__(self, description, status = 'not done', id = None):"
            },
            "4": {
                "relative_path": "examples/todo.py",
                "fqn_list": "examples/todo.py/load_todos",
                "class": null,
                "signature": "def load_todos() -> list[Todo]:"
            },
            "5": {
                "relative_path": "examples/todo.py",
                "fqn_list": "examples/todo.py/save_todos",
                "class": null,
                "signature": "def save_todos(todos: list[Todo]) -> None:"
            },
            "6": {
                "relative_path": "examples/todo.py",
                "fqn_list": "examples/todo.py/add_todo",
                "class": null,
                "signature": "def add_todo(description):"
            },
            "7": {
                "relative_path": "examples/todo.py",
                "fqn_list": "examples/todo.py/remove_todo",
                "class": null,
                "signature": "def remove_todo(id):"
            },
            "8": {
                "relative_path": "examples/todo.py",
                "fqn_list": "examples/todo.py/print_todos",
                "class": null,
                "signature": "def print_todos():"
            },
            "9": {
                "relative_path": "examples/todo.py",
                "fqn_list": "examples/todo.py/main",
                "class": null,
                "signature": "def main():"
            },
            "10": {
                "relative_path": "examples/file_sizes.py",
                "fqn_list": "examples/file_sizes.py/main",
                "class": null,
                "signature": "def main(path: str):"
            },
            "11": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/MissingPiece/get_line_pos",
                "class": "src/maccarone/preprocessor.py.MissingPiece",
                "signature": "def get_line_pos(self, raw_source: str) -> Tuple[int, int]:"
            },
            "12": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/MissingPiece/complete",
                "class": "src/maccarone/preprocessor.py.MissingPiece",
                "signature": "def complete(self, replacement: Optional[str]) -> str:"
            },
            "13": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/find_line_number",
                "class": null,
                "signature": "def find_line_number(text: str, pos: int):"
            },
            "14": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/__init__",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def __init__(self, raw_source: str, block_at_line: Optional[int] = None):"
            },
            "15": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/generic_visit",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def generic_visit(self, node: Node, visited_children: List[Node]):"
            },
            "16": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_maccarone",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_maccarone(self, node: Node, visited_children: list):"
            },
            "17": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_maccarone_chunk",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_maccarone_chunk(self, node: Node, visited_children: list):"
            },
            "18": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_snippet(self, node: Node, visited_children: list):"
            },
            "19": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_snippet_open(self, node: Node, visited_children: list):"
            },
            "20": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open_single",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_snippet_open_single(self, node: Node, visited_children: list):"
            },
            "21": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open_multi",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_snippet_open_multi(self, node: Node, visited_children: list):"
            },
            "22": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_open",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_guidance_open(self, node: Node, visited_children: list):"
            },
            "23": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_line",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_guidance_line(self, node: Node, visited_children: list):"
            },
            "24": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_lines",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_guidance_lines(self, node: Node, visited_children: list):"
            },
            "25": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_inner",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_guidance_inner(self, node: Node, visited_children: list):"
            },
            "26": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_human_source",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_human_source(self, node: Node, visited_children: list):"
            },
            "27": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_ai_source",
                "class": "src/maccarone/preprocessor.py.RawSourceVisitor",
                "signature": "def visit_ai_source(self, node: Node, visited_children: list):"
            },
            "28": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/raw_source_to_pieces",
                "class": null,
                "signature": "def raw_source_to_pieces(input: str, block_at_line: Optional[int] = None) -> List[Piece]:"
            },
            "29": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/raw_pieces_to_tagged_input",
                "class": null,
                "signature": "def raw_pieces_to_tagged_input(raw_pieces: List[Piece]) -> str:"
            },
            "30": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/tagged_input_to_tagged_output",
                "class": null,
                "signature": "def tagged_input_to_tagged_output(tagged_input: str, chat_api: ChatAPI) -> str:"
            },
            "31": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/tagged_output_to_completed_pieces",
                "class": null,
                "signature": "def tagged_output_to_completed_pieces(tagged_output: str) -> Dict[int, str]:"
            },
            "32": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/pieces_to_final_source",
                "class": null,
                "signature": "def pieces_to_final_source(raw_pieces: List[Piece], completed_pieces: Dict[int, str]) -> str:"
            },
            "33": {
                "relative_path": "src/maccarone/preprocessor.py",
                "fqn_list": "src/maccarone/preprocessor.py/preprocess_maccarone",
                "class": null,
                "signature": "def preprocess_maccarone(raw_source: str, chat_api: ChatAPI, block_at_line: Optional[int] = None) -> str:"
            },
            "34": {
                "relative_path": "src/maccarone/openai.py",
                "fqn_list": "src/maccarone/openai.py/complete_chat",
                "class": null,
                "signature": "def complete_chat(messages: List[Dict[str, str]], model = \"gpt-4\", on_token: Callable[[int], None] = lambda p: None) -> str:"
            },
            "35": {
                "relative_path": "src/maccarone/openai.py",
                "fqn_list": "src/maccarone/openai.py/ChatAPI/complete_chat",
                "class": "src/maccarone/openai.py.ChatAPI",
                "signature": "def complete_chat(self, chat_name: str, messages: List[Dict[str, str]], model = \"gpt-4\") -> str:"
            },
            "36": {
                "relative_path": "src/maccarone/scripts/preprocess.py",
                "fqn_list": "src/maccarone/scripts/preprocess.py/preprocess",
                "class": null,
                "signature": "def preprocess(mn_path: str, print_: bool, rewrite: bool, block_at_line: Optional[int]) -> None:"
            },
            "37": {
                "relative_path": "src/maccarone/scripts/preprocess.py",
                "fqn_list": "src/maccarone/scripts/preprocess.py/main",
                "class": null,
                "signature": "def main(path: str, print_: bool, rewrite: bool, suffix: str, block_at_line: Optional[int] = None) -> None:"
            },
            "38": {
                "relative_path": "src/maccarone/scripts/preprocess.py",
                "fqn_list": "src/maccarone/scripts/preprocess.py/parse_args",
                "class": null,
                "signature": "def parse_args() -> Namespace:"
            },
            "39": {
                "relative_path": "src/maccarone/scripts/preprocess.py",
                "fqn_list": "src/maccarone/scripts/preprocess.py/script_main",
                "class": null,
                "signature": "def script_main():"
            }
        }
    },
    "SantorinAI": {
        "generated code": "## main.py\nimport pygame\nimport sys\nfrom game import Game\n\nclass Main:\n    def __init__(self):\n        pygame.init()\n        self.screen = pygame.display.set_mode((800, 600))\n        pygame.display.set_caption(\"SantorinAI\")\n        self.game = Game()\n        self.clock = pygame.time.Clock()\n\n    def handle_events(self):\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                return False\n            # Additional event handling can be implemented here\n        return True\n\n    def run(self):\n        self.game.start_game()\n        running = True\n\n        while running:\n            running = self.handle_events()\n            self.game.update_game()  # This method should be properly implemented in the Game class\n            pygame.display.flip()\n            self.clock.tick(60)\n\n        pygame.quit()\n        sys.exit()\n\nif __name__ == \"__main__\":\n    main_instance = Main()\n    main_instance.run()\n\n## ai_player.py\nfrom typing import Optional\nfrom board import Board, Move\nfrom strategy import Strategy  # Assuming Strategy is defined in another module as per design\n\nclass AIPlayer:\n    def __init__(self, strategy: Strategy) -> None:\n        self.strategy = strategy\n\n    def make_move(self, board: Board) -> Optional[Move]:\n        \"\"\"\n        Uses the assigned strategy to calculate the next move on the given board.\n\n        Args:\n            board (Board): The current state of the game board.\n\n        Returns:\n            Optional[Move]: The move decided by the strategy. None if no valid move is found.\n        \"\"\"\n        if not isinstance(board, Board):\n            raise TypeError(\"The board argument must be an instance of Board.\")\n        \n        move = self.strategy.calculate_move(board)\n        if isinstance(move, Move):\n            return move\n        else:\n            return None\n\n## game.py\nfrom typing import List\nfrom ai_player import AIPlayer\nfrom gui import GUI\nfrom board import Board, Move\n\nclass Game:\n    def __init__(self):\n        self.board = Board()\n        self.players: List[AIPlayer] = []\n        self.gui = GUI()\n        self.current_player_index = 0\n\n    def start_game(self):\n        # Initialize players here for demonstration purposes\n        # In a real scenario, players should be added dynamically or through configuration\n        self.players.append(AIPlayer())\n        self.players.append(AIPlayer())\n        self.gui.display_board(self.board)\n\n    def update_game_state(self):\n        if not self.players:\n            raise ValueError(\"No players added to the game\")\n\n        if self.check_game_over():\n            return\n\n        current_player = self.get_current_player()\n        move = current_player.make_move(self.board)\n        if move and isinstance(move, Move):\n            self.board.apply_move(move)\n            self.gui.update_display(move)\n            self.current_player_index = (self.current_player_index + 1) % len(self.players)\n        else:\n            # Handle invalid move more gracefully\n            print(\"Invalid move made by player, please try again.\")\n            # Optionally, implement a retry mechanism here\n\n    def add_player(self, player: AIPlayer):\n        if not isinstance(player, AIPlayer):\n            raise TypeError(\"Only AIPlayer instances can be added as players\")\n        self.players.append(player)\n\n    def remove_player(self, player: AIPlayer):\n        if player in self.players:\n            self.players.remove(player)\n        else:\n            raise ValueError(\"Player not found in the game\")\n\n    def get_current_player(self) -> AIPlayer:\n        return self.players[self.current_player_index]\n\n    def is_game_over(self) -> bool:\n        # Example logic for a win condition\n        # This should be replaced with actual game-specific logic\n        for player in self.players:\n            if player.has_won(self.board):  # Assuming `has_won` is a method implemented in AIPlayer\n                return True\n        return False\n\n    def check_game_over(self):\n        if self.is_game_over():\n            print(\"Game Over\")\n            # Handle game over logic here, such as displaying the winner or resetting the game\n            return True\n        return False\n\n    # Placeholder for Board.apply_move(move) method\n    # This method should be implemented in the Board class\n    # def apply_move(self, move: Move):\n    #     pass\n\n    # Placeholder for AIPlayer.has_won(board) method\n    # This method should be implemented in the AIPlayer class\n    # def has_won(self, board: Board) -> bool:\n    #     pass\n\n## setup.py\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='SantorinAI',\n    version='1.0.0',\n    author='Alex',\n    author_email='alex@example.com',\n    description='A modular and extensible AI framework for the Santorini game',\n    long_description=open('README.md').read(),\n    long_description_content_type='text/markdown',\n    url='https://github.com/alex/SantorinAI',\n    packages=find_packages(),\n    install_requires=[\n        'pygame==2.0.1',\n        'pytest==6.2.4',\n    ],\n    classifiers=[\n        'Programming Language :: Python :: 3',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: OS Independent',\n    ],\n    python_requires='>=3.6',\n    entry_points={\n        'console_scripts': [\n            'santorinai=main:main',\n        ],\n    },\n)\n\n## gui.py\nimport pygame\nfrom board import Board\nfrom move import Move  # Correctly importing Move class\nfrom typing import Tuple, Union\n\nclass GUI:\n    def __init__(self, screen_size: Tuple[int, int] = (800, 600)):\n        \"\"\"\n        Initializes the GUI for the Santorini game.\n\n        Args:\n            screen_size (Tuple[int, int]): The size of the window, default to (800, 600).\n        \"\"\"\n        self.screen_size = screen_size\n        self.screen = pygame.display.set_mode(self.screen_size)\n        pygame.display.set_caption(\"SantorinAI\")\n\n        # Colors\n        self.background_color = (255, 255, 255)  # White\n        self.grid_color = (0, 0, 0)  # Black\n        self.tile_color = (200, 200, 200)  # Light Grey\n\n        # Grid settings\n        self.grid_size = 5  # Santorini is traditionally a 5x5 board\n        self.tile_size = min(self.screen_size) // self.grid_size\n\n    def display_board(self, board: Board) -> None:\n        \"\"\"\n        Displays the game board.\n\n        Args:\n            board (Board): The current state of the game board.\n        \"\"\"\n        if not isinstance(board, Board):\n            raise TypeError(\"The board parameter must be an instance of Board.\")\n\n        self.screen.fill(self.background_color)\n        for row in range(self.grid_size):\n            for col in range(self.grid_size):\n                tile_rect = pygame.Rect(\n                    col * self.tile_size, row * self.tile_size,\n                    self.tile_size, self.tile_size\n                )\n                pygame.draw.rect(self.screen, self.tile_color, tile_rect)\n                pygame.draw.rect(self.screen, self.grid_color, tile_rect, 1)  # Draw border\n\n        pygame.display.flip()\n\n    def update_display(self, move: Move, board: Board) -> None:\n        \"\"\"\n        Updates the display based on the move made. This method now correctly accepts both Move and Board as parameters.\n\n        Args:\n            move (Move): The move that was made.\n            board (Board): The current state of the game board after the move.\n        \"\"\"\n        if not isinstance(move, Move):\n            raise TypeError(\"The move parameter must be an instance of Move.\")\n        if not isinstance(board, Board):\n            raise TypeError(\"The board parameter must be an instance of Board.\")\n\n        # Update only the tile affected by the move\n        tile_rect = pygame.Rect(\n            move.build_position[1] * self.tile_size, move.build_position[0] * self.tile_size,\n            self.tile_size, self.tile_size\n        )\n        pygame.draw.rect(self.screen, self.tile_color, tile_rect)\n        pygame.draw.rect(self.screen, self.grid_color, tile_rect, 1)  # Redraw border\n        pygame.display.update(tile_rect)\n\n",
        "design": {
            "0": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/__init__",
                "class": "santorinai/board.py.Board",
                "signature": "def __init__(self, number_of_players: int):"
            },
            "1": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_move_possible",
                "class": "santorinai/board.py.Board",
                "signature": "def is_move_possible(self, start_pos: Tuple[int, int], end_pos: Tuple[int, int]) -> Tuple[bool, str]:"
            },
            "2": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_position_within_board",
                "class": "santorinai/board.py.Board",
                "signature": "def is_position_within_board(self, position: Tuple[int, int]):"
            },
            "3": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_position_adjacent",
                "class": "santorinai/board.py.Board",
                "signature": "def is_position_adjacent(self, position1: Tuple[int, int], position2: Tuple[int, int]):"
            },
            "4": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_pawn_on_position",
                "class": "santorinai/board.py.Board",
                "signature": "def is_pawn_on_position(self, position: Tuple[int, int]):"
            },
            "5": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_build_possible",
                "class": "santorinai/board.py.Board",
                "signature": "def is_build_possible(self, builder_position: Tuple[int, int], build_position: Tuple[int, int]):"
            },
            "6": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/get_player_pawns",
                "class": "santorinai/board.py.Board",
                "signature": "def get_player_pawns(self, player_number: int) -> List[Pawn]:"
            },
            "7": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/get_player_pawn",
                "class": "santorinai/board.py.Board",
                "signature": "def get_player_pawn(self, player_number: int, pawn_number: int) -> Pawn:"
            },
            "8": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/get_playing_pawn",
                "class": "santorinai/board.py.Board",
                "signature": "def get_playing_pawn(self, pawn_number: int) -> Pawn:"
            },
            "9": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/get_first_unplaced_player_pawn",
                "class": "santorinai/board.py.Board",
                "signature": "def get_first_unplaced_player_pawn(self, player_number: int) -> Pawn:"
            },
            "10": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/get_possible_movement_positions",
                "class": "santorinai/board.py.Board",
                "signature": "def get_possible_movement_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:"
            },
            "11": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/get_possible_building_positions",
                "class": "santorinai/board.py.Board",
                "signature": "def get_possible_building_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:"
            },
            "12": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/get_possible_movement_and_building_positions",
                "class": "santorinai/board.py.Board",
                "signature": "def get_possible_movement_and_building_positions(self, pawn: Pawn):"
            },
            "13": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/place_pawn",
                "class": "santorinai/board.py.Board",
                "signature": "def place_pawn(self, position: Tuple[int, int]) -> Tuple[bool, str]:"
            },
            "14": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/play_move",
                "class": "santorinai/board.py.Board",
                "signature": "def play_move(self, pawn_number: int, move_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:"
            },
            "15": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_position_valid",
                "class": "santorinai/board.py.Board",
                "signature": "def is_position_valid(self, pos: Tuple[int, int]):"
            },
            "16": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_game_over",
                "class": "santorinai/board.py.Board",
                "signature": "def is_game_over(self):"
            },
            "17": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/is_everyone_stuck",
                "class": "santorinai/board.py.Board",
                "signature": "def is_everyone_stuck(self):"
            },
            "18": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/next_turn",
                "class": "santorinai/board.py.Board",
                "signature": "def next_turn(self):"
            },
            "19": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/copy",
                "class": "santorinai/board.py.Board",
                "signature": "def copy(self) -> \"Board\":"
            },
            "20": {
                "relative_path": "santorinai/board.py",
                "fqn_list": "santorinai/board.py/Board/__repr__",
                "class": "santorinai/board.py.Board",
                "signature": "def __repr__(self) -> str:"
            },
            "21": {
                "relative_path": "santorinai/player.py",
                "fqn_list": "santorinai/player.py/Player/__init__",
                "class": "santorinai/player.py.Player",
                "signature": "def __init__(self, player_number: int, log_level = 0) -> None:"
            },
            "22": {
                "relative_path": "santorinai/player.py",
                "fqn_list": "santorinai/player.py/Player/name",
                "class": "santorinai/player.py.Player",
                "signature": "def name(self):"
            },
            "23": {
                "relative_path": "santorinai/player.py",
                "fqn_list": "santorinai/player.py/Player/place_pawn",
                "class": "santorinai/player.py.Player",
                "signature": "def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:"
            },
            "24": {
                "relative_path": "santorinai/player.py",
                "fqn_list": "santorinai/player.py/Player/play_move",
                "class": "santorinai/player.py.Player",
                "signature": "def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:"
            },
            "25": {
                "relative_path": "santorinai/pawn.py",
                "fqn_list": "santorinai/pawn.py/Pawn/__init__",
                "class": "santorinai/pawn.py.Pawn",
                "signature": "def __init__(self, number: int, order: int, player_number: int):"
            },
            "26": {
                "relative_path": "santorinai/pawn.py",
                "fqn_list": "santorinai/pawn.py/Pawn/move",
                "class": "santorinai/pawn.py.Pawn",
                "signature": "def move(self, new_pos: Tuple[int, int]):"
            },
            "27": {
                "relative_path": "santorinai/pawn.py",
                "fqn_list": "santorinai/pawn.py/Pawn/copy",
                "class": "santorinai/pawn.py.Pawn",
                "signature": "def copy(self) -> \"Pawn\":"
            },
            "28": {
                "relative_path": "santorinai/pawn.py",
                "fqn_list": "santorinai/pawn.py/Pawn/__repr__",
                "class": "santorinai/pawn.py.Pawn",
                "signature": "def __repr__(self):"
            },
            "29": {
                "relative_path": "santorinai/board_displayer/board_displayer.py",
                "fqn_list": "santorinai/board_displayer/board_displayer.py/init_window",
                "class": null,
                "signature": "def init_window(player_names):"
            },
            "30": {
                "relative_path": "santorinai/board_displayer/board_displayer.py",
                "fqn_list": "santorinai/board_displayer/board_displayer.py/draw_isometric_cube",
                "class": null,
                "signature": "def draw_isometric_cube(window: sg.Window, x, y, size, cube_heigth, color, line_color, line_width):"
            },
            "31": {
                "relative_path": "santorinai/board_displayer/board_displayer.py",
                "fqn_list": "santorinai/board_displayer/board_displayer.py/update_board",
                "class": null,
                "signature": "def update_board(window: sg.Window, board: Board):"
            },
            "32": {
                "relative_path": "santorinai/board_displayer/board_displayer.py",
                "fqn_list": "santorinai/board_displayer/board_displayer.py/close_window",
                "class": null,
                "signature": "def close_window(window):"
            },
            "33": {
                "relative_path": "santorinai/player_examples/first_choice_player.py",
                "fqn_list": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/__init__",
                "class": "santorinai/player_examples/first_choice_player.py.FirstChoicePlayer",
                "signature": "def __init__(self, player_number, log_level = 0) -> None:"
            },
            "34": {
                "relative_path": "santorinai/player_examples/first_choice_player.py",
                "fqn_list": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/name",
                "class": "santorinai/player_examples/first_choice_player.py.FirstChoicePlayer",
                "signature": "def name(self):"
            },
            "35": {
                "relative_path": "santorinai/player_examples/first_choice_player.py",
                "fqn_list": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/place_pawn",
                "class": "santorinai/player_examples/first_choice_player.py.FirstChoicePlayer",
                "signature": "def place_pawn(self, board: Board, pawn: Pawn):"
            },
            "36": {
                "relative_path": "santorinai/player_examples/first_choice_player.py",
                "fqn_list": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/play_move",
                "class": "santorinai/player_examples/first_choice_player.py.FirstChoicePlayer",
                "signature": "def play_move(self, board: Board):"
            },
            "37": {
                "relative_path": "santorinai/player_examples/random_player.py",
                "fqn_list": "santorinai/player_examples/random_player.py/RandomPlayer/__init__",
                "class": "santorinai/player_examples/random_player.py.RandomPlayer",
                "signature": "def __init__(self, player_number, log_level = 0) -> None:"
            },
            "38": {
                "relative_path": "santorinai/player_examples/random_player.py",
                "fqn_list": "santorinai/player_examples/random_player.py/RandomPlayer/name",
                "class": "santorinai/player_examples/random_player.py.RandomPlayer",
                "signature": "def name(self):"
            },
            "39": {
                "relative_path": "santorinai/player_examples/random_player.py",
                "fqn_list": "santorinai/player_examples/random_player.py/RandomPlayer/place_pawn",
                "class": "santorinai/player_examples/random_player.py.RandomPlayer",
                "signature": "def place_pawn(self, board: Board, pawn: Pawn):"
            },
            "40": {
                "relative_path": "santorinai/player_examples/random_player.py",
                "fqn_list": "santorinai/player_examples/random_player.py/RandomPlayer/play_move",
                "class": "santorinai/player_examples/random_player.py.RandomPlayer",
                "signature": "def play_move(self, board: Board):"
            },
            "41": {
                "relative_path": "santorinai/player_examples/basic_player.py",
                "fqn_list": "santorinai/player_examples/basic_player.py/BasicPlayer/__init__",
                "class": "santorinai/player_examples/basic_player.py.BasicPlayer",
                "signature": "def __init__(self, player_number, log_level = 0) -> None:"
            },
            "42": {
                "relative_path": "santorinai/player_examples/basic_player.py",
                "fqn_list": "santorinai/player_examples/basic_player.py/BasicPlayer/name",
                "class": "santorinai/player_examples/basic_player.py.BasicPlayer",
                "signature": "def name(self):"
            },
            "43": {
                "relative_path": "santorinai/player_examples/basic_player.py",
                "fqn_list": "santorinai/player_examples/basic_player.py/BasicPlayer/get_ally_pawn",
                "class": "santorinai/player_examples/basic_player.py.BasicPlayer",
                "signature": "def get_ally_pawn(self, board: Board, our_pawn: Pawn) -> Tuple[Pawn, None]:"
            },
            "44": {
                "relative_path": "santorinai/player_examples/basic_player.py",
                "fqn_list": "santorinai/player_examples/basic_player.py/BasicPlayer/get_enemy_pawns",
                "class": "santorinai/player_examples/basic_player.py.BasicPlayer",
                "signature": "def get_enemy_pawns(self, board, our_pawn):"
            },
            "45": {
                "relative_path": "santorinai/player_examples/basic_player.py",
                "fqn_list": "santorinai/player_examples/basic_player.py/BasicPlayer/get_winning_moves",
                "class": "santorinai/player_examples/basic_player.py.BasicPlayer",
                "signature": "def get_winning_moves(self, board: Board, pawn):"
            },
            "46": {
                "relative_path": "santorinai/player_examples/basic_player.py",
                "fqn_list": "santorinai/player_examples/basic_player.py/BasicPlayer/place_pawn",
                "class": "santorinai/player_examples/basic_player.py.BasicPlayer",
                "signature": "def place_pawn(self, board: Board, pawn):"
            },
            "47": {
                "relative_path": "santorinai/player_examples/basic_player.py",
                "fqn_list": "santorinai/player_examples/basic_player.py/BasicPlayer/play_move",
                "class": "santorinai/player_examples/basic_player.py.BasicPlayer",
                "signature": "def play_move(self, board):"
            }
        }
    },
    "alembic-postgresql-enum": {
        "generated code": "## main.py\nimport os\nfrom alembic_env import AlembicEnv\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import sessionmaker\nfrom myapp.mymodel import Base  # Adjust this import according to your project's structure\n\ndef main():\n    # Database connection string, adjust as necessary or use environment variables for better security\n    DATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql+psycopg2://user:password@localhost/dbname\")\n    \n    try:\n        # Create the SQLAlchemy engine\n        engine = create_engine(DATABASE_URL)\n        \n        # Create a configured \"Session\" class\n        Session = sessionmaker(bind=engine)\n        \n        # Create a new session to interact with the database\n        session = Session()\n        \n        # Ensure your models are imported before this point\n        Base.metadata.create_all(engine)\n        \n        # Configure and run Alembic migrations\n        AlembicEnv.configure()\n        if AlembicEnv.is_offline_mode():\n            AlembicEnv.run_migrations_offline()\n        else:\n            AlembicEnv.run_migrations_online()\n    except SQLAlchemyError as e:\n        print(f\"An error occurred while setting up the database: {e}\")\n    finally:\n        # Close the session if it's open\n        if 'session' in locals():\n            session.close()\n\nif __name__ == \"__main__\":\n    main()\n\n## utils.py\nfrom typing import Dict, List, Set\nfrom sqlalchemy import MetaData, Enum\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.sql import sqltypes\n\nclass Utils:\n    @staticmethod\n    def get_model_enums(metadata: MetaData) -> Dict[str, List[str]]:\n        \"\"\"\n        Extracts enums defined in the SQLAlchemy models.\n\n        :param metadata: SQLAlchemy MetaData object for schema metadata.\n        :return: A dictionary with enum names as keys and lists of enum values as values.\n        \"\"\"\n        enums = {}\n        for table in metadata.tables.values():\n            for column in table.columns:\n                if isinstance(column.type, Enum):\n                    enums[column.type.name] = list(column.type.enums)\n        return enums\n\n    @staticmethod\n    def get_db_enums(engine: Engine) -> Dict[str, List[str]]:\n        \"\"\"\n        Fetches enums currently defined in the database.\n\n        :param engine: SQLAlchemy Engine object for database connection.\n        :return: A dictionary with enum names as keys and lists of enum values as values.\n        \"\"\"\n        enums = {}\n        with engine.connect() as conn:\n            result = conn.execute(\"SELECT t.typname as enum_name, \"\n                                  \"       e.enumlabel as enum_value \"\n                                  \"FROM pg_type t \"\n                                  \"JOIN pg_enum e ON t.oid = e.enumtypid \"\n                                  \"JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\")\n            for row in result:\n                if row['enum_name'] in enums:\n                    enums[row['enum_name']].append(row['enum_value'])\n                else:\n                    enums[row['enum_name']] = [row['enum_value']]\n        return enums\n\n    @staticmethod\n    def get_enum_diff(old_enum: List[str], new_enum: List[str]) -> Dict[str, Set[str]]:\n        \"\"\"\n        Compares two lists of enum values and identifies differences.\n\n        :param old_enum: The original list of enum values.\n        :param new_enum: The new list of enum values.\n        :return: A dictionary with keys 'added' and 'removed', each containing a set of values that were added or removed.\n        \"\"\"\n        old_set, new_set = set(old_enum), set(new_enum)\n        return {\n            'added': new_set - old_set,\n            'removed': old_set - new_set\n        }\n\n    @staticmethod\n    def get_unused_enums(db_enums: Dict[str, List[str]], model_enums: Dict[str, List[str]]) -> List[str]:\n        \"\"\"\n        Identifies enums that are present in the database but not used in the models.\n\n        :param db_enums: A dictionary of enums currently defined in the database.\n        :param model_enums: A dictionary of enums defined in the SQLAlchemy models.\n        :return: A list of enum names that are unused.\n        \"\"\"\n        unused_enums = list(set(db_enums.keys()) - set(model_enums.keys()))\n        return unused_enums\n\n## enum_handler.py\nfrom typing import List\nfrom sqlalchemy import MetaData, inspect\nfrom migration_operations import MigrationOperations\nfrom utils import Utils\n\nclass EnumHandler:\n    def __init__(self, engine, metadata: MetaData):\n        \"\"\"\n        Initializes the EnumHandler with a database engine and metadata.\n\n        :param engine: SQLAlchemy Engine object for database connection.\n        :param metadata: SQLAlchemy MetaData object for schema metadata.\n        \"\"\"\n        self.engine = engine\n        self.metadata = metadata\n        self.migration_operations = MigrationOperations(engine)\n        self.utils = Utils()\n\n    def detect_new_enums(self) -> List[str]:\n        \"\"\"\n        Detects new enums that need to be added to the database.\n\n        :return: A list of new enum names to be added.\n        \"\"\"\n        model_enums = self.utils.get_model_enums(self.metadata)\n        db_enums = self.utils.get_db_enums(self.engine)\n        new_enums = list(set(model_enums) - set(db_enums))\n        return new_enums\n\n    def detect_enum_changes(self) -> List[str]:\n        \"\"\"\n        Detects changes to existing enums, such as added or removed values.\n\n        :return: A list of changed enum names.\n        \"\"\"\n        model_enums = self.utils.get_model_enums(self.metadata)\n        db_enums = self.utils.get_db_enums(self.engine)\n        changed_enums = []\n        for enum_name, model_values in model_enums.items():\n            if enum_name in db_enums:\n                db_values = db_enums[enum_name]\n                if set(model_values) != set(db_values):\n                    changed_enums.append(enum_name)\n        return changed_enums\n\n    def remove_unused_enums(self) -> List[str]:\n        \"\"\"\n        Detects and removes enums that are no longer used in the models from the database.\n\n        :return: A list of dropped enum names.\n        \"\"\"\n        model_enums = self.utils.get_model_enums(self.metadata)\n        db_enums = self.utils.get_db_enums(self.engine)\n        unused_enums = list(set(db_enums) - set(model_enums))\n        \n        # Check for actual usage in the database schema before removing\n        inspector = inspect(self.engine)\n        used_enums = set()\n        for table_name in inspector.get_table_names():\n            for column in inspector.get_columns(table_name):\n                if column['type'].__visit_name__ == 'ENUM':\n                    used_enums.add(column['type'].name)\n        unused_enums = [enum for enum in unused_enums if enum not in used_enums]\n        \n        return unused_enums\n\n    def process_revision_directives(self, context, revision, directives):\n        \"\"\"\n        Processes revision directives for Alembic migrations, integrating enum handling.\n\n        :param context: Alembic migration context.\n        :param revision: Current revision.\n        :param directives: List of current directives.\n        \"\"\"\n        new_enums = self.detect_new_enums()\n        for enum_name in new_enums:\n            enum_values = self.utils.get_model_enum_values(enum_name, self.metadata)\n            self.migration_operations.add_enum(enum_name, values=enum_values)\n\n        changed_enums = self.detect_enum_changes()\n        for enum_name in changed_enums:\n            enum_values = self.utils.get_model_enum_values(enum_name, self.metadata)\n            self.migration_operations.alter_enum(enum_name, values=enum_values)\n\n        unused_enums = self.remove_unused_enums()\n        for enum_name in unused_enums:\n            self.migration_operations.drop_enum(enum_name)\n\n## alembic_env.py\nfrom logging.config import fileConfig\nfrom sqlalchemy import engine_from_config, pool\nfrom alembic import context\nfrom enum_handler import EnumHandler\nimport os\nimport sys\n\n# Import your model's MetaData object here\n# for 'autogenerate' support\n# Example:\n# from myapp.mymodel import Base\n# target_metadata = Base.metadata\n# Adjust the import statement according to your project structure\nfrom myapp.mymodel import Base\ntarget_metadata = Base.metadata\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\nclass AlembicEnv:\n    @staticmethod\n    def configure() -> None:\n        \"\"\"\n        Configures the Alembic environment.\n        \"\"\"\n        # Placeholder for any setup configurations you might have.\n        pass\n\n    @staticmethod\n    def run_migrations_online() -> None:\n        \"\"\"\n        Run migrations in 'online' mode with enum handling.\n        \"\"\"\n        connectable = engine_from_config(\n            config.get_section(config.config_ini_section),\n            prefix='sqlalchemy.',\n            poolclass=pool.NullPool,\n        )\n\n        enum_handler = EnumHandler()\n\n        with connectable.connect() as connection:\n            context.configure(\n                connection=connection,\n                target_metadata=target_metadata,\n                process_revision_directives=enum_handler.process_revision_directives,\n                **config.get_section('alembic:env')\n            )\n\n            with context.begin_transaction():\n                # Enum handling before running migrations\n                enum_handler.detect_new_enums()\n                enum_handler.detect_enum_changes()\n                enum_handler.remove_unused_enums()\n                # Running migrations\n                context.run_migrations()\n\n    @staticmethod\n    def run_migrations_offline() -> None:\n        \"\"\"\n        Run migrations in 'offline' mode with enum handling.\n        \"\"\"\n        url = config.get_main_option(\"sqlalchemy.url\")\n        context.configure(\n            url=url,\n            target_metadata=target_metadata,\n            process_revision_directives=EnumHandler.process_revision_directives,\n            literal_binds=True,\n            dialect_opts={\"paramstyle\": \"named\"},\n            **config.get_section('alembic:env')\n        )\n\n        enum_handler = EnumHandler()\n\n        with context.begin_transaction():\n            # Enum handling before running migrations\n            enum_handler.detect_new_enums()\n            enum_handler.detect_enum_changes()\n            enum_handler.remove_unused_enums()\n            # Running migrations\n            context.run_migrations()\n\n# Determine if running in online or offline mode and execute migrations accordingly.\nif context.is_offline_mode():\n    AlembicEnv.run_migrations_offline()\nelse:\n    AlembicEnv.run_migrations_online()\n\n## migration_operations.py\nfrom sqlalchemy import create_engine, text\nfrom sqlalchemy.exc import ProgrammingError\nfrom typing import List\n\nclass MigrationOperations:\n    def __init__(self, engine):\n        \"\"\"\n        Initializes the MigrationOperations with a database engine.\n\n        :param engine: SQLAlchemy Engine object for database connection.\n        \"\"\"\n        self.engine = engine\n\n    def add_enum(self, enum_name: str, values: List[str]) -> None:\n        \"\"\"\n        Adds a new enum type to the database.\n\n        :param enum_name: The name of the enum type to add.\n        :param values: A list of values for the new enum type.\n        \"\"\"\n        enum_values = \"', '\".join(values)\n        create_enum_query = f\"CREATE TYPE {enum_name} AS ENUM ('{enum_values}');\"\n        with self.engine.connect() as conn:\n            conn.execute(text(create_enum_query))\n\n    def alter_enum(self, enum_name: str, values: List[str]) -> None:\n        \"\"\"\n        Alters an existing enum type by adding new values. This operation does not support removing values.\n\n        :param enum_name: The name of the enum type to alter.\n        :param values: A list of new values to add to the enum type.\n        \"\"\"\n        with self.engine.connect() as conn:\n            for value in values:\n                add_value_query = f\"ALTER TYPE {enum_name} ADD VALUE IF NOT EXISTS '{value}';\"\n                try:\n                    conn.execute(text(add_value_query))\n                except ProgrammingError as e:\n                    # Log the specific exception or handle it as appropriate\n                    print(f\"Value '{value}' already exists in enum '{enum_name}'. Exception: {e}\")\n\n    def drop_enum(self, enum_name: str) -> None:\n        \"\"\"\n        Drops an enum type from the database.\n\n        :param enum_name: The name of the enum type to drop.\n        \"\"\"\n        drop_enum_query = f\"DROP TYPE IF EXISTS {enum_name};\"\n        with self.engine.connect() as conn:\n            conn.execute(text(drop_enum_query))\n\n",
        "design": {
            "0": {
                "relative_path": "alembic_postgresql_enum/connection.py",
                "fqn_list": "alembic_postgresql_enum/connection.py/get_connection",
                "class": null,
                "signature": "def get_connection(operations) -> Iterator[sqlalchemy.engine.Connection]:"
            },
            "1": {
                "relative_path": "alembic_postgresql_enum/compare_dispatch.py",
                "fqn_list": "alembic_postgresql_enum/compare_dispatch.py/compare_enums",
                "class": null,
                "signature": "def compare_enums(autogen_context: AutogenContext, upgrade_ops: UpgradeOps, schema_names: Iterable[Union[str, None]]):"
            },
            "2": {
                "relative_path": "alembic_postgresql_enum/add_create_type_false.py",
                "fqn_list": "alembic_postgresql_enum/add_create_type_false.py/ReprWorkaround/__repr__",
                "class": "alembic_postgresql_enum/add_create_type_false.py.ReprWorkaround",
                "signature": "def __repr__(self):"
            },
            "3": {
                "relative_path": "alembic_postgresql_enum/add_create_type_false.py",
                "fqn_list": "alembic_postgresql_enum/add_create_type_false.py/get_replacement_type",
                "class": null,
                "signature": "def get_replacement_type(column_type):"
            },
            "4": {
                "relative_path": "alembic_postgresql_enum/add_create_type_false.py",
                "fqn_list": "alembic_postgresql_enum/add_create_type_false.py/inject_repr_into_enums",
                "class": null,
                "signature": "def inject_repr_into_enums(column: Column):"
            },
            "5": {
                "relative_path": "alembic_postgresql_enum/add_create_type_false.py",
                "fqn_list": "alembic_postgresql_enum/add_create_type_false.py/add_create_type_false",
                "class": null,
                "signature": "def add_create_type_false(upgrade_ops: UpgradeOps):"
            },
            "6": {
                "relative_path": "alembic_postgresql_enum/add_postgres_using_to_text.py",
                "fqn_list": "alembic_postgresql_enum/add_postgres_using_to_text.py/PostgresUsingAlterColumnOp/reverse",
                "class": "alembic_postgresql_enum/add_postgres_using_to_text.py.PostgresUsingAlterColumnOp",
                "signature": "def reverse(self):"
            },
            "7": {
                "relative_path": "alembic_postgresql_enum/add_postgres_using_to_text.py",
                "fqn_list": "alembic_postgresql_enum/add_postgres_using_to_text.py/_postgres_using_alter_column",
                "class": null,
                "signature": "def _postgres_using_alter_column(autogen_context: AutogenContext, op: ops.AlterColumnOp) -> str:"
            },
            "8": {
                "relative_path": "alembic_postgresql_enum/add_postgres_using_to_text.py",
                "fqn_list": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_alter_operation",
                "class": null,
                "signature": "def add_postgres_using_to_alter_operation(op: AlterColumnOp):"
            },
            "9": {
                "relative_path": "alembic_postgresql_enum/add_postgres_using_to_text.py",
                "fqn_list": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_text",
                "class": null,
                "signature": "def add_postgres_using_to_text(upgrade_ops: UpgradeOps):"
            },
            "10": {
                "relative_path": "alembic_postgresql_enum/sql_commands/enum_type.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_array_enum_type_to_new",
                "class": null,
                "signature": "def cast_old_array_enum_type_to_new(connection: \"Connection\", table_reference: TableReference, enum_type_name: str, enum_values_to_rename: List[Tuple[str, str]]):"
            },
            "11": {
                "relative_path": "alembic_postgresql_enum/sql_commands/enum_type.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_enum_type_to_new",
                "class": null,
                "signature": "def cast_old_enum_type_to_new(connection: \"Connection\", table_reference: TableReference, enum_type_name: str, enum_values_to_rename: List[Tuple[str, str]]):"
            },
            "12": {
                "relative_path": "alembic_postgresql_enum/sql_commands/enum_type.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/enum_type.py/drop_type",
                "class": null,
                "signature": "def drop_type(connection: \"Connection\", schema: str, type_name: str):"
            },
            "13": {
                "relative_path": "alembic_postgresql_enum/sql_commands/enum_type.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/enum_type.py/rename_type",
                "class": null,
                "signature": "def rename_type(connection: \"Connection\", schema: str, type_name: str, new_type_name: str):"
            },
            "14": {
                "relative_path": "alembic_postgresql_enum/sql_commands/enum_type.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/enum_type.py/create_type",
                "class": null,
                "signature": "def create_type(connection: \"Connection\", schema: str, type_name: str, enum_values: List[str]):"
            },
            "15": {
                "relative_path": "alembic_postgresql_enum/sql_commands/enum_type.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/enum_type.py/get_all_enums",
                "class": null,
                "signature": "def get_all_enums(connection: \"Connection\", schema: str):"
            },
            "16": {
                "relative_path": "alembic_postgresql_enum/sql_commands/column_default.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/column_default.py/get_column_default",
                "class": null,
                "signature": "def get_column_default(connection: \"Connection\", table_schema: str, table_name: str, column_name: str) -> Union[str, None]:"
            },
            "17": {
                "relative_path": "alembic_postgresql_enum/sql_commands/column_default.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/column_default.py/drop_default",
                "class": null,
                "signature": "def drop_default(connection: \"Connection\", table_name_with_schema: str, column_name: str):"
            },
            "18": {
                "relative_path": "alembic_postgresql_enum/sql_commands/column_default.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/column_default.py/set_default",
                "class": null,
                "signature": "def set_default(connection: \"Connection\", table_name_with_schema: str, column_name: str, default_value: str):"
            },
            "19": {
                "relative_path": "alembic_postgresql_enum/sql_commands/column_default.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/column_default.py/rename_default_if_required",
                "class": null,
                "signature": "def rename_default_if_required(schema: str, default_value: str, enum_name: str, enum_values_to_rename: List[Tuple[str, str]]) -> str:"
            },
            "20": {
                "relative_path": "alembic_postgresql_enum/sql_commands/column_default.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/column_default.py/_replace_strings_in_quotes",
                "class": null,
                "signature": "def _replace_strings_in_quotes(old_default: str, enum_values_to_rename: List[Tuple[str, str]]) -> str:"
            },
            "21": {
                "relative_path": "alembic_postgresql_enum/sql_commands/comparison_operators.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_create_comparison_operator",
                "class": null,
                "signature": "def _create_comparison_operator(connection: \"Connection\", schema: str, enum_name: str, old_enum_name: str, enum_values_to_rename: List[Tuple[str, str]], operator: str, comparison_function_name: str):"
            },
            "22": {
                "relative_path": "alembic_postgresql_enum/sql_commands/comparison_operators.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/comparison_operators.py/create_comparison_operators",
                "class": null,
                "signature": "def create_comparison_operators(connection: \"Connection\", schema: str, enum_name: str, old_enum_name: str, enum_values_to_rename: List[Tuple[str, str]]):"
            },
            "23": {
                "relative_path": "alembic_postgresql_enum/sql_commands/comparison_operators.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_drop_comparison_operator",
                "class": null,
                "signature": "def _drop_comparison_operator(connection: \"Connection\", schema: str, enum_name: str, old_enum_name: str, comparison_function_name: str):"
            },
            "24": {
                "relative_path": "alembic_postgresql_enum/sql_commands/comparison_operators.py",
                "fqn_list": "alembic_postgresql_enum/sql_commands/comparison_operators.py/drop_comparison_operators",
                "class": null,
                "signature": "def drop_comparison_operators(connection: \"Connection\", schema: str, enum_name: str, old_enum_name: str):"
            },
            "25": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/types.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/types.py/ColumnType/__repr__",
                "class": "alembic_postgresql_enum/get_enum_data/types.py.ColumnType",
                "signature": "def __repr__(self):"
            },
            "26": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/types.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/__repr__",
                "class": "alembic_postgresql_enum/get_enum_data/types.py.TableReference",
                "signature": "def __repr__(self):"
            },
            "27": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/types.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/is_column_type_import_needed",
                "class": "alembic_postgresql_enum/get_enum_data/types.py.TableReference",
                "signature": "def is_column_type_import_needed(self):"
            },
            "28": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/types.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/table_name_with_schema",
                "class": "alembic_postgresql_enum/get_enum_data/types.py.TableReference",
                "signature": "def table_name_with_schema(self):"
            },
            "29": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/defined_enums.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/defined_enums.py/_remove_schema_prefix",
                "class": null,
                "signature": "def _remove_schema_prefix(enum_name: str, schema: str) -> str:"
            },
            "30": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/defined_enums.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/defined_enums.py/get_defined_enums",
                "class": null,
                "signature": "def get_defined_enums(connection: \"Connection\", schema: str) -> EnumNamesToValues:"
            },
            "31": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/declared_enums.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_enum_values",
                "class": null,
                "signature": "def get_enum_values(enum_type: sqlalchemy.Enum) -> \"Tuple[str, ...]\":"
            },
            "32": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/declared_enums.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/declared_enums.py/column_type_is_enum",
                "class": null,
                "signature": "def column_type_is_enum(column_type: Any) -> bool:"
            },
            "33": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/declared_enums.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_declared_enums",
                "class": null,
                "signature": "def get_declared_enums(metadata: Union[MetaData, List[MetaData]], schema: str, default_schema: str, connection: \"Connection\", upgrade_ops: Optional[UpgradeOps] = None) -> DeclaredEnumValues:"
            },
            "34": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_add_column_op",
                "class": null,
                "signature": "def _get_default_from_add_column_op(op: AddColumnOp, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:"
            },
            "35": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_alter_column_op",
                "class": null,
                "signature": "def _get_default_from_alter_column_op(op: AlterColumnOp, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:"
            },
            "36": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_column",
                "class": null,
                "signature": "def _get_default_from_column(column: Column, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:"
            },
            "37": {
                "relative_path": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py",
                "fqn_list": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/get_just_added_defaults",
                "class": null,
                "signature": "def get_just_added_defaults(upgrade_ops: Optional[UpgradeOps], default_schema: str) -> Dict[ColumnLocation, Optional[str]]:"
            },
            "38": {
                "relative_path": "alembic_postgresql_enum/detection_of_changes/enum_creation.py",
                "fqn_list": "alembic_postgresql_enum/detection_of_changes/enum_creation.py/create_new_enums",
                "class": null,
                "signature": "def create_new_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, schema: str, upgrade_ops: UpgradeOps):"
            },
            "39": {
                "relative_path": "alembic_postgresql_enum/detection_of_changes/enum_alteration.py",
                "fqn_list": "alembic_postgresql_enum/detection_of_changes/enum_alteration.py/sync_changed_enums",
                "class": null,
                "signature": "def sync_changed_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, table_references: EnumNamesToTableReferences, schema: str, upgrade_ops: UpgradeOps):"
            },
            "40": {
                "relative_path": "alembic_postgresql_enum/detection_of_changes/enum_deletion.py",
                "fqn_list": "alembic_postgresql_enum/detection_of_changes/enum_deletion.py/drop_unused_enums",
                "class": null,
                "signature": "def drop_unused_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, schema: str, upgrade_ops: UpgradeOps):"
            },
            "41": {
                "relative_path": "alembic_postgresql_enum/operations/sync_enum_values.py",
                "fqn_list": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/__init__",
                "class": "alembic_postgresql_enum/operations/sync_enum_values.py.SyncEnumValuesOp",
                "signature": "def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):"
            },
            "42": {
                "relative_path": "alembic_postgresql_enum/operations/sync_enum_values.py",
                "fqn_list": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/reverse",
                "class": "alembic_postgresql_enum/operations/sync_enum_values.py.SyncEnumValuesOp",
                "signature": "def reverse(self):"
            },
            "43": {
                "relative_path": "alembic_postgresql_enum/operations/sync_enum_values.py",
                "fqn_list": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/_set_enum_values",
                "class": "alembic_postgresql_enum/operations/sync_enum_values.py.SyncEnumValuesOp",
                "signature": "def _set_enum_values(cls, connection: \"Connection\", enum_schema: str, enum_name: str, new_values: List[str], affected_columns: List[TableReference], enum_values_to_rename: List[Tuple[str, str]]):"
            },
            "44": {
                "relative_path": "alembic_postgresql_enum/operations/sync_enum_values.py",
                "fqn_list": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/sync_enum_values",
                "class": "alembic_postgresql_enum/operations/sync_enum_values.py.SyncEnumValuesOp",
                "signature": "def sync_enum_values(cls, operations, enum_schema: str, enum_name: str, new_values: List[str], affected_columns: List[Tuple[str, str]], enum_values_to_rename: Iterable[Tuple[str, str]] = tuple()):"
            },
            "45": {
                "relative_path": "alembic_postgresql_enum/operations/sync_enum_values.py",
                "fqn_list": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/to_diff_tuple",
                "class": "alembic_postgresql_enum/operations/sync_enum_values.py.SyncEnumValuesOp",
                "signature": "def to_diff_tuple(self) -> Tuple[Any, ...]:"
            },
            "46": {
                "relative_path": "alembic_postgresql_enum/operations/sync_enum_values.py",
                "fqn_list": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/is_column_type_import_needed",
                "class": "alembic_postgresql_enum/operations/sync_enum_values.py.SyncEnumValuesOp",
                "signature": "def is_column_type_import_needed(self) -> bool:"
            },
            "47": {
                "relative_path": "alembic_postgresql_enum/operations/sync_enum_values.py",
                "fqn_list": "alembic_postgresql_enum/operations/sync_enum_values.py/render_sync_enum_value_op",
                "class": null,
                "signature": "def render_sync_enum_value_op(autogen_context: AutogenContext, op: SyncEnumValuesOp):"
            },
            "48": {
                "relative_path": "alembic_postgresql_enum/operations/enum_lifecycle_base.py",
                "fqn_list": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/__init__",
                "class": "alembic_postgresql_enum/operations/enum_lifecycle_base.py.EnumLifecycleOp",
                "signature": "def __init__(self, schema: str, name: str, enum_values: Iterable[str]):"
            },
            "49": {
                "relative_path": "alembic_postgresql_enum/operations/enum_lifecycle_base.py",
                "fqn_list": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/operation_name",
                "class": "alembic_postgresql_enum/operations/enum_lifecycle_base.py.EnumLifecycleOp",
                "signature": "def operation_name(self) -> str:"
            },
            "50": {
                "relative_path": "alembic_postgresql_enum/operations/enum_lifecycle_base.py",
                "fqn_list": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/to_diff_tuple",
                "class": "alembic_postgresql_enum/operations/enum_lifecycle_base.py.EnumLifecycleOp",
                "signature": "def to_diff_tuple(self) -> Tuple[Any, ...]:"
            },
            "51": {
                "relative_path": "alembic_postgresql_enum/operations/create_enum.py",
                "fqn_list": "alembic_postgresql_enum/operations/create_enum.py/CreateEnumOp/reverse",
                "class": "alembic_postgresql_enum/operations/create_enum.py.CreateEnumOp",
                "signature": "def reverse(self):"
            },
            "52": {
                "relative_path": "alembic_postgresql_enum/operations/create_enum.py",
                "fqn_list": "alembic_postgresql_enum/operations/create_enum.py/render_create_enum_op",
                "class": null,
                "signature": "def render_create_enum_op(autogen_context: AutogenContext, op: CreateEnumOp):"
            },
            "53": {
                "relative_path": "alembic_postgresql_enum/operations/drop_enum.py",
                "fqn_list": "alembic_postgresql_enum/operations/drop_enum.py/DropEnumOp/reverse",
                "class": "alembic_postgresql_enum/operations/drop_enum.py.DropEnumOp",
                "signature": "def reverse(self):"
            },
            "54": {
                "relative_path": "alembic_postgresql_enum/operations/drop_enum.py",
                "fqn_list": "alembic_postgresql_enum/operations/drop_enum.py/render_drop_enum_op",
                "class": null,
                "signature": "def render_drop_enum_op(autogen_context: AutogenContext, op: DropEnumOp):"
            }
        }
    },
    "PyNest": {
        "generated code": "## main.py\nimport uvicorn\nfrom fastapi import FastAPI\nfrom app import create_app\n\napp = create_app()\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\n## config.py\nfrom pydantic import BaseSettings, Field\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str = Field(\"sqlite:///./sql_app.db\", env=\"DATABASE_URL\")\n    SECRET_KEY: str = Field(\"YOUR_SECRET_KEY\", env=\"SECRET_KEY\")\n    # Add more configuration variables here with default values and environment variable support\n\n    class Config:\n        # Configuration class to specify the settings source\n        # and other Pydantic model configurations\n        env_file = \".env\"\n        env_file_encoding = 'utf-8'\n\n# Instantiate the Settings class to be used across the project\nsettings = Settings()\n\n## cli.py\nimport typer\nfrom pathlib import Path\nimport os\n\napp = typer.Typer()\n\ndef create_directory_structure(name: str):\n    \"\"\"\n    Creates the basic directory structure for a new project.\n    \"\"\"\n    directories = [\n        f\"{name}/app\",\n        f\"{name}/app/plugins\",\n        f\"{name}/tests\",\n    ]\n    for directory in directories:\n        try:\n            Path(directory).mkdir(parents=True, exist_ok=True)\n            typer.echo(f\"Created directory {directory}\")\n        except Exception as e:\n            typer.echo(f\"Failed to create directory {directory}: {e}\")\n            raise typer.Exit(code=1)\n\ndef create_basic_files(name: str):\n    \"\"\"\n    Creates basic files necessary for the project to run.\n    \"\"\"\n    files = {\n        f\"{name}/main.py\": '\"\"\"\\nMain application entry point.\\n\"\"\"\\n',\n        f\"{name}/app/__init__.py\": '\"\"\"\\nPackage initializer.\\n\"\"\"\\n',\n        f\"{name}/config.py\": '\"\"\"\\nConfiguration settings.\\n\"\"\"\\n',\n    }\n    for file_path, content in files.items():\n        try:\n            with open(file_path, \"w\") as file:\n                file.write(content)\n                typer.echo(f\"Created file {file_path}\")\n        except Exception as e:\n            typer.echo(f\"Failed to create file {file_path}: {e}\")\n            raise typer.Exit(code=1)\n\n@app.command()\ndef create_project(name: str):\n    \"\"\"\n    Creates a new project with a given name.\n    \"\"\"\n    typer.echo(f\"Creating project: {name}\")\n    create_directory_structure(name)\n    create_basic_files(name)\n    typer.echo(\"Project created successfully.\")\n\n@app.command()\ndef add_plugin(name: str):\n    \"\"\"\n    Adds a new plugin to the project.\n    \"\"\"\n    plugin_directory = Path(\"app/plugins\")\n    plugin_directory.mkdir(parents=True, exist_ok=True)  # Ensure the plugin directory exists\n    plugin_path = plugin_directory / f\"{name}.py\"\n    if plugin_path.exists():\n        typer.echo(f\"Plugin {name} already exists.\")\n        raise typer.Exit(code=1)\n    \n    try:\n        with open(plugin_path, \"w\") as file:\n            file.write(\n                f'\"\"\"\\nPlugin: {name}\\n\"\"\"\\n'\n                'from fastapi import FastAPI\\n\\n'\n                'def register(app: FastAPI):\\n'\n                '    \"\"\"Registers the plugin with the FastAPI application.\"\"\"\\n'\n                '    pass\\n'\n            )\n            typer.echo(f\"Plugin {name} added successfully.\")\n    except Exception as e:\n        typer.echo(f\"Failed to add plugin {name}: {e}\")\n        raise typer.Exit(code=1)\n\nif __name__ == \"__main__\":\n    app()\n\n## app/models.py\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\n\nBase = declarative_base()\n\nclass Models(Base):\n    __abstract__ = True\n    id = Column(Integer, primary_key=True, index=True)\n\nclass User(Models):\n    __tablename__ = \"users\"\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n    is_active = Column(Boolean, default=True)\n    items = relationship(\"Item\", order_by=\"Item.id\", back_populates=\"owner\")\n\nclass Item(Models):\n    __tablename__ = \"items\"\n    title = Column(String, index=True)\n    description = Column(String, index=True)\n    owner_id = Column(Integer, ForeignKey(\"users.id\"))\n    owner = relationship(\"User\", back_populates=\"items\")\n    created_at = Column(DateTime, default=func.now())\n\n## app/routes.py\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom typing import List\nfrom passlib.context import CryptContext\n\nfrom .dependencies import get_db\nfrom .models import User, Item  # Assuming these are the only models needed for CRUD operations\nfrom .schemas import UserCreate, UserRead, ItemCreate, ItemRead  # Assuming these schemas exist for serialization\n\nrouter = APIRouter()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# User Routes\n@router.post(\"/users/\", response_model=UserRead)\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.email == user.email).first()\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    hashed_password = pwd_context.hash(user.password)\n    new_user = User(**user.dict(exclude={\"password\"}), hashed_password=hashed_password)\n    try:\n        db.add(new_user)\n        db.commit()\n        db.refresh(new_user)\n    except SQLAlchemyError:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to create user\")\n    return new_user\n\n@router.get(\"/users/\", response_model=List[UserRead])\ndef read_users(skip: int = 0, limit: int = 10, db: Session = Depends(get_db)):\n    try:\n        users = db.query(User).offset(skip).limit(limit).all()\n    except SQLAlchemyError:\n        raise HTTPException(status_code=500, detail=\"Failed to fetch users\")\n    return users\n\n@router.get(\"/users/{user_id}\", response_model=UserRead)\ndef read_user(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n# Item Routes\n@router.post(\"/items/\", response_model=ItemRead)\ndef create_item(item: ItemCreate, db: Session = Depends(get_db)):\n    db_item = Item(**item.dict())\n    try:\n        db.add(db_item)\n        db.commit()\n        db.refresh(db_item)\n    except SQLAlchemyError:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to create item\")\n    return db_item\n\n@router.get(\"/items/\", response_model=List[ItemRead])\ndef read_items(skip: int = 0, limit: int = 10, db: Session = Depends(get_db)):\n    try:\n        items = db.query(Item).offset(skip).limit(limit).all()\n    except SQLAlchemyError:\n        raise HTTPException(status_code=500, detail=\"Failed to fetch items\")\n    return items\n\n@router.get(\"/items/{item_id}\", response_model=ItemRead)\ndef read_item(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Item).filter(Item.id == item_id).first()\n    if item is None:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item\n\n# Update and Delete operations with improved validation and error handling\n@router.put(\"/users/{user_id}\", response_model=UserRead)\ndef update_user(user_id: int, user: UserCreate, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.id == user_id).first()\n    if not db_user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    user_data = user.dict(exclude_unset=True)\n    if \"password\" in user_data:\n        user_data[\"hashed_password\"] = pwd_context.hash(user_data.pop(\"password\"))\n    for key, value in user_data.items():\n        setattr(db_user, key, value)\n    try:\n        db.commit()\n        db.refresh(db_user)\n    except SQLAlchemyError:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to update user\")\n    return db_user\n\n@router.delete(\"/users/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_user(user_id: int, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.id == user_id).first()\n    if not db_user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    try:\n        db.delete(db_user)\n        db.commit()\n    except SQLAlchemyError:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to delete user\")\n    return {\"ok\": True}\n\n@router.put(\"/items/{item_id}\", response_model=ItemRead)\ndef update_item(item_id: int, item: ItemCreate, db: Session = Depends(get_db)):\n    db_item = db.query(Item).filter(Item.id == item_id).first()\n    if not db_item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    item_data = item.dict(exclude_unset=True)\n    for key, value in item_data.items():\n        setattr(db_item, key, value)\n    try:\n        db.commit()\n        db.refresh(db_item)\n    except SQLAlchemyError:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to update item\")\n    return db_item\n\n@router.delete(\"/items/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_item(item_id: int, db: Session = Depends(get_db)):\n    db_item = db.query(Item).filter(Item.id == item_id).first()\n    if not db_item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    try:\n        db.delete(db_item)\n        db.commit()\n    except SQLAlchemyError:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=\"Failed to delete item\")\n    return {\"ok\": True}\n\n## app/dependencies.py\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom sqlalchemy.orm import Session\nfrom .models import User\nfrom .config import settings\nfrom .database import SessionLocal\nfrom .schemas import TokenData  # Import TokenData model\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef get_db() -> Session:\n    \"\"\"\n    Dependency to get a database session.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)) -> User:\n    \"\"\"\n    Dependency to extract and verify the current user from the token.\n    \"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    user = db.query(User).filter(User.username == token_data.username).first()\n    if user is None:\n        raise credentials_exception\n    return user\n\n## app/__init__.py\nfrom fastapi import FastAPI\nfrom .core import Core\nfrom .routes import Routes\nfrom .dependencies import get_db, get_current_user\n\ndef create_app() -> FastAPI:\n    \"\"\"\n    Initialize the FastAPI application, register routes and plugins, and setup dependency injection.\n    Returns:\n        app (FastAPI): The FastAPI application instance.\n    \"\"\"\n    app = FastAPI(title=\"PyNest Application\", version=\"1.0.0\")\n    \n    # Initialize Core and Routes\n    core = Core()\n    routes = Routes()\n\n    # Register routes and plugins\n    core.register_routes(app, routes)\n    core.register_plugins(app)\n\n    # Setup dependency injection for shared resources\n    app.dependency_overrides[get_db] = get_db\n    app.dependency_overrides[get_current_user] = get_current_user\n\n    return app\n\n## app/core.py\nfrom fastapi import FastAPI\nfrom typing import Callable, List, Type\nimport importlib\nimport pkgutil\nimport os\nfrom .routes import Routes\n\nclass PluginInterface:\n    \"\"\"\n    A base interface for plugins. All plugins must implement this interface.\n    \"\"\"\n    @staticmethod\n    def register(app: FastAPI):\n        \"\"\"\n        Register the plugin with the FastAPI application.\n\n        Args:\n            app (FastAPI): The FastAPI application instance.\n        \"\"\"\n        raise NotImplementedError(\"Plugin must implement the register method.\")\n\nclass Core:\n    \"\"\"\n    Core class responsible for registering routes and plugins to the FastAPI application.\n    \"\"\"\n\n    def register_routes(self, app: FastAPI, routes: Routes) -> None:\n        \"\"\"\n        Registers routes to the FastAPI application.\n\n        Args:\n            app (FastAPI): The FastAPI application instance.\n            routes (Routes): The Routes instance containing route definitions.\n        \"\"\"\n        app.include_router(routes.router)\n\n    def register_plugins(self, app: FastAPI, plugins_path: str = \"app/plugins\") -> None:\n        \"\"\"\n        Dynamically discovers and registers plugins to the FastAPI application.\n\n        Args:\n            app (FastAPI): The FastAPI application instance.\n            plugins_path (str): The path to the directory containing plugin modules.\n        \"\"\"\n        discovered_plugins = self._discover_plugins(plugins_path)\n        for plugin in discovered_plugins:\n            try:\n                plugin.register(app)\n            except NotImplementedError as e:\n                print(f\"Error: {plugin.__name__} does not implement the register method. {e}\")\n\n    def _discover_plugins(self, plugins_path: str) -> List[Type[PluginInterface]]:\n        \"\"\"\n        Discovers plugin modules in the specified directory and imports them.\n\n        Args:\n            plugins_path (str): The path to the directory containing plugin modules.\n\n        Returns:\n            List[Type[PluginInterface]]: A list of discovered plugin classes.\n        \"\"\"\n        if not os.path.exists(plugins_path) or not os.path.isdir(plugins_path):\n            print(f\"Warning: The plugin directory {plugins_path} does not exist or is not a directory.\")\n            return []\n\n        plugins = []\n        for _, name, _ in pkgutil.iter_modules([plugins_path]):\n            module = importlib.import_module(f\"{plugins_path}.{name}\")\n            for attribute_name in dir(module):\n                attribute = getattr(module, attribute_name)\n                if isinstance(attribute, type) and issubclass(attribute, PluginInterface) and attribute is not PluginInterface:\n                    plugins.append(attribute)\n        return plugins\n\n",
        "design": {
            "0": {
                "relative_path": "nest/core/pynest_app_context.py",
                "fqn_list": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
                "class": "nest/core/pynest_app_context.py.PyNestApplicationContext",
                "signature": "def is_initialized(self):"
            },
            "1": {
                "relative_path": "nest/core/pynest_app_context.py",
                "fqn_list": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
                "class": "nest/core/pynest_app_context.py.PyNestApplicationContext",
                "signature": "def is_initialized(self, value: bool):"
            },
            "2": {
                "relative_path": "nest/core/pynest_app_context.py",
                "fqn_list": "nest/core/pynest_app_context.py/PyNestApplicationContext/init",
                "class": "nest/core/pynest_app_context.py.PyNestApplicationContext",
                "signature": "def init(self):"
            },
            "3": {
                "relative_path": "nest/core/pynest_app_context.py",
                "fqn_list": "nest/core/pynest_app_context.py/PyNestApplicationContext/__init__",
                "class": "nest/core/pynest_app_context.py.PyNestApplicationContext",
                "signature": "def __init__(self, container: PyNestContainer, context_module: Union[Module, None] = None):"
            },
            "4": {
                "relative_path": "nest/core/pynest_app_context.py",
                "fqn_list": "nest/core/pynest_app_context.py/PyNestApplicationContext/select_context_module",
                "class": "nest/core/pynest_app_context.py.PyNestApplicationContext",
                "signature": "def select_context_module(self):"
            },
            "5": {
                "relative_path": "nest/core/pynest_app_context.py",
                "fqn_list": "nest/core/pynest_app_context.py/PyNestApplicationContext/select",
                "class": "nest/core/pynest_app_context.py.PyNestApplicationContext",
                "signature": "def select(self, module: T) -> T:"
            },
            "6": {
                "relative_path": "nest/core/pynest_factory.py",
                "fqn_list": "nest/core/pynest_factory.py/PyNestFactory/create",
                "class": "nest/core/pynest_factory.py.PyNestFactory",
                "signature": "def create(main_module: Type[ModuleType], **kwargs) -> PyNestApp:"
            },
            "7": {
                "relative_path": "nest/core/pynest_factory.py",
                "fqn_list": "nest/core/pynest_factory.py/PyNestFactory/_create_server",
                "class": "nest/core/pynest_factory.py.PyNestFactory",
                "signature": "def _create_server(**kwargs) -> FastAPI:"
            },
            "8": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/__new__",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def __new__(cls):"
            },
            "9": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/__init__",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def __init__(self):"
            },
            "10": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/modules",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def modules(self):"
            },
            "11": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/module_token_factory",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def module_token_factory(self):"
            },
            "12": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/modules_metadata",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def modules_metadata(self):"
            },
            "13": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/module_compiler",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def module_compiler(self):"
            },
            "14": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/get_instance",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def get_instance(self, dependency: TProvider, provider: Optional[Union[TProvider, TController]] = None):"
            },
            "15": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_module",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_module(self, metaclass) -> dict:"
            },
            "16": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/register_module",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def register_module(self, module_factory: ModuleFactory) -> Module:"
            },
            "17": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_metadata",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_metadata(self, token: str, module_metadata) -> None:"
            },
            "18": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_import",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_import(self, token: str):"
            },
            "19": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_modules",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_modules(self, modules: List[Any]) -> None:"
            },
            "20": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_providers",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_providers(self, providers: List[Any], module_token: str) -> None:"
            },
            "21": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_provider",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_provider(self, token: str, provider):"
            },
            "22": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/_get_providers",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def _get_providers(self, token: str) -> List[Any]:"
            },
            "23": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_controllers",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_controllers(self, controllers: List[Any], module_token: str) -> None:"
            },
            "24": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/_add_controller",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def _add_controller(self, token: str, controller: TController) -> None:"
            },
            "25": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/_get_controllers",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def _get_controllers(self, token: str) -> List[Any]:"
            },
            "26": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/clear",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def clear(self):"
            },
            "27": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/add_related_module",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def add_related_module(self, related_module, token: str) -> None:"
            },
            "28": {
                "relative_path": "nest/core/pynest_container.py",
                "fqn_list": "nest/core/pynest_container.py/PyNestContainer/get_module_by_key",
                "class": "nest/core/pynest_container.py.PyNestContainer",
                "signature": "def get_module_by_key(self, module_key: str) -> Module:"
            },
            "29": {
                "relative_path": "nest/core/pynest_application.py",
                "fqn_list": "nest/core/pynest_application.py/PyNestApp/is_listening",
                "class": "nest/core/pynest_application.py.PyNestApp",
                "signature": "def is_listening(self) -> bool:"
            },
            "30": {
                "relative_path": "nest/core/pynest_application.py",
                "fqn_list": "nest/core/pynest_application.py/PyNestApp/__init__",
                "class": "nest/core/pynest_application.py.PyNestApp",
                "signature": "def __init__(self, container: PyNestContainer, http_server: FastAPI):"
            },
            "31": {
                "relative_path": "nest/core/pynest_application.py",
                "fqn_list": "nest/core/pynest_application.py/PyNestApp/use",
                "class": "nest/core/pynest_application.py.PyNestApp",
                "signature": "def use(self, middleware: type, **options) -> \"PyNestApp\":"
            },
            "32": {
                "relative_path": "nest/core/pynest_application.py",
                "fqn_list": "nest/core/pynest_application.py/PyNestApp/get_server",
                "class": "nest/core/pynest_application.py.PyNestApp",
                "signature": "def get_server(self) -> FastAPI:"
            },
            "33": {
                "relative_path": "nest/core/pynest_application.py",
                "fqn_list": "nest/core/pynest_application.py/PyNestApp/register_routes",
                "class": "nest/core/pynest_application.py.PyNestApp",
                "signature": "def register_routes(self):"
            },
            "34": {
                "relative_path": "nest/core/decorators/injectable.py",
                "fqn_list": "nest/core/decorators/injectable.py/Injectable",
                "class": null,
                "signature": "def Injectable(target_class: Optional[Type] = None, *args, **kwargs) -> Callable:"
            },
            "35": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/Controller",
                "class": null,
                "signature": "def Controller(prefix: Optional[str] = None, tag: Optional[str] = None):"
            },
            "36": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/process_prefix",
                "class": null,
                "signature": "def process_prefix(route_prefix: Optional[str], tag_name: Optional[str]) -> str:"
            },
            "37": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/process_dependencies",
                "class": null,
                "signature": "def process_dependencies(cls: Type) -> None:"
            },
            "38": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/set_instance_variables",
                "class": null,
                "signature": "def set_instance_variables(cls: Type) -> None:"
            },
            "39": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/ensure_init_method",
                "class": null,
                "signature": "def ensure_init_method(cls: Type) -> None:"
            },
            "40": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/add_routes",
                "class": null,
                "signature": "def add_routes(cls: Type, router: APIRouter, route_prefix: str) -> None:"
            },
            "41": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/validate_method_decorator",
                "class": null,
                "signature": "def validate_method_decorator(method_function: callable, method_name: str) -> None:"
            },
            "42": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/configure_method_route",
                "class": null,
                "signature": "def configure_method_route(method_function: callable, route_prefix: str) -> None:"
            },
            "43": {
                "relative_path": "nest/core/decorators/controller.py",
                "fqn_list": "nest/core/decorators/controller.py/add_route_to_router",
                "class": null,
                "signature": "def add_route_to_router(router: APIRouter, method_function: callable) -> None:"
            },
            "44": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/route",
                "class": null,
                "signature": "def route(http_method: HTTPMethod, route_path: Union[str, List[str]] = \"/\", **kwargs):"
            },
            "45": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/Get",
                "class": null,
                "signature": "def Get(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:"
            },
            "46": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/Post",
                "class": null,
                "signature": "def Post(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:"
            },
            "47": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/Delete",
                "class": null,
                "signature": "def Delete(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:"
            },
            "48": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/Put",
                "class": null,
                "signature": "def Put(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:"
            },
            "49": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/Patch",
                "class": null,
                "signature": "def Patch(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:"
            },
            "50": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/Head",
                "class": null,
                "signature": "def Head(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:"
            },
            "51": {
                "relative_path": "nest/core/decorators/http_method.py",
                "fqn_list": "nest/core/decorators/http_method.py/Options",
                "class": null,
                "signature": "def Options(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:"
            },
            "52": {
                "relative_path": "nest/core/decorators/database.py",
                "fqn_list": "nest/core/decorators/database.py/db_request_handler",
                "class": null,
                "signature": "def db_request_handler(func):"
            },
            "53": {
                "relative_path": "nest/core/decorators/database.py",
                "fqn_list": "nest/core/decorators/database.py/async_db_request_handler",
                "class": null,
                "signature": "def async_db_request_handler(func):"
            },
            "54": {
                "relative_path": "nest/core/decorators/http_code.py",
                "fqn_list": "nest/core/decorators/http_code.py/HttpCode",
                "class": null,
                "signature": "def HttpCode(status_code: int):"
            },
            "55": {
                "relative_path": "nest/core/decorators/module.py",
                "fqn_list": "nest/core/decorators/module.py/Module/__init__",
                "class": "nest/core/decorators/module.py.Module",
                "signature": "def __init__(self, imports = None, controllers = None, providers = None, exports = None, is_global: bool = False):"
            },
            "56": {
                "relative_path": "nest/core/decorators/module.py",
                "fqn_list": "nest/core/decorators/module.py/Module/__call__",
                "class": "nest/core/decorators/module.py.Module",
                "signature": "def __call__(self, cls):"
            },
            "57": {
                "relative_path": "nest/core/decorators/utils.py",
                "fqn_list": "nest/core/decorators/utils.py/get_instance_variables",
                "class": null,
                "signature": "def get_instance_variables(cls):"
            },
            "58": {
                "relative_path": "nest/core/decorators/utils.py",
                "fqn_list": "nest/core/decorators/utils.py/get_non_dependencies_params",
                "class": null,
                "signature": "def get_non_dependencies_params(cls):"
            },
            "59": {
                "relative_path": "nest/core/decorators/utils.py",
                "fqn_list": "nest/core/decorators/utils.py/parse_dependencies",
                "class": null,
                "signature": "def parse_dependencies(cls):"
            },
            "60": {
                "relative_path": "nest/core/decorators/class_based_view.py",
                "fqn_list": "nest/core/decorators/class_based_view.py/class_based_view",
                "class": null,
                "signature": "def class_based_view(router: APIRouter, cls: Type[T]) -> Type[T]:"
            },
            "61": {
                "relative_path": "nest/core/decorators/class_based_view.py",
                "fqn_list": "nest/core/decorators/class_based_view.py/_init_cbv",
                "class": null,
                "signature": "def _init_cbv(cls: Type[Any]) -> None:"
            },
            "62": {
                "relative_path": "nest/core/decorators/class_based_view.py",
                "fqn_list": "nest/core/decorators/class_based_view.py/_update_cbv_route_endpoint_signature",
                "class": null,
                "signature": "def _update_cbv_route_endpoint_signature(cls: Type[Any], route: Union[Route, WebSocketRoute]) -> None:"
            },
            "63": {
                "relative_path": "nest/core/database/base_config.py",
                "fqn_list": "nest/core/database/base_config.py/ConfigFactoryBase/__init__",
                "class": "nest/core/database/base_config.py.ConfigFactoryBase",
                "signature": "def __init__(self, db_type: str):"
            },
            "64": {
                "relative_path": "nest/core/database/base_config.py",
                "fqn_list": "nest/core/database/base_config.py/ConfigFactoryBase/get_config",
                "class": "nest/core/database/base_config.py.ConfigFactoryBase",
                "signature": "def get_config(self):"
            },
            "65": {
                "relative_path": "nest/core/database/base_config.py",
                "fqn_list": "nest/core/database/base_config.py/BaseConfig/get_engine_url",
                "class": "nest/core/database/base_config.py.BaseConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "66": {
                "relative_path": "nest/core/database/base_config.py",
                "fqn_list": "nest/core/database/base_config.py/BaseProvider/__init__",
                "class": "nest/core/database/base_config.py.BaseProvider",
                "signature": "def __init__(self, host: str, db_name: str, user: str, password: str, port: int):"
            },
            "67": {
                "relative_path": "nest/core/database/base_config.py",
                "fqn_list": "nest/core/database/base_config.py/BaseProvider/get_engine_url",
                "class": "nest/core/database/base_config.py.BaseProvider",
                "signature": "def get_engine_url(self) -> str:"
            },
            "68": {
                "relative_path": "nest/core/database/odm_provider.py",
                "fqn_list": "nest/core/database/odm_provider.py/OdmProvider/__init__",
                "class": "nest/core/database/odm_provider.py.OdmProvider",
                "signature": "def __init__(self, db_type = \"mongodb\", config_params: dict = None, document_models: List[Document] = None):"
            },
            "69": {
                "relative_path": "nest/core/database/odm_provider.py",
                "fqn_list": "nest/core/database/odm_provider.py/OdmProvider/check_document_models",
                "class": "nest/core/database/odm_provider.py.OdmProvider",
                "signature": "def check_document_models(self):"
            },
            "70": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/BaseOrmProvider/__init__",
                "class": "nest/core/database/orm_provider.py.BaseOrmProvider",
                "signature": "def __init__(self, db_type: str = \"postgresql\", config_params: dict = None, async_mode: bool = False, **kwargs):"
            },
            "71": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/BaseOrmProvider/create_all",
                "class": "nest/core/database/orm_provider.py.BaseOrmProvider",
                "signature": "def create_all(self):"
            },
            "72": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/BaseOrmProvider/drop_all",
                "class": "nest/core/database/orm_provider.py.BaseOrmProvider",
                "signature": "def drop_all(self):"
            },
            "73": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/BaseOrmProvider/get_db",
                "class": "nest/core/database/orm_provider.py.BaseOrmProvider",
                "signature": "def get_db(self):"
            },
            "74": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/OrmProvider/__init__",
                "class": "nest/core/database/orm_provider.py.OrmProvider",
                "signature": "def __init__(self, db_type: str = \"postgresql\", config_params: dict = None):"
            },
            "75": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/OrmProvider/create_all",
                "class": "nest/core/database/orm_provider.py.OrmProvider",
                "signature": "def create_all(self):"
            },
            "76": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/OrmProvider/drop_all",
                "class": "nest/core/database/orm_provider.py.OrmProvider",
                "signature": "def drop_all(self):"
            },
            "77": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/OrmProvider/get_db",
                "class": "nest/core/database/orm_provider.py.OrmProvider",
                "signature": "def get_db(self) -> Session:"
            },
            "78": {
                "relative_path": "nest/core/database/orm_provider.py",
                "fqn_list": "nest/core/database/orm_provider.py/AsyncOrmProvider/__init__",
                "class": "nest/core/database/orm_provider.py.AsyncOrmProvider",
                "signature": "def __init__(self, db_type: str = \"postgresql\", config_params: dict = None, **kwargs):"
            },
            "79": {
                "relative_path": "nest/core/database/odm_config.py",
                "fqn_list": "nest/core/database/odm_config.py/MongoDBConfig/__init__",
                "class": "nest/core/database/odm_config.py.MongoDBConfig",
                "signature": "def __init__(self, host: str, db_name: str, user: str = None, password: str = None, port: int = 27017, srv: bool = False):"
            },
            "80": {
                "relative_path": "nest/core/database/odm_config.py",
                "fqn_list": "nest/core/database/odm_config.py/MongoDBConfig/get_engine_url",
                "class": "nest/core/database/odm_config.py.MongoDBConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "81": {
                "relative_path": "nest/core/database/odm_config.py",
                "fqn_list": "nest/core/database/odm_config.py/ConfigFactory/__init__",
                "class": "nest/core/database/odm_config.py.ConfigFactory",
                "signature": "def __init__(self, db_type: str):"
            },
            "82": {
                "relative_path": "nest/core/database/odm_config.py",
                "fqn_list": "nest/core/database/odm_config.py/ConfigFactory/get_config",
                "class": "nest/core/database/odm_config.py.ConfigFactory",
                "signature": "def get_config(self):"
            },
            "83": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/PostgresConfig/__init__",
                "class": "nest/core/database/orm_config.py.PostgresConfig",
                "signature": "def __init__(self, host: str, db_name: str, user: str, password: str, port: int):"
            },
            "84": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/PostgresConfig/get_engine_url",
                "class": "nest/core/database/orm_config.py.PostgresConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "85": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/MySQLConfig/__init__",
                "class": "nest/core/database/orm_config.py.MySQLConfig",
                "signature": "def __init__(self, host: str, db_name: str, user: str, password: str, port: int):"
            },
            "86": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/MySQLConfig/get_engine_url",
                "class": "nest/core/database/orm_config.py.MySQLConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "87": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/SQLiteConfig/__init__",
                "class": "nest/core/database/orm_config.py.SQLiteConfig",
                "signature": "def __init__(self, db_name: str):"
            },
            "88": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/SQLiteConfig/get_engine_url",
                "class": "nest/core/database/orm_config.py.SQLiteConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "89": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncSQLiteConfig/__init__",
                "class": "nest/core/database/orm_config.py.AsyncSQLiteConfig",
                "signature": "def __init__(self, db_name: str):"
            },
            "90": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncSQLiteConfig/get_engine_url",
                "class": "nest/core/database/orm_config.py.AsyncSQLiteConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "91": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncPostgresConfig/__init__",
                "class": "nest/core/database/orm_config.py.AsyncPostgresConfig",
                "signature": "def __init__(self, host: str, db_name: str, user: str, password: str, port: int):"
            },
            "92": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncPostgresConfig/get_engine_url",
                "class": "nest/core/database/orm_config.py.AsyncPostgresConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "93": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncMySQLConfig/__init__",
                "class": "nest/core/database/orm_config.py.AsyncMySQLConfig",
                "signature": "def __init__(self, host: str, db_name: str, user: str, password: str, port: int):"
            },
            "94": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncMySQLConfig/get_engine_url",
                "class": "nest/core/database/orm_config.py.AsyncMySQLConfig",
                "signature": "def get_engine_url(self) -> str:"
            },
            "95": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/ConfigFactory/__init__",
                "class": "nest/core/database/orm_config.py.ConfigFactory",
                "signature": "def __init__(self, db_type: str):"
            },
            "96": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/ConfigFactory/get_config",
                "class": "nest/core/database/orm_config.py.ConfigFactory",
                "signature": "def get_config(self):"
            },
            "97": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncConfigFactory/__init__",
                "class": "nest/core/database/orm_config.py.AsyncConfigFactory",
                "signature": "def __init__(self, db_type: str):"
            },
            "98": {
                "relative_path": "nest/core/database/orm_config.py",
                "fqn_list": "nest/core/database/orm_config.py/AsyncConfigFactory/get_config",
                "class": "nest/core/database/orm_config.py.AsyncConfigFactory",
                "signature": "def get_config(self):"
            }
        }
    }
}