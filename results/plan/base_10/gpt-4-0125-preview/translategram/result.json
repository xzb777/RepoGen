{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "translategram/translategram/translator_services.py/MtranslateTranslatorService/__init__",
            "imports": [
                "from mtranslate import translate"
            ],
            "code": "class MtranslateTranslatorService:\n    def __init__(self) -> None:\n        self.service = translate\n\n    def translate(self, text: str, to_language: str, from_language: str = 'auto') -> str:\n        translated_text = self.service(text, to_language, from_language)\n        return translated_text"
        },
        {
            "key_id": 1,
            "fqn": "translategram/translategram/cache.py/PickleCache/__init__",
            "imports": [
                "import pickle",
                "from pathlib import Path"
            ],
            "code": "class PickleCache:\n    def __init__(self, obj: object, filename: str = 'translation.data') -> None:\n        self.obj = obj\n        self.filename = filename\n        self._load_cache()\n\n    def _load_cache(self):\n        if Path(self.filename).exists():\n            with open(self.filename, 'rb') as file:\n                self.obj = pickle.load(file)\n\n    def __del__(self):\n        with open(self.filename, 'wb') as file:\n            pickle.dump(self.obj, file)"
        },
        {
            "key_id": 3,
            "fqn": "translategram/translategram/translator.py/Translator/__init__",
            "imports": [
                "from typing import Type, Union",
                "from .translator_services import MtranslateTranslatorService",
                "from .cache import PickleCache"
            ],
            "code": "class Translator:\n    def __init__(self, translator_service: Type[MtranslateTranslatorService], cache_system: Union[Type[PickleCache], None] = None) -> None:\n        self.translator_service = translator_service()\n        self.cache_system = cache_system() if cache_system else None"
        },
        {
            "key_id": 6,
            "fqn": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/__init__",
            "imports": [
                "from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters",
                "from telegram import Update",
                "from asyncio import run",
                "from translategram.translategram.translator import Translator",
                "from translategram.translategram.translator_services import MtranslateTranslatorService",
                "from translategram.translategram.cache import PickleCache"
            ],
            "code": "class PythonTelegramBotAdapter:\n    def __init__(self, translator_service: Type[MtranslateTranslatorService], cache_system: Union[Type[PickleCache], None] = None) -> None:\n        self._translator_service = Translator(translator_service, cache_system)\n\n    async def handler_translator(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message: str, source_lang: str = 'auto') -> None:\n        user_lang = update.effective_user.language_code if update.effective_user else 'en'\n        msg = ''\n        if self._translator_service.cache_system:\n            msg = await self._translator_service.cache_system.retrieve(func.__name__ + '_' + user_lang) if self._translator_service.cache_system else ''\n        if not msg:\n            msg = self._translator_service.translator_service.translate(message, user_lang, source_lang)\n        await context.bot.send_message(chat_id=update.effective_chat.id, text=msg)"
        },
        {
            "key_id": 2,
            "fqn": "translategram/translategram/cache.py/PickleCache/__del__",
            "imports": [
                "import pickle",
                "from pathlib import Path"
            ],
            "code": "class PickleCache:\n    def __init__(self, obj: object, filename: str = 'translation.data') -> None:\n        self.obj = obj\n        self.filename = filename\n        self._load_cache()\n\n    def _load_cache(self):\n        if Path(self.filename).exists():\n            with open(self.filename, 'rb') as file:\n                self.obj = pickle.load(file)\n\n    def __del__(self):\n        with open(self.filename, 'wb') as file:\n            pickle.dump(self.obj, file)"
        },
        {
            "key_id": 4,
            "fqn": "translategram/translategram/translator.py/Translator/handler_translator",
            "imports": [
                "from typing import Callable, Coroutine, Any, Type",
                "from translategram.translategram.translator_services import MtranslateTranslatorService",
                "from translategram.translategram.cache import PickleCache"
            ],
            "code": "class Translator:\n    def __init__(self, translator_service: Type[MtranslateTranslatorService], cache_system: Union[Type[PickleCache], None] = None) -> None:\n        self.translator_service = translator_service()\n        self.cache_system = cache_system() if cache_system else None\n\n    def handler_translator(self, message: str, source_lang: str) -> Callable[[Callable[..., object]], Callable[[Any, Any, str], Coroutine[Any, Any, Any]]]:\n        async def wrapper(update: Any, context: Any, message: str) -> None:\n            if self.cache_system:\n                translated_message = self.cache_system.get(message)\n                if not translated_message:\n                    translated_message = self.translator_service.translate(message, source_lang)\n                    self.cache_system.set(message, translated_message)\n            else:\n                translated_message = self.translator_service.translate(message, source_lang)\n            await context.bot.send_message(chat_id=update.effective_chat.id, text=translated_message)\n        return wrapper"
        },
        {
            "key_id": 5,
            "fqn": "translategram/translategram/translator.py/Translator/dynamic_handler_translator",
            "imports": [
                "from typing import Callable, Coroutine, Any, Type",
                "from translategram.translategram.translator_services import MtranslateTranslatorService",
                "from translategram.translategram.cache import PickleCache"
            ],
            "code": "class Translator:\n    def __init__(self, translator_service: Type[MtranslateTranslatorService], cache_system: Union[Type[PickleCache], None] = None) -> None:\n        self.translator_service = translator_service()\n        self.cache_system = cache_system() if cache_system else None\n\n    def dynamic_handler_translator(self, message_func: Callable[[str, Any], str], source_lang: str = 'auto') -> Callable[[Callable[..., object]], Callable[[Any, Any], Coroutine[Any, Any, Any]]]:\n        async def wrapper(update: Any, context: Any) -> None:\n            original_message = message_func(update, context)\n            if self.cache_system:\n                translated_message = self.cache_system.get(original_message)\n                if not translated_message:\n                    translated_message = self.translator_service.translate(original_message, source_lang)\n                    self.cache_system.set(original_message, translated_message)\n            else:\n                translated_message = self.translator_service.translate(original_message, source_lang)\n            await context.bot.send_message(chat_id=update.effective_chat.id, text=translated_message)\n        return wrapper"
        },
        {
            "key_id": 7,
            "fqn": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/handler_translator",
            "imports": [
                "from telegram import Update",
                "from telegram.ext import ContextTypes",
                "from typing import Callable, Coroutine, Any",
                "from translategram.translategram.translator import Translator",
                "from translategram.translategram.translator_services import MtranslateTranslatorService",
                "from translategram.translategram.cache import PickleCache"
            ],
            "code": "class PythonTelegramBotAdapter:\n    def __init__(self, translator_service: Type[MtranslateTranslatorService], cache_system: Union[Type[PickleCache], None] = None) -> None:\n        self._translator_service = Translator(translator_service, cache_system)\n\n    async def handler_translator(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message: str, source_lang: str = 'auto') -> None:\n        user_lang = update.effective_user.language_code if update.effective_user else 'en'\n        msg = ''\n        if self._translator_service.cache_system:\n            msg = await self._translator_service.cache_system.retrieve(func.__name__ + '_' + user_lang) if self._translator_service.cache_system else ''\n        if not msg:\n            msg = self._translator_service.translator_service.translate(message, user_lang, source_lang)\n        await context.bot.send_message(chat_id=update.effective_chat.id, text=msg)"
        },
        {
            "key_id": 8,
            "fqn": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/dynamic_handler_translator",
            "imports": [
                "from telegram import Update",
                "from telegram.ext import ContextTypes",
                "from typing import Callable, Coroutine, Any",
                "from translategram.translategram.translator import Translator",
                "from translategram.translategram.translator_services import MtranslateTranslatorService",
                "from translategram.translategram.cache import PickleCache"
            ],
            "code": "class PythonTelegramBotAdapter:\n    def __init__(self, translator_service: Type[MtranslateTranslatorService], cache_system: Union[Type[PickleCache], None] = None) -> None:\n        self._translator_service = Translator(translator_service, cache_system)\n\n    async def dynamic_handler_translator(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message_func: Callable[[str, Any], str], source_lang: str = 'auto') -> None:\n        original_message = message_func(update, context)\n        user_lang = update.effective_user.language_code if update.effective_user else 'en'\n        msg = ''\n        if self._translator_service.cache_system:\n            msg = await self._translator_service.cache_system.retrieve(func.__name__ + '_' + user_lang) if self._translator_service.cache_system else ''\n        if not msg:\n            msg = self._translator_service.translator_service.translate(original_message, user_lang, source_lang)\n        await context.bot.send_message(chat_id=update.effective_chat.id, text=msg)"
        }
    ]
}