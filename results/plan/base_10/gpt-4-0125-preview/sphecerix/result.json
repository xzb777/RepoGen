{
    "implementation": [
        {
            "key_id": 19,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/__init__",
            "imports": [],
            "code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.molecule = mol\n        self.operations = []"
        },
        {
            "key_id": 22,
            "fqn": "sphecerix/symmetry_operations.py/Operation/__init__",
            "imports": [],
            "code": "class Operation:\n    def __init__(self, name):\n        self.name = name\n        self.matrix = None\n        self.wigner_matrix = None"
        },
        {
            "key_id": 24,
            "fqn": "sphecerix/symmetry_operations.py/Identity/__init__",
            "imports": [],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n        self.wigner_matrix = lambda l: np.eye(2*l+1)"
        },
        {
            "key_id": 27,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = np.diag([-1, -1, -1])\n        self.wigner_matrix = lambda l: np.diag([-1 if i % 2 == 0 else 1 for i in range(2*l+1)])"
        },
        {
            "key_id": 30,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/__init__",
            "imports": [
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        self.matrix = R.from_rotvec(axis * angle).as_matrix()\n        self.wigner_matrix = lambda l: tesseral_wigner_D(l, R.from_rotvec(axis * angle))"
        },
        {
            "key_id": 33,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Mirror(Operation):\n    def __init__(self, label, normal):\n        super().__init__(label)\n        n = np.array(normal)\n        n /= np.linalg.norm(n)\n        self.matrix = np.eye(3) - 2 * np.outer(n, n)\n        self.wigner_matrix = lambda l: tesseral_wigner_D_mirror(l, n)"
        },
        {
            "key_id": 36,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/__init__",
            "imports": [
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "class ImproperRotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        rot_matrix = R.from_rotvec(axis * angle).as_matrix()\n        self.matrix = np.diag([-1, -1, -1]) @ rot_matrix\n        self.wigner_matrix = lambda l: tesseral_wigner_D_improper(l, R.from_rotvec(axis * angle))"
        },
        {
            "key_id": 3,
            "fqn": "sphecerix/molecule.py/Molecule/__init__",
            "imports": [],
            "code": "class Molecule:\n    def __init__(self, _name = 'unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []"
        },
        {
            "key_id": 40,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__init__",
            "imports": [],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.coefficients = []"
        },
        {
            "key_id": 7,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wffield(n, l, m, d, npts):\n    theta, phi = np.mgrid[0:np.pi:npts*1j, 0:2*np.pi:npts*1j]\n    r = np.abs(sph_harm(m, l, phi, theta))\n    x = r * np.sin(theta) * np.cos(phi)\n    y = r * np.sin(theta) * np.sin(phi)\n    z = r * np.cos(theta)\n    return x, y, z"
        },
        {
            "key_id": 8,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield_l",
            "imports": [
                "import numpy as np"
            ],
            "code": "def wffield_l(n, l, d, npts):\n    # This function is a placeholder for logic specific to spherical harmonics of a given l\n    # Assuming d represents some form of density or distribution parameter\n    density = np.linspace(0, d, npts)\n    # Placeholder logic for generating field based on n, l, and density\n    field = density * (l + n)  # Simplified example\n    return field"
        },
        {
            "key_id": 9,
            "fqn": "sphecerix/atomic_wave_functions.py/wfcart",
            "imports": [
                "import numpy as np"
            ],
            "code": "def wfcart(n, l, m, x, y, z):\n    # Convert Cartesian coordinates to spherical\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(np.sqrt(x**2 + y**2), z)\n    phi = np.arctan2(y, x)\n    # Placeholder for wave function calculation, assuming a simple form\n    psi = r**(l) * np.exp(-r/n) * np.cos(m * phi) * np.sin(theta)**l\n    return psi"
        },
        {
            "key_id": 10,
            "fqn": "sphecerix/atomic_wave_functions.py/wf",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wf(n, l, m, r, theta, phi):\n    # Example wave function using spherical harmonics\n    Ylm = sph_harm(m, l, phi, theta)\n    radial_part = np.exp(-r/n) * r**l\n    return radial_part * Ylm"
        },
        {
            "key_id": 11,
            "fqn": "sphecerix/atomic_wave_functions.py/angular",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def angular(l, m, theta, phi):\n    # Calculate and return the angular part of the wave function\n    return sph_harm(m, l, phi, theta)"
        },
        {
            "key_id": 12,
            "fqn": "sphecerix/atomic_wave_functions.py/radial",
            "imports": [
                "import numpy as np"
            ],
            "code": "def radial(n, l, r):\n    # Placeholder for a radial part of the wave function, simplified\n    return np.exp(-r/n) * r**l"
        },
        {
            "key_id": 13,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "def tesseral_wigner_D(l, Robj):\n    # Assuming Robj is a scipy Rotation object\n    # Placeholder for generating tesseral Wigner D matrix\n    # This is a simplified example\n    D = np.eye(2*l + 1)  # Identity matrix as placeholder\n    return D"
        },
        {
            "key_id": 14,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_mirror",
            "imports": [
                "import numpy as np"
            ],
            "code": "def tesseral_wigner_D_mirror(l, normal):\n    # Placeholder for tesseral Wigner D matrix for mirror operation\n    # Assuming 'normal' is the normal vector to the mirror plane\n    # This is a simplified example\n    D_mirror = np.eye(2*l + 1)  # Identity matrix as placeholder\n    return D_mirror"
        },
        {
            "key_id": 15,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_improper",
            "imports": [
                "import numpy as np"
            ],
            "code": "def tesseral_wigner_D_improper(l, Robj):\n    # Placeholder for tesseral Wigner D matrix for improper rotation\n    # Assuming Robj is a scipy Rotation object\n    # This is a simplified example\n    D_improper = np.eye(2*l + 1)  # Identity matrix as placeholder\n    return D_improper"
        },
        {
            "key_id": 16,
            "fqn": "sphecerix/wignerd.py/wigner_D",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "def wigner_D(l, Robj):\n    # Placeholder for generating the Wigner D matrix\n    # Assuming Robj is a scipy Rotation object\n    # This is a simplified example\n    D = np.eye(2*l + 1)  # Identity matrix as placeholder\n    return D"
        },
        {
            "key_id": 17,
            "fqn": "sphecerix/wignerd.py/wigner_d",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wigner_d(l, beta):\n    d_matrix = np.zeros((2*l+1, 2*l+1), dtype=complex)\n    for m in range(-l, l+1):\n        for mp in range(-l, l+1):\n            d_matrix[m+l, mp+l] = sph_harm(mp, l, beta, 0) * np.conj(sph_harm(m, l, 0, 0))\n    return d_matrix"
        },
        {
            "key_id": 18,
            "fqn": "sphecerix/wignerd.py/wigner_d_element_euler_angles",
            "imports": [
                "import numpy as np",
                "from scipy.linalg import expm",
                "from scipy.special import sph_harm"
            ],
            "code": "def wigner_d_element_euler_angles(l, m1, m2, beta):\n    alpha = np.deg2rad(90)  # Conversion to radians for consistency\n    gamma = np.deg2rad(-90)\n    d = wigner_d(l, beta)\n    # Euler rotation matrix\n    R = expm(np.array([[0, -alpha, 0], [alpha, 0, -gamma], [0, gamma, 0]]))\n    # Apply rotation\n    rotated_d = R @ d @ R.T\n    return rotated_d[m1+l, m2+l]"
        },
        {
            "key_id": 20,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/add",
            "imports": [
                "numpy as np"
            ],
            "code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.molecule = mol\n        self.operations = []\n\n    def add(self, name, label=None, vec=None, angle=None):\n        operation = {'name': name, 'label': label, 'vec': vec, 'angle': angle}\n        self.operations.append(operation)"
        },
        {
            "key_id": 21,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/run",
            "imports": [
                "numpy as np"
            ],
            "code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.molecule = mol\n        self.operations = []\n\n    def run(self):\n        for operation in self.operations:\n            print(f'Executing {operation['name']} with label {operation['label']}, vector {operation['vec']}, and angle {operation['angle']}')"
        },
        {
            "key_id": 23,
            "fqn": "sphecerix/symmetry_operations.py/Operation/set_atomic_id",
            "imports": [],
            "code": "class Operation:\n    def __init__(self, name):\n        self.name = name\n        self.matrix = None\n        self.wigner_matrix = None\n\n    def set_atomic_id(self, idx):\n        self.atomic_id = idx\n        print(f'Atomic ID for {self.name} operation set to {idx}')"
        },
        {
            "key_id": 25,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 26,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_wigner_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n\n    def get_wigner_matrix(self, l):\n        return np.eye(2*l+1)"
        },
        {
            "key_id": 28,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = np.diag([-1, -1, -1])\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 29,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_wigner_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = np.diag([-1, -1, -1])\n\n    def get_wigner_matrix(self, l):\n        return np.diag([-1 if i % 2 == 0 else 1 for i in range(2*l+1)])"
        },
        {
            "key_id": 31,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_matrix",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        rot_matrix = R.from_rotvec(axis * angle).as_matrix()\n        self.matrix = rot_matrix\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 32,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_wigner_matrix",
            "imports": [
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D_improper"
            ],
            "code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D_improper(l, R.from_rotvec(self.axis * self.angle))"
        },
        {
            "key_id": 34,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "def get_matrix(self):\n    n = np.array(self.normal)\n    n /= np.linalg.norm(n)\n    return np.eye(3) - 2 * np.outer(n, n)"
        },
        {
            "key_id": 35,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_wigner_matrix",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "def get_wigner_matrix(self, l):\n    n = np.array(self.normal)\n    n /= np.linalg.norm(n)\n    return tesseral_wigner_D_mirror(l, n)"
        },
        {
            "key_id": 37,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/get_matrix",
            "imports": [
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ],
            "code": "def get_matrix(self):\n    rot_matrix = R.from_rotvec(self.axis * self.angle).as_matrix()\n    return np.diag([-1, -1, -1]) @ rot_matrix"
        },
        {
            "key_id": 4,
            "fqn": "sphecerix/molecule.py/Molecule/__str__",
            "imports": [],
            "code": "def __str__(self):\n    atom_descriptions = [str(atom) for atom in self.atoms]\n    return f'Molecule: {self.name}, Atoms: {' '.join(atom_descriptions)}'"
        },
        {
            "key_id": 5,
            "fqn": "sphecerix/molecule.py/Molecule/add_atom",
            "imports": [],
            "code": "def add_atom(self, atom, x, y, z, unit='bohr'):\n    self.atoms.append({'atom': atom, 'x': x, 'y': y, 'z': z, 'unit': unit})"
        },
        {
            "key_id": 6,
            "fqn": "sphecerix/molecule.py/Molecule/build_basis",
            "imports": [
                "from sphecerix.atomic_wave_functions import wffield, wffield_l, wfcart, wf, angular, radial",
                "from sphecerix.basis_functions import BasisFunction"
            ],
            "code": "def build_basis(self, molset):\n    for atom in self.atoms:\n        for orbital in molset.get('orbitals', []):\n            bf = BasisFunction(orbital['n'], orbital['l'], orbital['m'])\n            self.basis_functions.append(bf)"
        },
        {
            "key_id": 38,
            "fqn": "sphecerix/tesseral.py/tesseral_transformation",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.tesseral import permutation_sh_car"
            ],
            "code": "def tesseral_transformation(l):\n    perm_matrix = permutation_sh_car()\n    wigner_matrix = tesseral_wigner_D(l, R.from_euler('z', np.pi/2))\n    return perm_matrix @ wigner_matrix @ np.linalg.inv(perm_matrix)"
        },
        {
            "key_id": 39,
            "fqn": "sphecerix/tesseral.py/permutation_sh_car",
            "imports": [
                "import numpy as np"
            ],
            "code": "def permutation_sh_car():\n    # This is a placeholder for the permutation matrix logic\n    # Replace this with the actual permutation logic based on spherical harmonics\n    return np.eye(5)  # Assuming a 5x5 identity matrix as a placeholder"
        },
        {
            "key_id": 41,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_name",
            "imports": [],
            "code": "def __get_name(self):\n    return f'{self.n}{self.l}{self.m}'"
        },
        {
            "key_id": 42,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_type",
            "imports": [],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.coefficients = []\n\n    def __get_type(self):\n        if self.l == 0:\n            return 's'\n        elif self.l == 1:\n            return 'p'\n        elif self.l == 2:\n            return 'd'\n        elif self.l == 3:\n            return 'f'\n        else:\n            return 'unknown'"
        },
        {
            "key_id": 0,
            "fqn": "sphecerix/matrixplot.py/visualize_matrices",
            "imports": [
                "import matplotlib.pyplot as plt"
            ],
            "code": "def visualize_matrices(symops, numcols = 3, highlight_groups = None, filename = None, figsize = (7,5), xlabelrot = 0):\n    fig, axs = plt.subplots(len(symops)//numcols + bool(len(symops)%numcols), numcols, figsize=figsize)\n    axs = axs.flatten()\n    for i, symop in enumerate(symops):\n        ax = axs[i]\n        ax.imshow(symop)\n        ax.set_title(f'SymOp {i+1}')\n    for ax in axs[len(symops):]:\n        ax.set_visible(False)\n    plt.tight_layout()\n    if filename:\n        plt.savefig(filename)\n    plt.show()"
        },
        {
            "key_id": 1,
            "fqn": "sphecerix/matrixplot.py/plot_highlight_groups",
            "imports": [
                "import matplotlib.pyplot as plt"
            ],
            "code": "def plot_highlight_groups(axh, groups, mat):\n    for group in groups:\n        axh.plot(group, mat[group], 'ro')\n    return axh"
        },
        {
            "key_id": 2,
            "fqn": "sphecerix/matrixplot.py/plot_matrix",
            "imports": [
                "import matplotlib.pyplot as plt"
            ],
            "code": "def plot_matrix(ax, mat, bfs, title = None, xlabelrot = 0):\n    cax = ax.matshow(mat, cmap='viridis')\n    if title:\n        ax.set_title(title)\n    ax.set_xticks(range(len(bfs)))\n    ax.set_xticklabels(bfs, rotation=xlabelrot)\n    ax.set_yticks(range(len(bfs)))\n    ax.set_yticklabels(bfs)\n    plt.colorbar(cax, ax=ax)"
        },
        {
            "key_id": 43,
            "fqn": "docs/conf.py/setup",
            "imports": [
                "from sphinx.ext.autodoc import between"
            ],
            "code": "def setup(app):\n    app.add_css_file('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css')\n    app.add_config_value('recommonmark_config', {\n            'auto_toc_tree_section': 'Contents',\n            }, True)\n    app.add_transform(AutoStructify)"
        },
        {
            "key_id": 44,
            "fqn": "examples/fz3_rotation.py/main",
            "imports": [
                "from sphecerix import tesseral_wigner_D",
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ],
            "code": "def main():\n    # build rotation axis and set angle\n    axis = np.ones(3) / np.sqrt(3)\n    angle = np.pi\n    Robj = R.from_rotvec(axis * angle)\n    \n    # construct tesseral Wigner D matrix\n    D = tesseral_wigner_D(2, Robj)\n    Y = np.zeros(5)\n    Y[2] = 1\n    \n    # calculate linear combination of the spherical harmonics after rotation\n    Yp = D @ Y\n    print(Yp)"
        },
        {
            "key_id": 45,
            "fqn": "examples/ethylene.py/main",
            "imports": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations"
            ],
            "code": "def main():\n    ethylene = Molecule('Ethylene')\n    ethylene.add_atom('C', 0, 0, 0)\n    ethylene.add_atom('C', 1.2, 0, 0)\n    ethylene.add_atom('H', -0.6, -1, 0)\n    ethylene.add_atom('H', -0.6, 1, 0)\n    ethylene.add_atom('H', 1.8, -1, 0)\n    ethylene.add_atom('H', 1.8, 1, 0)\n    symops = SymmetryOperations(ethylene)\n    symops.add('C2', vec=(0,0,1), angle=180)\n    symops.run()\n    print('Symmetry operations completed.')"
        },
        {
            "key_id": 46,
            "fqn": "examples/dz2_rotation.py/main",
            "imports": [
                "from sphecerix import tesseral_wigner_D",
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ],
            "code": "def main():\n    # build rotation axis and set angle\n    axis = np.ones(3) / np.sqrt(3)\n    angle = np.pi\n    Robj = R.from_rotvec(axis * angle)\n    \n    # construct tesseral Wigner D matrix\n    D = tesseral_wigner_D(2, Robj)\n    Y = np.zeros(5)\n    Y[2] = 1\n    \n    # calculate linear combination of the spherical harmonics after rotation\n    Yp = D @ Y\n    print(Yp)"
        },
        {
            "key_id": 47,
            "fqn": "examples/nh3.py/main",
            "imports": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations"
            ],
            "code": "def main():\n    ammonia = Molecule('Ammonia')\n    ammonia.add_atom('N', 0, 0, 0.2)\n    ammonia.add_atom('H', 0.93, 0, -0.3)\n    ammonia.add_atom('H', -0.47, 0.81, -0.3)\n    ammonia.add_atom('H', -0.47, -0.81, -0.3)\n    symops = SymmetryOperations(ammonia)\n    symops.add('C3', vec=(0,0,1), angle=120)\n    symops.run()\n    print('Symmetry operations completed.')"
        }
    ]
}