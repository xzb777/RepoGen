{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "santorinai/board.py/Board/__init__",
            "imports": [
                "from typing import List"
            ],
            "code": "class Board:\n    def __init__(self, number_of_players: int):\n        self.number_of_players = number_of_players\n        self.board = [[0 for _ in range(5)] for _ in range(5)]\n        self.pawns = []  # List to store Pawn objects\n        self.player_turn = 1\n        self.turn_number = 0\n        # Initialize board with empty values\n        for i in range(5):\n            for j in range(5):\n                self.board[i][j] = 0\n\n        # Additional initializations can be added here"
        },
        {
            "key_id": 25,
            "fqn": "santorinai/pawn.py/Pawn/__init__",
            "imports": [],
            "code": "class Pawn:\n    def __init__(self, number: int, order: int, player_number: int):\n        self.number = number\n        self.order = order\n        self.player_number = player_number\n        self.pos = (None, None)  # Initial position is undefined"
        },
        {
            "key_id": 21,
            "fqn": "santorinai/player.py/Player/__init__",
            "imports": [],
            "code": "class Player:\n    def __init__(self, player_number: int, log_level=0) -> None:\n        self.player_number = player_number\n        self.log_level = log_level\n        # Additional player setup can be added here"
        },
        {
            "key_id": 33,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/__init__",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class FirstChoicePlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n        # Additional FirstChoicePlayer setup can be added here"
        },
        {
            "key_id": 37,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/__init__",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n        # Additional RandomPlayer setup can be added here"
        },
        {
            "key_id": 41,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/__init__",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n        # Additional BasicPlayer setup can be added here"
        },
        {
            "key_id": 15,
            "fqn": "santorinai/board.py/Board/is_position_valid",
            "imports": [],
            "code": "def is_position_valid(self, pos: Tuple[int, int]) -> bool:\n        x, y = pos\n        return 0 <= x < 5 and 0 <= y < 5"
        },
        {
            "key_id": 2,
            "fqn": "santorinai/board.py/Board/is_position_within_board",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_position_within_board(self, position: Tuple[int, int]) -> bool:\n        return self.is_position_valid(position)"
        },
        {
            "key_id": 3,
            "fqn": "santorinai/board.py/Board/is_position_adjacent",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_position_adjacent(self, position1: Tuple[int, int], position2: Tuple[int, int]) -> bool:\n        return max(abs(position1[0] - position2[0]), abs(position1[1] - position2[1])) == 1"
        },
        {
            "key_id": 4,
            "fqn": "santorinai/board.py/Board/is_pawn_on_position",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_pawn_on_position(self, position: Tuple[int, int]) -> bool:\n        for pawn in self.pawns:\n            if pawn.pos == position:\n                return True\n        return False"
        },
        {
            "key_id": 1,
            "fqn": "santorinai/board.py/Board/is_move_possible",
            "imports": [
                "from typing import Tuple, List"
            ],
            "code": "def is_move_possible(self, start_pos: Tuple[int, int], end_pos: Tuple[int, int]) -> Tuple[bool, str]:\n        if not self.is_position_within_board(end_pos) or not self.is_position_adjacent(start_pos, end_pos) or self.is_pawn_on_position(end_pos):\n            return False, 'Move not possible'\n        return True, 'Move possible'"
        },
        {
            "key_id": 5,
            "fqn": "santorinai/board.py/Board/is_build_possible",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_build_possible(self, builder_position: Tuple[int, int], build_position: Tuple[int, int]) -> bool:\n        if not self.is_position_within_board(build_position) or not self.is_position_adjacent(builder_position, build_position) or self.is_pawn_on_position(build_position) or self.board[build_position[0]][build_position[1]] == 4:\n            return False\n        return True"
        },
        {
            "key_id": 13,
            "fqn": "santorinai/board.py/Board/place_pawn",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def place_pawn(self, position: Tuple[int, int]) -> Tuple[bool, str]:\n        if not self.is_position_valid(position) or self.is_pawn_on_position(position):\n            return False, 'Invalid position for pawn'\n        return True, 'Pawn placed'"
        },
        {
            "key_id": 14,
            "fqn": "santorinai/board.py/Board/play_move",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def play_move(self, pawn_number: int, move_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:\n        if not self.is_move_possible(self.pawns[pawn_number - 1].pos, move_position)[0] or not self.is_build_possible(move_position, build_position):\n            return False, 'Invalid move or build position'\n        self.pawns[pawn_number - 1].move(move_position)\n        self.board[build_position[0]][build_position[1]] += 1\n        self.next_turn()\n        return True, 'Move and build successful'"
        },
        {
            "key_id": 19,
            "fqn": "santorinai/board.py/Board/copy",
            "imports": [
                "from typing import List",
                "from copy import deepcopy"
            ],
            "code": "def copy(self) -> 'Board':\n        new_board = Board(self.number_of_players)\n        new_board.board = deepcopy(self.board)\n        new_board.pawns = deepcopy(self.pawns)\n        new_board.player_turn = self.player_turn\n        new_board.turn_number = self.turn_number\n        return new_board"
        },
        {
            "key_id": 20,
            "fqn": "santorinai/board.py/Board/__repr__",
            "imports": [],
            "code": "def __repr__(self) -> str:\n        board_str = ''\n        for row in self.board:\n            board_str += ' '.join(str(cell) for cell in row) + '\\n'\n        return board_str"
        },
        {
            "key_id": 16,
            "fqn": "santorinai/board.py/Board/is_game_over",
            "imports": [],
            "code": "def is_game_over(self):\n    if self.is_everyone_stuck():\n        return True\n    for pawn in self.pawns:\n        if pawn.pos and self.board[pawn.pos[0]][pawn.pos[1]] == 3:  # Check if any pawn is on a level 3 tower\n            return True\n    return False"
        },
        {
            "key_id": 17,
            "fqn": "santorinai/board.py/Board/is_everyone_stuck",
            "imports": [],
            "code": "def is_everyone_stuck(self):\n    for pawn in self.pawns:\n        if self.get_possible_movement_positions(pawn) or self.get_possible_building_positions(pawn):\n            return False\n    return True"
        },
        {
            "key_id": 18,
            "fqn": "santorinai/board.py/Board/next_turn",
            "imports": [],
            "code": "def next_turn(self):\n    self.player_turn = (self.player_turn % self.number_of_players) + 1\n    self.turn_number += 1"
        },
        {
            "key_id": 26,
            "fqn": "santorinai/pawn.py/Pawn/move",
            "imports": [],
            "code": "def move(self, new_pos):\n    if self.player_number == self.board.player_turn and self.board.is_position_valid(new_pos) and self.board.is_move_possible(self.pos, new_pos):\n        self.pos = new_pos\n        return True\n    return False"
        },
        {
            "key_id": 27,
            "fqn": "santorinai/pawn.py/Pawn/copy",
            "imports": [],
            "code": "def copy(self):\n    return Pawn(self.number, self.order, self.player_number)"
        },
        {
            "key_id": 28,
            "fqn": "santorinai/pawn.py/Pawn/__repr__",
            "imports": [],
            "code": "def __repr__(self):\n    return f'Pawn({self.number}, {self.order}, {self.player_number}, {self.pos})'"
        },
        {
            "key_id": 6,
            "fqn": "santorinai/board.py/Board/get_player_pawns",
            "imports": [],
            "code": "def get_player_pawns(self, player_number):\n    return [pawn for pawn in self.pawns if pawn.player_number == player_number]"
        },
        {
            "key_id": 7,
            "fqn": "santorinai/board.py/Board/get_player_pawn",
            "imports": [],
            "code": "def get_player_pawn(self, player_number, pawn_number):\n    for pawn in self.pawns:\n        if pawn.player_number == player_number and pawn.number == pawn_number:\n            return pawn\n    return None"
        },
        {
            "key_id": 8,
            "fqn": "santorinai/board.py/Board/get_playing_pawn",
            "imports": [],
            "code": "def get_playing_pawn(self, pawn_number):\n    for pawn in self.pawns:\n        if pawn.order == pawn_number and pawn.player_number == self.player_turn:\n            return pawn\n    return None"
        },
        {
            "key_id": 9,
            "fqn": "santorinai/board.py/Board/get_first_unplaced_player_pawn",
            "imports": [],
            "code": "def get_first_unplaced_player_pawn(self, player_number):\n    for pawn in self.pawns:\n        if pawn.player_number == player_number and pawn.pos == (None, None):\n            return pawn\n    return None"
        },
        {
            "key_id": 10,
            "fqn": "santorinai/board.py/Board/get_possible_movement_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_movement_positions(self, pawn) -> List[Tuple[int, int]]:\n    possible_positions = []\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for direction in directions:\n        new_pos = (pawn.pos[0] + direction[0], pawn.pos[1] + direction[1])\n        if self.is_position_within_board(new_pos) and not self.is_pawn_on_position(new_pos) and self.is_position_adjacent(pawn.pos, new_pos):\n            if self.is_move_possible(pawn.pos, new_pos)[0]:\n                possible_positions.append(new_pos)\n    return possible_positions"
        },
        {
            "key_id": 11,
            "fqn": "santorinai/board.py/Board/get_possible_building_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_building_positions(self, pawn) -> List[Tuple[int, int]]:\n    possible_positions = []\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for direction in directions:\n        new_pos = (pawn.pos[0] + direction[0], pawn.pos[1] + direction[1])\n        if self.is_position_within_board(new_pos) and not self.is_pawn_on_position(new_pos):\n            if self.is_build_possible(pawn.pos, new_pos):\n                possible_positions.append(new_pos)\n    return possible_positions"
        },
        {
            "key_id": 12,
            "fqn": "santorinai/board.py/Board/get_possible_movement_and_building_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_movement_and_building_positions(self, pawn):\n    possible_moves = self.get_possible_movement_positions(pawn)\n    possible_builds = []\n    for move in possible_moves:\n        pawn_copy = pawn.copy()\n        pawn_copy.move(move)\n        possible_builds.extend([(move, build) for build in self.get_possible_building_positions(pawn_copy)])\n    return possible_builds"
        },
        {
            "key_id": 22,
            "fqn": "santorinai/player.py/Player/name",
            "imports": [],
            "code": "def name(self):\n    return 'BasicPlayer'"
        },
        {
            "key_id": 23,
            "fqn": "santorinai/player.py/Player/place_pawn",
            "imports": [
                "from random import choice"
            ],
            "code": "def place_pawn(self, board, pawn) -> Tuple[int, int]:\n    possible_positions = [(x, y) for x in range(5) for y in range(5) if not board.is_pawn_on_position((x, y))]\n    chosen_position = choice(possible_positions)\n    success, msg = board.place_pawn(chosen_position)\n    if success:\n        return chosen_position\n    else:\n        raise Exception(f'Failed to place pawn: {msg}')"
        },
        {
            "key_id": 24,
            "fqn": "santorinai/player.py/Player/play_move",
            "imports": [
                "from random import choice"
            ],
            "code": "def play_move(self, board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n    my_pawns = board.get_player_pawns(self.player_number)\n    for pawn in my_pawns:\n        possible_moves_and_builds = board.get_possible_movement_and_building_positions(pawn)\n        if possible_moves_and_builds:\n            chosen_move_and_build = choice(possible_moves_and_builds)\n            success, msg = board.play_move(pawn.number, chosen_move_and_build[0], chosen_move_and_build[1])\n            if success:\n                return pawn.number, chosen_move_and_build[0], chosen_move_and_build[1]\n    return None, None, None"
        },
        {
            "key_id": 34,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/name",
            "imports": [],
            "code": "def name(self):\n    return 'FirstChoicePlayer'"
        },
        {
            "key_id": 35,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/place_pawn",
            "imports": [],
            "code": "def place_pawn(self, board, pawn):\n    for x in range(5):\n        for y in range(5):\n            if not board.is_pawn_on_position((x, y)):\n                success, msg = board.place_pawn((x, y))\n                if success:\n                    return (x, y)\n    raise Exception('Failed to place pawn: No valid positions available')"
        },
        {
            "key_id": 36,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/play_move",
            "imports": [],
            "code": "def play_move(self, board):\n    my_pawns = board.get_player_pawns(self.player_number)\n    for pawn in my_pawns:\n        possible_moves_and_builds = board.get_possible_movement_and_building_positions(pawn)\n        if possible_moves_and_builds:\n            for move_and_build in possible_moves_and_builds:\n                success, msg = board.play_move(pawn.number, move_and_build[0], move_and_build[1])\n                if success:\n                    return pawn.number, move_and_build[0], move_and_build[1]\n    return None, None, None"
        },
        {
            "key_id": 38,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/name",
            "imports": [],
            "code": "def name(self):\n    return 'RandomPlayer'"
        },
        {
            "key_id": 39,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/place_pawn",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def place_pawn(self, board: Board, pawn: Pawn) -> tuple[int, int]:\n        possible_positions = board.get_possible_movement_positions(pawn)\n        if not possible_positions:\n            raise ValueError('No possible positions to place pawn.')\n        position = choice(possible_positions)\n        return position"
        },
        {
            "key_id": 40,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/play_move",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def play_move(self, board: Board):\n        my_pawn = choice([pawn for pawn in board.pawns if pawn.player_number == self.player_number and pawn.pos is not None])\n        possible_moves = board.get_possible_movement_and_building_positions(my_pawn)\n        if not possible_moves:\n            return None, None, None\n        move_position, build_position = choice(possible_moves)\n        return my_pawn.order, move_position, build_position"
        },
        {
            "key_id": 42,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/name",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def name(self):\n        return 'BasicPlayer'"
        },
        {
            "key_id": 43,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_ally_pawn",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def get_ally_pawn(self, board: Board, our_pawn: Pawn) -> tuple[Pawn, None]:\n        for pawn in board.get_player_pawns(self.player_number):\n            if pawn != our_pawn and pawn.pos is not None:\n                return pawn, None\n        return None, None"
        },
        {
            "key_id": 44,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_enemy_pawns",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def get_enemy_pawns(self, board: Board, our_pawn):\n        return [pawn for pawn in board.pawns if pawn.player_number != self.player_number]"
        },
        {
            "key_id": 45,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_winning_moves",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def get_winning_moves(self, board: Board, pawn: Pawn):\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        winning_moves = [move for move in possible_moves if board.board[move[0][0]][move[0][1]] == 3]\n        return winning_moves"
        },
        {
            "key_id": 46,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/place_pawn",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def place_pawn(self, board: Board, pawn: Pawn):\n        possible_positions = board.get_possible_movement_positions(pawn)\n        if not possible_positions:\n            raise ValueError('No possible positions to place pawn.')\n        position = choice(possible_positions)\n        return position"
        },
        {
            "key_id": 47,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/play_move",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from random import choice"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def play_move(self, board: Board):\n        my_pawn = choice([pawn for pawn in board.pawns if pawn.player_number == self.player_number and pawn.pos is not None])\n        possible_moves = board.get_possible_movement_and_building_positions(my_pawn)\n        if not possible_moves:\n            return None, None, None\n        move_position, build_position = choice(possible_moves)\n        return my_pawn.order, move_position, build_position"
        },
        {
            "key_id": 29,
            "fqn": "santorinai/board_displayer/board_displayer.py/init_window",
            "imports": [
                "import PySimpleGUI as sg",
                "from santorinai.board import Board",
                "from santorinai.board_displayer.board_displayer import init_window, update_board"
            ],
            "code": "def init_window(player_names):\n    sg.theme('Dark Blue 3')\n    layout = [[sg.Text('Santorini Game', size=(30, 1), justification='center', font=('Helvetica', 25), relief=sg.RELIEF_RIDGE)],\n              [sg.Canvas(size=(800, 600), key='-CANVAS-')],\n              [sg.Button('Exit')]]\n    window = sg.Window('Santorini Board', layout, finalize=True)\n    return window"
        },
        {
            "key_id": 30,
            "fqn": "santorinai/board_displayer/board_displayer.py/draw_isometric_cube",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def draw_isometric_cube(window: sg.Window, x, y, size, cube_height, color, line_color, line_width):\n    canvas = window['-CANVAS-'].TKCanvas\n    # Example drawing function, replace with actual logic to draw an isometric cube\n    points = [(x, y), (x + size, y), (x + size, y + size), (x, y + size)]\n    canvas.create_polygon(points, fill=color, outline=line_color, width=line_width)"
        },
        {
            "key_id": 31,
            "fqn": "santorinai/board_displayer/board_displayer.py/update_board",
            "imports": [
                "import PySimpleGUI as sg",
                "from santorinai.board import Board"
            ],
            "code": "def update_board(window: sg.Window, board: Board):\n    window['-BOARD-'].update(value=board.__repr__())\n    for y in range(board.SIZE):\n        for x in range(board.SIZE):\n            tile = board.board[y][x]\n            color = 'white' if tile == 0 else 'grey'\n            if tile > 0:\n                color = 'blue'\n            elif tile == 4:\n                color = 'red'\n            window[(x, y)].update(button_color=('black', color))\n    window.refresh()"
        },
        {
            "key_id": 32,
            "fqn": "santorinai/board_displayer/board_displayer.py/close_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def close_window(window: sg.Window):\n    window.close()"
        }
    ]
}