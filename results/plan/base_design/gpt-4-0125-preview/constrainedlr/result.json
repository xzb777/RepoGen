{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class ConstrainedLinearRegression:\n    def __init__(self, fit_intercept: bool = True, alpha: float = 0.0):\n        self.fit_intercept = fit_intercept\n        self.alpha = alpha\n        self.coef_ = None\n        self.intercept_ = None\n\n    def _validate_inputs(self):\n        if not isinstance(self.fit_intercept, bool):\n            raise ValueError('fit_intercept must be a boolean')\n        if not isinstance(self.alpha, (float, int)) or self.alpha < 0:\n            raise ValueError('alpha must be a non-negative number')"
        },
        {
            "key_id": 4,
            "fqn": "constrainedlr/validation.py/validate_constraint_features_all_strings_or_all_int",
            "imports": [],
            "code": "def validate_constraint_features_all_strings_or_all_int(constraints: dict) -> None:\n    if not all(isinstance(key, str) for key in constraints) and not all(isinstance(key, int) for key in constraints):\n        raise ValueError('All constraint feature keys must be all strings or all integers.')"
        },
        {
            "key_id": 5,
            "fqn": "constrainedlr/validation.py/get_clean_feature_names_from_pipeline",
            "imports": [],
            "code": "def get_clean_feature_names_from_pipeline(feature_names: list[str]) -> list[str]:\n    clean_names = []\n    for name in feature_names:\n        if isinstance(name, str) and name.startswith('step_'):\n            clean_name = name.split('__')[-1]\n            clean_names.append(clean_name)\n        else:\n            clean_names.append(name)\n    return clean_names"
        },
        {
            "key_id": 6,
            "fqn": "constrainedlr/validation.py/validate_feature_names_in_constraints",
            "imports": [
                "from .validation import validate_constraint_features_all_strings_or_all_int",
                "from .validation import get_clean_feature_names_from_pipeline",
                "from .validation import convert_feature_names_to_indices"
            ],
            "code": "def validate_feature_names_in_constraints(constraints: dict, feature_names: list[str]) -> None:\n    validate_constraint_features_all_strings_or_all_int(constraints)\n    clean_feature_names = get_clean_feature_names_from_pipeline(feature_names)\n    for key in constraints.keys():\n        if key not in clean_feature_names:\n            raise ValueError(f'Constraint feature {key} is not a valid feature name.')"
        },
        {
            "key_id": 7,
            "fqn": "constrainedlr/validation.py/convert_feature_names_to_indices",
            "imports": [
                "from .validation import get_clean_feature_names_from_pipeline"
            ],
            "code": "def convert_feature_names_to_indices(constraints: dict, feature_names_in_: np.ndarray[str]) -> dict:\n    clean_feature_names = get_clean_feature_names_from_pipeline(list(feature_names_in_))\n    return {clean_feature_names.index(key): value for key, value in constraints.items() if key in clean_feature_names}"
        },
        {
            "key_id": 8,
            "fqn": "constrainedlr/validation.py/validate_coefficients_sign_constraints",
            "imports": [
                "from .validation import validate_constraint_features_all_strings_or_all_int"
            ],
            "code": "def validate_coefficients_sign_constraints(coefficients_sign_constraints: Optional[dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> dict:\n    if coefficients_sign_constraints is None:\n        return {}\n    validate_constraint_features_all_strings_or_all_int(coefficients_sign_constraints)\n    valid_constraints = {}\n    for key, value in coefficients_sign_constraints.items():\n        if value not in [-1, 0, 1]:\n            raise ValueError(f'Invalid sign constraint value {value} for key {key}. Must be -1, 0, or 1.')\n        valid_constraints[key] = value\n    return valid_constraints"
        },
        {
            "key_id": 9,
            "fqn": "constrainedlr/validation.py/validate_intercept_sign_constraint",
            "imports": [
                "from typing import Union"
            ],
            "code": "def validate_intercept_sign_constraint(intercept_sign_constraint: Union[int, str]) -> int:\n    if isinstance(intercept_sign_constraint, str):\n        if intercept_sign_constraint.lower() == 'positive':\n            return 1\n        elif intercept_sign_constraint.lower() == 'negative':\n            return -1\n        elif intercept_sign_constraint.lower() == 'none':\n            return 0\n        else:\n            raise ValueError('Invalid value for intercept_sign_constraint. Allowed values are positive, negative, or none.')\n    elif isinstance(intercept_sign_constraint, int) and intercept_sign_constraint in [-1, 0, 1]:\n        return intercept_sign_constraint\n    else:\n        raise ValueError('intercept_sign_constraint must be an integer among -1, 0, 1 or a string among positive, negative, none.')"
        },
        {
            "key_id": 10,
            "fqn": "constrainedlr/validation.py/validate_coefficients_range_constraints",
            "imports": [
                "from typing import Optional, Union, dict",
                "import numpy as np",
                "from .validate_constraint_features_all_strings_or_all_int import validate_constraint_features_all_strings_or_all_int",
                "from .convert_feature_names_to_indices import convert_feature_names_to_indices"
            ],
            "code": "def validate_coefficients_range_constraints(coefficients_range_constraints: Optional[dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> dict:\n    if coefficients_range_constraints is None:\n        return {}\n    validate_constraint_features_all_strings_or_all_int(coefficients_range_constraints)\n    coefficients_range_constraints = convert_feature_names_to_indices(coefficients_range_constraints, feature_names_in_)\n    for key, value in coefficients_range_constraints.items():\n        if 'lower' in value and 'upper' in value:\n            if value['lower'] > value['upper']:\n                raise ValueError(f'Lower bound cannot be greater than upper bound for coefficient {key}')\n        if 'lower' in value:\n            if not isinstance(value['lower'], (int, float)):\n                raise ValueError(f'Lower bound must be a number for coefficient {key}')\n        if 'upper' in value:\n            if not isinstance(value['upper'], (int, float)):\n                raise ValueError(f'Upper bound must be a number for coefficient {key}')\n    return coefficients_range_constraints"
        },
        {
            "key_id": 1,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/fit",
            "imports": [
                "from typing import Union, Optional, dict",
                "import numpy as np",
                "import pandas as pd",
                "from .validation import validate_intercept_sign_constraint, validate_coefficients_range_constraints, validate_coefficients_sign_constraints"
            ],
            "code": "def fit(self, X: Union[np.ndarray, pd.DataFrame], y: np.ndarray, sample_weight: Optional[np.ndarray] = None, coefficients_sign_constraints: Optional[dict] = None, coefficients_range_constraints: Optional[dict] = None, intercept_sign_constraint: Union[int, str] = 0, coefficients_sum_constraint: Optional[float] = None) -> 'ConstrainedLinearRegression':\n    self._validate_inputs()\n    intercept_sign = validate_intercept_sign_constraint(intercept_sign_constraint)\n    coefficients_range = validate_coefficients_range_constraints(coefficients_range_constraints, X, self.get_feature_names_out())\n    coefficients_sign = validate_coefficients_sign_constraints(coefficients_sign_constraints, X, self.get_feature_names_out())\n    # Placeholder for the optimization logic to fit the model with constraints\n    # This part would involve solving the optimization problem given the constraints\n    # and updating self.coef_ and self.intercept_ accordingly\n    return self"
        },
        {
            "key_id": 2,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/predict",
            "imports": [
                "import numpy as np"
            ],
            "code": "def predict(self, X: Union[np.ndarray, pd.DataFrame]) -> np.ndarray:\n    if self.coef_ is None or self.intercept_ is None:\n        raise Exception('Model is not fitted yet. Please call fit before predict.')\n    return np.dot(X, self.coef_) + self.intercept_"
        },
        {
            "key_id": 3,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/get_feature_names_out",
            "imports": [
                "import numpy as np"
            ],
            "code": "def get_feature_names_out(self) -> np.ndarray[str]:\n    if self.coef_ is None:\n        raise Exception('Model is not fitted yet. Feature names cannot be determined.')\n    return np.array([f'x{i}' for i in range(self.coef_.shape[0])])"
        }
    ]
}