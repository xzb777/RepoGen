{
    "implementation": [
        {
            "key_id": 41,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/__init__",
            "imports": [
                "from typing import List",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "import logging"
            ],
            "code": "def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n    self.schema = schema\n    self.name = name\n    self.old_values = old_values\n    self.new_values = new_values\n    self.affected_columns = affected_columns\n    self.operation_name = 'change_enum_variants'\n    log = logging.getLogger(f'alembic.{__name__}')\n    log.info(f'Initializing SyncEnumValuesOp with name: {name}, schema: {schema}')"
        },
        {
            "key_id": 48,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/__init__",
            "imports": [
                "from typing import Iterable"
            ],
            "code": "def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n    self.schema = schema\n    self.name = name\n    self.enum_values = list(enum_values)\n    self.operation_name = self.__class__.__name__.replace('Op', '').lower()\n    print(f'EnumLifecycle operation {self.operation_name} for enum {name} in schema {schema} with values {enum_values}')"
        },
        {
            "key_id": 10,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_array_enum_type_to_new",
            "imports": [
                "from sqlalchemy import text",
                "from alembic_postgresql_enum.sql_commands.enum_type import TableReference"
            ],
            "code": "def cast_old_array_enum_type_to_new(connection, table_reference: TableReference, enum_type_name: str, enum_values_to_rename: list):\n    for old_value, new_value in enum_values_to_rename:\n        connection.execute(text(f\"UPDATE {table_reference.table_name_with_schema()} SET {table_reference.column_name} = array_replace({table_reference.column_name}, '{old_value}', '{new_value}') WHERE {table_reference.column_name} @> ARRAY['{old_value}']::varchar[];\"))"
        },
        {
            "key_id": 11,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_enum_type_to_new",
            "imports": [
                "from sqlalchemy import text",
                "from alembic_postgresql_enum.sql_commands.enum_type import TableReference"
            ],
            "code": "def cast_old_enum_type_to_new(connection, table_reference: TableReference, enum_type_name: str, enum_values_to_rename: list):\n    for old_value, new_value in enum_values_to_rename:\n        connection.execute(text(f\"UPDATE {table_reference.table_name_with_schema()} SET {table_reference.column_name} = '{new_value}' WHERE {table_reference.column_name} = '{old_value}';\"))"
        },
        {
            "key_id": 12,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/drop_type",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def drop_type(connection, schema: str, type_name: str):\n    connection.execute(text(f\"DROP TYPE IF EXISTS {schema}.{type_name};\"))"
        },
        {
            "key_id": 13,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/rename_type",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def rename_type(connection, schema: str, type_name: str, new_type_name: str):\n    connection.execute(text(f\"ALTER TYPE {schema}.{type_name} RENAME TO {new_type_name};\"))"
        },
        {
            "key_id": 14,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/create_type",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def create_type(connection, schema: str, type_name: str, enum_values: list):\n    enum_values_str = ', '.join(f\"'{value}'\" for value in enum_values)\n    connection.execute(text(f\"CREATE TYPE {schema}.{type_name} AS ENUM ({enum_values_str});\"))"
        },
        {
            "key_id": 15,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/get_all_enums",
            "imports": [
                "from sqlalchemy import text",
                "from typing import List, Tuple"
            ],
            "code": "def get_all_enums(connection, schema: str) -> List[Tuple[str, List[str]]]:\n    query = text(\n        \"SELECT t.typname AS enumtype,\\n       array_agg(e.enumlabel ORDER BY e.enumsortorder) AS enumlabels\\nFROM pg_type t\\nJOIN pg_enum e ON t.oid = e.enumtypid\\nJOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\\nWHERE n.nspname = :schema\\nGROUP BY enumtype\"\n    )\n    result = connection.execute(query, schema=schema).fetchall()\n    return [(row['enumtype'], row['enumlabels']) for row in result]"
        },
        {
            "key_id": 16,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/get_column_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def get_column_default(connection, table_schema: str, table_name: str, column_name: str) -> str:\n    query = text(\n        \"SELECT column_default\\nFROM information_schema.columns\\nWHERE table_schema = :schema\\nAND table_name = :table\\nAND column_name = :column\"\n    )\n    result = connection.execute(query, schema=table_schema, table=table_name, column=column_name).fetchone()\n    return result['column_default'] if result else None"
        },
        {
            "key_id": 17,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/drop_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def drop_default(connection, table_name_with_schema: str, column_name: str):\n    query = text(\n        \"ALTER TABLE :table_name_with_schema ALTER COLUMN :column_name DROP DEFAULT\"\n    )\n    connection.execute(query, table_name_with_schema=table_name_with_schema, column_name=column_name)"
        },
        {
            "key_id": 18,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/set_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def set_default(connection, table_name_with_schema: str, column_name: str, default_value: str):\n    query = text(\n        \"ALTER TABLE :table_name_with_schema ALTER COLUMN :column_name SET DEFAULT :default_value\"\n    )\n    connection.execute(query, table_name_with_schema=table_name_with_schema, column_name=column_name, default_value=default_value)"
        },
        {
            "key_id": 19,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/rename_default_if_required",
            "imports": [
                "import re"
            ],
            "code": "def rename_default_if_required(schema: str, default_value: str, enum_name: str, enum_values_to_rename: List[Tuple[str, str]]) -> str:\n    for old_value, new_value in enum_values_to_rename:\n        pattern = re.compile(f\"'{old_value}'::\" + schema + \".\" + enum_name)\n        default_value = pattern.sub(f\"'{new_value}'::\" + schema + \".\" + enum_name, default_value)\n    return default_value"
        },
        {
            "key_id": 20,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/_replace_strings_in_quotes",
            "imports": [
                "import re"
            ],
            "code": "def _replace_strings_in_quotes(old_default: str, enum_values_to_rename: List[Tuple[str, str]]) -> str:\n    for old_value, new_value in enum_values_to_rename:\n        old_default = re.sub(f\"'{old_value}'\", f\"'{new_value}'\", old_default)\n    return old_default"
        },
        {
            "key_id": 21,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_create_comparison_operator",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def _create_comparison_operator(connection, schema: str, enum_name: str, old_enum_name: str, enum_values_to_rename: List[Tuple[str, str]], operator: str, comparison_function_name: str):\n    operation_sql = f\"CREATE OR REPLACE FUNCTION {schema}.{comparison_function_name}(a {schema}.{enum_name}, b {schema}.{enum_name}) RETURNS boolean LANGUAGE sql IMMUTABLE AS $$ SELECT $1 {operator} $2; $$;\"\n    connection.execute(text(operation_sql))"
        },
        {
            "key_id": 22,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/create_comparison_operators",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def create_comparison_operators(connection, schema: str, enum_name: str, old_enum_name: str, enum_values_to_rename: List[Tuple[str, str]]):\n    for operator, function_name in OPERATORS_TO_CREATE:\n        _create_comparison_operator(connection, schema, enum_name, old_enum_name, enum_values_to_rename, operator, function_name)"
        },
        {
            "key_id": 23,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_drop_comparison_operator",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def _drop_comparison_operator(connection, schema: str, enum_name: str, old_enum_name: str, comparison_function_name: str):\n    drop_sql = f\"DROP FUNCTION IF EXISTS {schema}.{comparison_function_name};\"\n    connection.execute(text(drop_sql))"
        },
        {
            "key_id": 24,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/drop_comparison_operators",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def drop_comparison_operators(connection, schema: str, enum_name: str, old_enum_name: str):\n    for _, function_name in OPERATORS_TO_CREATE:\n        _drop_comparison_operator(connection, schema, enum_name, old_enum_name, function_name)"
        },
        {
            "key_id": 25,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/ColumnType/__repr__",
            "imports": [
                "from enum import Enum"
            ],
            "code": "class ColumnType(Enum):\n    COMMON = 'common'\n    ARRAY = 'array'\n\n    def __repr__(self):\n        return f'<ColumnType.{self.name}>'"
        },
        {
            "key_id": 26,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/__repr__",
            "imports": [],
            "code": "class TableReference:\n    def __init__(self, schema: str, table_name: str, column_name: str, column_type: ColumnType):\n        self.schema = schema\n        self.table_name = table_name\n        self.column_name = column_name\n        self.column_type = column_type\n\n    def __repr__(self):\n        return f'<TableReference schema={self.schema}, table={self.table_name}, column={self.column_name}, type={self.column_type}>'"
        },
        {
            "key_id": 27,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/is_column_type_import_needed",
            "imports": [
                "from .types import ColumnType"
            ],
            "code": "def is_column_type_import_needed(self) -> bool:\n        return self.column_type == ColumnType.ARRAY"
        },
        {
            "key_id": 28,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/table_name_with_schema",
            "imports": [],
            "code": "def table_name_with_schema(self) -> str:\n        return f'{self.schema}.{self.table_name}' if self.schema else self.table_name"
        },
        {
            "key_id": 29,
            "fqn": "alembic_postgresql_enum/get_enum_data/defined_enums.py/_remove_schema_prefix",
            "imports": [],
            "code": "def _remove_schema_prefix(enum_name: str, schema: str) -> str:\n        return enum_name[len(schema) + 1:] if enum_name.startswith(schema + '.') else enum_name"
        },
        {
            "key_id": 30,
            "fqn": "alembic_postgresql_enum/get_enum_data/defined_enums.py/get_defined_enums",
            "imports": [
                "from typing import Dict, Tuple",
                "from sqlalchemy.engine import Connection",
                "from alembic_postgresql_enum.sql_commands.enum_type import get_all_enums"
            ],
            "code": "def get_defined_enums(connection: Connection, schema: str) -> Dict[str, Tuple[str, ...]]:\n    enums = get_all_enums(connection, schema)\n    enum_definitions = {}\n    for enum in enums:\n        enum_name, enum_values = enum\n        enum_definitions[enum_name] = tuple(enum_values)\n    return enum_definitions"
        },
        {
            "key_id": 31,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_enum_values",
            "imports": [
                "from sqlalchemy import Enum",
                "from typing import Tuple"
            ],
            "code": "def get_enum_values(enum_type: Enum) -> Tuple[str, ...]:\n    return tuple([e.value for e in enum_type.enums])"
        },
        {
            "key_id": 32,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/column_type_is_enum",
            "imports": [
                "from sqlalchemy.types import Enum",
                "from typing import Any"
            ],
            "code": "def column_type_is_enum(column_type: Any) -> bool:\n    return isinstance(column_type, Enum)"
        },
        {
            "key_id": 33,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_declared_enums",
            "imports": [
                "from sqlalchemy.schema import MetaData",
                "from typing import Union, List, Dict, Optional",
                "from sqlalchemy.engine import Connection",
                "from alembic.operations import Operations, UpgradeOps",
                "from alembic_postgresql_enum.get_enum_data.declared_enums import get_enum_values, column_type_is_enum",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference, DeclaredEnumValues"
            ],
            "code": "def get_declared_enums(metadata: Union[MetaData, List[MetaData]], schema: str, default_schema: str, connection: Connection, upgrade_ops: Optional[UpgradeOps] = None) -> DeclaredEnumValues:\n    enum_values = {}\n    enum_table_references = {}\n    for meta in metadata if isinstance(metadata, list) else [metadata]:\n        for table in meta.tables.values():\n            for column in table.columns:\n                if column_type_is_enum(column.type):\n                    enum_vals = get_enum_values(column.type)\n                    enum_name = column.type.name\n                    if enum_name not in enum_values:\n                        enum_values[enum_name] = enum_vals\n                    if enum_name not in enum_table_references:\n                        enum_table_references[enum_name] = []\n                    enum_table_references[enum_name].append(TableReference(table.name, column.name))\n    return DeclaredEnumValues(enum_values, enum_table_references)"
        },
        {
            "key_id": 34,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_add_column_op",
            "imports": [
                "from typing import Tuple, Optional",
                "from alembic.operations.ops import AddColumnOp",
                "from alembic_postgresql_enum.get_enum_data.get_default_from_alembic_ops import _get_default_from_column",
                "from alembic_postgresql_enum.get_enum_data.types import ColumnLocation, SchemaName, TableName, ColumnName"
            ],
            "code": "def _get_default_from_add_column_op(op: AddColumnOp, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:\n    column = op.column\n    table_name = op.table_name\n    schema_name = op.schema or default_schema\n    column_name = column.name\n    column_location = (schema_name, table_name, column_name)\n    default_value = _get_default_from_column(column, default_schema)\n    return column_location, default_value"
        },
        {
            "key_id": 36,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_column",
            "imports": [
                "from typing import Tuple, Optional",
                "from sqlalchemy import Column",
                "from alembic.operations.ops import AlterColumnOp"
            ],
            "code": "def _get_default_from_column(column: Column, default_schema: str) -> Tuple[Tuple[str, str, str], Optional[str]]:\n    schema = column.table.schema or default_schema\n    table_name = column.table.name\n    column_name = column.name\n    default = str(column.default.arg) if column.default is not None else None\n    return ((schema, table_name, column_name), default)"
        },
        {
            "key_id": 35,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_alter_column_op",
            "imports": [
                "from typing import Tuple, Optional",
                "from alembic.operations.ops import AlterColumnOp",
                "from alembic_postgresql_enum.get_enum_data.get_default_from_alembic_ops import _get_default_from_column"
            ],
            "code": "def _get_default_from_alter_column_op(op: AlterColumnOp, default_schema: str) -> Tuple[Tuple[str, str, str], Optional[str]]:\n    column = op.column\n    return _get_default_from_column(column, default_schema)"
        },
        {
            "key_id": 37,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/get_just_added_defaults",
            "imports": [
                "from typing import Dict, Tuple, Optional",
                "from alembic.operations import Operations, UpgradeOps",
                "from alembic_postgresql_enum.get_enum_data.get_default_from_alembic_ops import _get_default_from_add_column_op, _get_default_from_alter_column_op"
            ],
            "code": "def get_just_added_defaults(upgrade_ops: Optional[UpgradeOps], default_schema: str) -> Dict[Tuple[str, str, str], Optional[str]]:\n    defaults = {}\n    for op in upgrade_ops.ops:\n        if isinstance(op, AddColumnOp):\n            location, default = _get_default_from_add_column_op(op, default_schema)\n            if default is not None:\n                defaults[location] = default\n        elif isinstance(op, AlterColumnOp) and op.modify_default:\n            location, default = _get_default_from_alter_column_op(op, default_schema)\n            if default is not None:\n                defaults[location] = default\n    return defaults"
        },
        {
            "key_id": 38,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_creation.py/create_new_enums",
            "imports": [
                "import logging",
                "from alembic.operations import Operations",
                "from typing import Dict"
            ],
            "code": "def create_new_enums(defined_enums: Dict[str, set], declared_enums: Dict[str, set], schema: str, upgrade_ops: Operations):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    for name, values in declared_enums.items():\n        if name not in defined_enums:\n            log.info(f\"Creating new enum {name} with values {values}\")\n            upgrade_ops.create_enum(name=name, values=list(values), schema=schema)"
        },
        {
            "key_id": 39,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_alteration.py/sync_changed_enums",
            "imports": [
                "import logging",
                "from alembic.operations import Operations",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp",
                "from typing import Dict, List"
            ],
            "code": "def sync_changed_enums(defined_enums: Dict[str, set], declared_enums: Dict[str, set], table_references: Dict[str, List[str]], schema: str, upgrade_ops: Operations):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    for name, new_values in declared_enums.items():\n        if name in defined_enums and defined_enums[name] != new_values:\n            log.info(f\"Syncing enum {name} with new values {new_values}\")\n            affected_columns = table_references.get(name, [])\n            upgrade_ops.invoke_operation(SyncEnumValuesOp, schema=schema, name=name, old_values=list(defined_enums[name]), new_values=list(new_values), affected_columns=affected_columns)"
        },
        {
            "key_id": 40,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_deletion.py/drop_unused_enums",
            "imports": [
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.operations.drop_enum import DropEnumOp",
                "from typing import Dict, Set",
                "import logging"
            ],
            "code": "def drop_unused_enums(defined_enums: Dict[str, Set[str]], declared_enums: Dict[str, Set[str]], schema: str, upgrade_ops: ops.UpgradeOps):\n    log = logging.getLogger(f'alembic.{__name__}')\n    unused_enums = defined_enums.keys() - declared_enums.keys()\n    for enum_name in unused_enums:\n        log.info(f'Dropping unused enum: {enum_name} in schema {schema}')\n        drop_enum_op = DropEnumOp(schema=schema, name=enum_name, enum_values=list(defined_enums[enum_name]))\n        upgrade_ops.ops.append(drop_enum_op)"
        },
        {
            "key_id": 42,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/reverse",
            "imports": [
                "from alembic.operations import ops",
                "import logging"
            ],
            "code": "def reverse(self):\n    log = logging.getLogger(f'alembic.{__name__}')\n    log.info(f'Reversing SyncEnumValuesOp for enum: {self.name} in schema: {self.schema}')\n    return ops.AlterEnumOp(self.schema, self.name, self.new_values, self.old_values, self.affected_columns)"
        },
        {
            "key_id": 43,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/_set_enum_values",
            "imports": [
                "from sqlalchemy import text",
                "from alembic.runtime.environment import EnvironmentContext",
                "import logging"
            ],
            "code": "def _set_enum_values(cls, connection, enum_schema: str, enum_name: str, new_values: list, affected_columns: list, enum_values_to_rename: list):\n    log = logging.getLogger(f'alembic.{__name__}')\n    log.info(f'Setting new values for enum: {enum_name} in schema: {enum_schema}')\n    for old_value, new_value in enum_values_to_rename:\n        connection.execute(text(f\"ALTER TYPE {enum_schema}.{enum_name} RENAME VALUE '{old_value}' TO '{new_value}';\"))\n    connection.execute(text(f\"ALTER TYPE {enum_schema}.{enum_name} ADD VALUE IF NOT EXISTS {' AND '.join([f'\\'{value}\\'' for value in new_values])};\"))"
        },
        {
            "key_id": 44,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/sync_enum_values",
            "imports": [
                "from alembic.operations import Operations",
                "from alembic.runtime.environment import EnvironmentContext",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp",
                "import logging"
            ],
            "code": "def sync_enum_values(cls, operations: Operations, enum_schema: str, enum_name: str, new_values: list, affected_columns: list, enum_values_to_rename: list = []):\n    log = logging.getLogger(f'alembic.{__name__}')\n    log.info(f'Syncing enum values for: {enum_name} in schema: {enum_schema}')\n    op = SyncEnumValuesOp(schema=enum_schema, name=enum_name, old_values=[], new_values=new_values, affected_columns=affected_columns)\n    operations.invoke(op)"
        },
        {
            "key_id": 45,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/to_diff_tuple",
            "imports": [
                "import logging"
            ],
            "code": "def to_diff_tuple(self):\n    log = logging.getLogger(f'alembic.{__name__}')\n    log.info(f'Creating diff tuple for SyncEnumValuesOp: {self.name} in schema: {self.schema}')\n    return ('enum_values', self.schema, self.name, self.old_values, self.new_values, self.affected_columns)"
        },
        {
            "key_id": 46,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/is_column_type_import_needed",
            "imports": [
                "from typing import List",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "import logging"
            ],
            "code": "class SyncEnumValuesOp:\n    def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n        self.schema = schema\n        self.name = name\n        self.old_values = old_values\n        self.new_values = new_values\n        self.affected_columns = affected_columns\n        self.operation_name = 'change_enum_variants'\n        log = logging.getLogger(f'alembic.{__name__}')\n        log.info(f'Initializing SyncEnumValuesOp with name: {name}, schema: {schema}')\n\n    def is_column_type_import_needed(self) -> bool:\n        return True"
        },
        {
            "key_id": 47,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/render_sync_enum_value_op",
            "imports": [
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp",
                "import logging"
            ],
            "code": "def render_sync_enum_value_op(autogen_context: AutogenContext, op: SyncEnumValuesOp):\n    log = logging.getLogger(f'alembic.{__name__}')\n    log.info(f'Rendering SyncEnumValuesOp for enum {op.name} in schema {op.schema}')\n    # Assuming rendering involves returning some form of string representation for the operation\n    return f'SyncEnumValuesOp(schema={op.schema}, name={op.name}, old_values={op.old_values}, new_values={op.new_values}, affected_columns={op.affected_columns})'"
        },
        {
            "key_id": 49,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/operation_name",
            "imports": [
                "from typing import Iterable"
            ],
            "code": "class EnumLifecycleOp:\n    def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n        self.schema = schema\n        self.name = name\n        self.enum_values = list(enum_values)\n        self.operation_name = self.__class__.__name__.replace('Op', '').lower()\n        print(f'EnumLifecycle operation {self.operation_name} for enum {name} in schema {schema} with values {enum_values}')\n\n    def operation_name(self) -> str:\n        return self.operation_name"
        },
        {
            "key_id": 50,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/to_diff_tuple",
            "imports": [],
            "code": "class EnumLifecycleOp(EnumLifecycleOp):\n    def to_diff_tuple(self) -> Tuple[Any, ...]:\n        return ('EnumLifecycleOp', self.schema, self.name, self.enum_values)"
        },
        {
            "key_id": 51,
            "fqn": "alembic_postgresql_enum/operations/create_enum.py/CreateEnumOp/reverse",
            "imports": [
                "from alembic_postgresql_enum.operations.create_enum import CreateEnumOp",
                "from alembic_postgresql_enum.operations.drop_enum import DropEnumOp"
            ],
            "code": "class CreateEnumOp:\n    def reverse(self):\n        return DropEnumOp(schema=self.schema, name=self.name, enum_values=self.enum_values)"
        },
        {
            "key_id": 52,
            "fqn": "alembic_postgresql_enum/operations/create_enum.py/render_create_enum_op",
            "imports": [
                "from alembic.autogenerate import renderers",
                "from alembic.operations import ops"
            ],
            "code": "def render_create_enum_op(autogen_context, op):\n    renderers.dispatch(autogen_context, op)"
        },
        {
            "key_id": 53,
            "fqn": "alembic_postgresql_enum/operations/drop_enum.py/DropEnumOp/reverse",
            "imports": [
                "from alembic.operations import ops"
            ],
            "code": "class DropEnumOp(ops.MigrateOperation):\n    def reverse(self):\n        return ops.CreateEnumOp(\n            schema=self.schema,\n            name=self.name,\n            enum_values=self.enum_values\n        )"
        },
        {
            "key_id": 54,
            "fqn": "alembic_postgresql_enum/operations/drop_enum.py/render_drop_enum_op",
            "imports": [
                "from alembic.autogenerate import renderers",
                "from alembic.operations import ops"
            ],
            "code": "def render_drop_enum_op(autogen_context, op):\n    renderers.dispatch(autogen_context, op)"
        },
        {
            "key_id": 0,
            "fqn": "alembic_postgresql_enum/connection.py/get_connection",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from contextlib import contextmanager"
            ],
            "code": "def get_connection(operations) -> Connection:\n    @contextmanager\n    def connection_context():\n        conn = operations.get_bind()\n        try:\n            yield conn\n        finally:\n            conn.close()\n    return connection_context()"
        },
        {
            "key_id": 1,
            "fqn": "alembic_postgresql_enum/compare_dispatch.py/compare_enums",
            "imports": [
                "import logging",
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic.operations import ops",
                "from typing import Iterable, Union"
            ],
            "code": "def compare_enums(autogen_context: AutogenContext, upgrade_ops: ops.UpgradeOps, schema_names: Iterable[Union[str, None]]):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    log.info(\"Comparing enums...\")\n    # Implementation for comparing enums and generating SyncEnumValuesOp operations"
        },
        {
            "key_id": 2,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/ReprWorkaround/__repr__",
            "imports": [
                "from sqlalchemy.dialects.postgresql import ENUM"
            ],
            "code": "class ReprWorkaround(ENUM):\n    __module__ = 'sqlalchemy.dialects.postgresql'\n\n    def __repr__(self):\n        return f\"<ReprWorkaround(name={self.name}, enums={self.enums})>\""
        },
        {
            "key_id": 3,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/get_replacement_type",
            "imports": [
                "from sqlalchemy import Column",
                "from sqlalchemy.dialects.postgresql import ENUM"
            ],
            "code": "def get_replacement_type(column_type):\n    if isinstance(column_type, ENUM):\n        return ReprWorkaround(name=column_type.name, enums=column_type.enums, metadata=column_type.metadata, schema=column_type.schema, create_type=False)\n    return column_type"
        },
        {
            "key_id": 4,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/inject_repr_into_enums",
            "imports": [
                "from sqlalchemy import Column"
            ],
            "code": "def inject_repr_into_enums(column: Column):\n    column.type = get_replacement_type(column.type)"
        },
        {
            "key_id": 5,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/add_create_type_false",
            "imports": [
                "from alembic.operations import ops",
                "from sqlalchemy import MetaData, Table"
            ],
            "code": "def add_create_type_false(upgrade_ops: ops.UpgradeOps):\n    metadata = MetaData()\n    for op in upgrade_ops.ops:\n        if isinstance(op, ops.CreateTableOp):\n            table = Table(op.table_name, metadata, *op.columns)\n            for column in table.columns:\n                inject_repr_into_enums(column)\n        elif isinstance(op, ops.AddColumnOp):\n            table = Table(op.table_name, metadata)\n            inject_repr_into_enums(op.column)"
        },
        {
            "key_id": 6,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/PostgresUsingAlterColumnOp/reverse",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.autogenerate.api import AutogenContext",
                "from sqlalchemy import text"
            ],
            "code": "class PostgresUsingAlterColumnOp(ops.AlterColumnOp):\n    def reverse(self):\n        new_op = self.copy()\n        new_op.modify_nullable = not self.modify_nullable\n        return new_op\n\n    @classmethod\n    def _postgres_using_alter_column(cls, autogen_context: AutogenContext, op: ops.AlterColumnOp) -> str:\n        return f\"ALTER COLUMN {op.column_name} TYPE {op.modify_type.compile(dialect=autogen_context.dialect)} USING {op.column_name}::text\"\n\n    @classmethod\n    def add_postgres_using_to_alter_operation(cls, op: ops.AlterColumnOp):\n        if op.modify_type is not None:\n            op.existing_type = op.modify_type\n            op.modify_type = text(cls._postgres_using_alter_column(AutogenContext(), op))"
        },
        {
            "key_id": 7,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/_postgres_using_alter_column",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.autogenerate.api import AutogenContext"
            ],
            "code": "def _postgres_using_alter_column(autogen_context: AutogenContext, op: ops.AlterColumnOp) -> str:\n    if op.modify_type is not None:\n        return 'USING {column_name}::text::{enum_type}'.format(column_name=op.column_name, enum_type=op.modify_type.impl.__visit_name__)\n    return ''"
        },
        {
            "key_id": 8,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_alter_operation",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic_postgresql_enum.add_postgres_using_to_text import _postgres_using_alter_column"
            ],
            "code": "def add_postgres_using_to_alter_operation(op: ops.AlterColumnOp):\n    using_clause = _postgres_using_alter_column(AutogenContext(op), op)\n    if using_clause:\n        op.existing_type.create(op.get_bind(), checkfirst=False)\n        op.alter_column_kwargs['postgresql_using'] = using_clause"
        },
        {
            "key_id": 9,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_text",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.operations import UpgradeOps",
                "from alembic_postgresql_enum.add_postgres_using_to_text import add_postgres_using_to_alter_operation"
            ],
            "code": "def add_postgres_using_to_text(upgrade_ops: UpgradeOps):\n    for op in upgrade_ops.ops:\n        if isinstance(op, ops.AlterColumnOp) and 'postgresql_using' not in op.alter_column_kwargs:\n            add_postgres_using_to_alter_operation(op)"
        }
    ]
}