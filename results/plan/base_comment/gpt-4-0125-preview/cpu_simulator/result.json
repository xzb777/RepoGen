{
    "implementation": [
        {
            "key_id": 17,
            "fqn": "src/hardware/basic_components.py/HalfAdder/__init__",
            "imports": [
                "from src.hardware.gates import and_",
                "from src.hardware.gates import or_"
            ],
            "code": "class HalfAdder:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sum = None\n        self.carry = None\n\n    def calculate(self):\n        self.sum = self.input1 ^ self.input2\n        self.carry = and_(self.input1, self.input2)"
        },
        {
            "key_id": 20,
            "fqn": "src/hardware/basic_components.py/FullAdder/__init__",
            "imports": [
                "from src.hardware.basic_components import HalfAdder"
            ],
            "code": "class FullAdder:\n    def __init__(self, input1: bool, input2: bool, carry_in: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.carry_in = carry_in\n        self.sum = None\n        self.carry_out = None\n\n    def calculate(self):\n        first_half = HalfAdder(self.input1, self.input2)\n        first_half.calculate()\n        second_half = HalfAdder(first_half.sum, self.carry_in)\n        second_half.calculate()\n        self.sum = second_half.sum\n        self.carry_out = first_half.carry or second_half.carry"
        },
        {
            "key_id": 23,
            "fqn": "src/hardware/basic_components.py/Adder/__init__",
            "imports": [
                "from src.hardware.basic_components import FullAdder"
            ],
            "code": "class Adder:\n    def __init__(self, input1: list[bool], input2: list[bool], carry_in: bool = False):\n        self.input1 = input1\n        self.input2 = input2\n        self.carry_in = carry_in\n        self.result = []\n        self.carry_out = False\n\n    def calculate(self):\n        carry = self.carry_in\n        for bit1, bit2 in zip(self.input1[::-1], self.input2[::-1]):\n            full_adder = FullAdder(bit1, bit2, carry)\n            full_adder.calculate()\n            self.result.insert(0, full_adder.sum)\n            carry = full_adder.carry_out\n        self.carry_out = carry"
        },
        {
            "key_id": 26,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/__init__",
            "imports": [
                "from src.hardware.gates import and_",
                "from src.hardware.gates import not_"
            ],
            "code": "class HalfSubtractor:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.diff = None\n        self.borrow = None\n\n    def calculate(self):\n        self.diff = self.input1 ^ self.input2\n        self.borrow = and_(not_(self.input1), self.input2)"
        },
        {
            "key_id": 29,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/__init__",
            "imports": [
                "from src.hardware.basic_components import HalfSubtractor"
            ],
            "code": "class FullSubtractor:\n    def __init__(self, input1: bool, input2: bool, borrow_in: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.borrow_in = borrow_in\n        self.diff = None\n        self.borrow_out = None\n\n    def calculate(self):\n        first_half = HalfSubtractor(self.input1, self.input2)\n        first_half.calculate()\n        second_half = HalfSubtractor(first_half.diff, self.borrow_in)\n        second_half.calculate()\n        self.diff = second_half.diff\n        self.borrow_out = first_half.borrow or second_half.borrow"
        },
        {
            "key_id": 32,
            "fqn": "src/hardware/basic_components.py/Subtractor/__init__",
            "imports": [],
            "code": "class Subtractor:\n    def __init__(self, input1: list[bool], input2: list[bool], borrow_in: bool = False):\n        self.input1 = input1\n        self.input2 = input2\n        self.borrow_in = borrow_in\n        self.output = []\n        self.borrow_out = False\n\n        for i in range(len(input1)):\n            fs = FullSubtractor(input1[i], input2[i], self.borrow_in if i == 0 else self.borrow_out)\n            self.output.append(fs.diff())\n            self.borrow_out = fs.borrow()\n\n        if len(input1) > len(input2):\n            for i in range(len(input2), len(input1)):\n                fs = FullSubtractor(input1[i], False, self.borrow_out)\n                self.output.append(fs.diff())\n                self.borrow_out = fs.borrow()"
        },
        {
            "key_id": 35,
            "fqn": "src/hardware/basic_components.py/Mux/__init__",
            "imports": [],
            "code": "class Mux:\n    def __init__(self, input1: bool, input2: bool, sel: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sel = sel\n\n    def output(self) -> bool:\n        return self.input2 if self.sel else self.input1"
        },
        {
            "key_id": 37,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/__init__",
            "imports": [],
            "code": "class Mux8Bit:\n    def __init__(self, input1: list[bool], input2: list[bool], sel: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sel = sel\n\n    def output(self) -> list[bool]:\n        return self.input2 if self.sel else self.input1"
        },
        {
            "key_id": 39,
            "fqn": "src/hardware/basic_components.py/AddSub/__init__",
            "imports": [],
            "code": "class AddSub:\n    def __init__(self, input1: list[bool], input2: list[bool], operation: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.operation = operation\n        self.output = []\n        self.overflow = False\n\n        if operation:  # If operation is True, perform addition\n            adder = Adder(input1, input2)\n            self.output = adder.sum()\n            self.overflow = adder.carry_out()\n        else:  # If operation is False, perform subtraction\n            subtractor = Subtractor(input1, input2)\n            self.output = subtractor.diff()\n            self.overflow = subtractor.borrow_out"
        },
        {
            "key_id": 43,
            "fqn": "src/hardware/basic_components.py/Decoder/__init__",
            "imports": [],
            "code": "class Decoder:\n    def __init__(self, input: list[bool]):\n        self.input = input\n        self.output = [False] * (2 ** len(input))\n\n        index = 0\n        for bit in reversed(input):\n            if bit:\n                index += 2 ** (len(input) - 1 - input.index(bit))\n        self.output[index] = True"
        },
        {
            "key_id": 45,
            "fqn": "src/hardware/basic_components.py/Control/__init__",
            "imports": [],
            "code": "class Control:\n    def __init__(self, input: list[bool]):\n        self.input = input\n        self.output = []\n\n    def process(self):\n        # Assuming a simple control logic for demonstration\n        self.output = [not bit for bit in self.input]\n        return self.output"
        },
        {
            "key_id": 47,
            "fqn": "src/hardware/basic_components.py/Comparison/__init__",
            "imports": [],
            "code": "class Comparison:\n    def __init__(self, control: list[bool], byte: list[bool]):\n        self.control = control\n        self.byte = byte\n\n    def compare(self):\n        # Example comparison logic\n        if self.control[0]:  # If MSB of control is True, check equality\n            return self.byte == [False] * len(self.byte)\n        else:\n            return self.byte != [False] * len(self.byte)"
        },
        {
            "key_id": 53,
            "fqn": "src/hardware/alu.py/ALU/__init__",
            "imports": [],
            "code": "class ALU:\n    def __init__(self, input1: list[bool], input2: list[bool], control1: bool, control2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.control1 = control1\n        self.control2 = control2\n\n    def operate(self):\n        # Example operation\n        if self.control1 and not self.control2:\n            # Perform AND operation\n            return [i and j for i, j in zip(self.input1, self.input2)]\n        elif not self.control1 and self.control2:\n            # Perform OR operation\n            return [i or j for i, j in zip(self.input1, self.input2)]"
        },
        {
            "key_id": 49,
            "fqn": "src/hardware/registers.py/Registers/__init__",
            "imports": [],
            "code": "class Registers:\n    def __init__(self):\n        self.registers = [[False] * 8 for _ in range(8)]  # Example: 8 registers of 8 bits\n\n    def read(self, register_id):\n        return self.registers[register_id]\n\n    def write(self, register_id, data):\n        self.registers[register_id] = data"
        },
        {
            "key_id": 66,
            "fqn": "src/hardware/cpu.py/CPU/__init__",
            "imports": [
                "from src.hardware.basic_components import Control",
                "from src.hardware.basic_components import Comparison",
                "from src.hardware.alu import ALU",
                "from src.hardware.registers import Registers"
            ],
            "code": "class CPU:\n    def __init__(self, program, verbose=True):\n        self.program = program\n        self.verbose = verbose\n        self.registers = Registers()\n        self.alu = ALU([], [], False, False)\n        self.control = Control([])\n        self.comparison = Comparison([], [])\n\n    def run(self, write_to_input=None, read_from_output=None):\n        # Example run logic\n        if write_to_input:\n            input_data = write_to_input()\n            print(f'Input: {input_data}')\n        if read_from_output:\n            output_data = [True, False, True]  # Example output\n            read_from_output(output_data)"
        },
        {
            "key_id": 68,
            "fqn": "src/hardware/cpu.py/Cycle/__init__",
            "imports": [],
            "code": "def __init__(self, cpu, program_instruction_byte):\n    self.cpu = cpu\n    self.program_instruction_byte = program_instruction_byte\n    self.current_operation = None\n    self.decode_instruction()\n\ndef decode_instruction(self):\n    # Assuming a method exists to decode the instruction byte\n    # This is a placeholder logic for decoding\n    opcode = self.program_instruction_byte[:4]\n    operand = self.program_instruction_byte[4:]\n    if opcode == [0,0,0,0]:  # Example opcode for 'NOP'\n        self.current_operation = self.cpu.nop\n    elif opcode == [1,0,0,0]:  # Example opcode for 'ADD'\n        self.current_operation = self.cpu.add\n    # Add more elif blocks for other opcodes\n    else:\n        raise ValueError('Unknown opcode')"
        },
        {
            "key_id": 8,
            "fqn": "src/games/maze.py/Robot/__init__",
            "imports": [
                "import pygame",
                "from pygame.locals import *"
            ],
            "code": "def __init__(self, initial_pos = [1,1], initial_dir = 'up', delay = 0):\n    self.position = initial_pos\n    self.direction = initial_dir\n    self.delay = delay\n    self.color = pygame.Color('blue')\n\n    # Initialize pygame components necessary for drawing\n    pygame.init()\n    self.screen = pygame.display.set_mode((800, 600))\n    pygame.display.set_caption('Maze Runner')\n\n    # Load maze layout\n    self.maze = self.load_maze()\n\n    # Set initial direction\n    self.directions = ['up', 'right', 'down', 'left']\n    self.current_direction_index = self.directions.index(initial_dir)\n\n    # Load robot image or representation\n    self.robot_image = pygame.image.load('robot.png')\n    self.robot_image = pygame.transform.scale(self.robot_image, (50, 50))\n\ndef load_maze(self):\n    # Placeholder for maze loading logic\n    return [\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        # More rows here\n    ]"
        },
        {
            "key_id": 59,
            "fqn": "src/hardware/gates.py/and_",
            "imports": [],
            "code": "def and_(*args) -> int:\n    result = 1\n    for arg in args:\n        result &= arg\n    return result"
        },
        {
            "key_id": 60,
            "fqn": "src/hardware/gates.py/or_",
            "imports": [],
            "code": "def or_(*args) -> int:\n    result = 0\n    for arg in args:\n        result |= arg\n    return result"
        },
        {
            "key_id": 61,
            "fqn": "src/hardware/gates.py/not_",
            "imports": [],
            "code": "def not_(*args) -> int:\n    # Assuming only one argument for NOT operation\n    if args:\n        return ~args[0] & 1\n    else:\n        raise ValueError('No argument provided for NOT operation')"
        },
        {
            "key_id": 62,
            "fqn": "src/hardware/gates.py/nor",
            "imports": [],
            "code": "def nor(*args) -> int:\n    result = 0\n    for arg in args:\n        result |= arg\n    return ~result & 1"
        },
        {
            "key_id": 63,
            "fqn": "src/hardware/gates.py/nand",
            "imports": [],
            "code": "def nand(*args) -> int:\n    result = 1\n    for arg in args:\n        result &= arg\n    return ~result & 1"
        },
        {
            "key_id": 64,
            "fqn": "src/hardware/gates.py/xor",
            "imports": [],
            "code": "def xor(a: bool, b: bool) -> int:\n    return int(a != b)"
        },
        {
            "key_id": 65,
            "fqn": "src/hardware/gates.py/xnor",
            "imports": [],
            "code": "def xnor(a: bool, b: bool) -> int:\n    return int(a == b)"
        },
        {
            "key_id": 18,
            "fqn": "src/hardware/basic_components.py/HalfAdder/sum",
            "imports": [
                "from src.hardware.gates import and_, xor"
            ],
            "code": "def sum(self) -> bool:\n    self.calculate()\n    return self.sum"
        },
        {
            "key_id": 19,
            "fqn": "src/hardware/basic_components.py/HalfAdder/carry",
            "imports": [
                "from src.hardware.gates import and_"
            ],
            "code": "def carry(self) -> bool:\n    self.calculate()\n    return self.carry"
        },
        {
            "key_id": 21,
            "fqn": "src/hardware/basic_components.py/FullAdder/sum",
            "imports": [
                "from src.hardware.basic_components import HalfAdder"
            ],
            "code": "def sum(self):\n    self.calculate()\n    return self.sum"
        },
        {
            "key_id": 22,
            "fqn": "src/hardware/basic_components.py/FullAdder/carry",
            "imports": [],
            "code": "def carry(self):\n        # Utilize the HalfAdder class to calculate the carry out of a FullAdder\n        first_half = HalfAdder(self.input1, self.input2)\n        first_half.calculate()\n        second_half = HalfAdder(first_half.sum, self.carry_in)\n        second_half.calculate()\n        # The carry out is true if either half adder produces a carry\n        self.carry_out = first_half.carry or second_half.carry\n        return self.carry_out"
        },
        {
            "key_id": 24,
            "fqn": "src/hardware/basic_components.py/Adder/sum",
            "imports": [
                "from .basic_components import FullAdder"
            ],
            "code": "def sum(self):\n        # Initialize the carry for the first addition\n        carry = self.carry_in\n        # Iterate over each bit in reverse order (LSB to MSB)\n        for bit1, bit2 in zip(self.input1[::-1], self.input2[::-1]):\n            full_adder = FullAdder(bit1, bit2, carry)\n            full_adder.calculate()\n            # Insert the sum at the beginning of the result list\n            self.result.insert(0, full_adder.sum)\n            # Update carry for the next iteration\n            carry = full_adder.carry_out\n        return self.result"
        },
        {
            "key_id": 25,
            "fqn": "src/hardware/basic_components.py/Adder/carry_out",
            "imports": [],
            "code": "def carry_out(self):\n        # The carry out of the adder is the carry of the last addition\n        return self.carry_out"
        },
        {
            "key_id": 27,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/diff",
            "imports": [
                "from .gates import and_, not_"
            ],
            "code": "def diff(self):\n        # The difference is calculated as the XOR of the two inputs\n        self.diff = self.input1 ^ self.input2\n        return self.diff"
        },
        {
            "key_id": 28,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/borrow",
            "imports": [
                "from .gates import and_, not_"
            ],
            "code": "def borrow(self):\n        # The borrow occurs if the subtractor needs to borrow from a higher bit\n        self.borrow = and_(not_(self.input1), self.input2)\n        return self.borrow"
        },
        {
            "key_id": 30,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/diff",
            "imports": [],
            "code": "def diff(self):\n        first_half = HalfSubtractor(self.input1, self.input2)\n        first_half.calculate()\n        second_half = HalfSubtractor(first_half.diff, self.borrow_in)\n        second_half.calculate()\n        self.diff = second_half.diff\n        return self.diff"
        },
        {
            "key_id": 31,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/borrow",
            "imports": [],
            "code": "def borrow(self):\n        first_half = HalfSubtractor(self.input1, self.input2)\n        first_half.calculate()\n        second_half = HalfSubtractor(first_half.diff, self.borrow_in)\n        second_half.calculate()\n        self.borrow_out = first_half.borrow or second_half.borrow\n        return self.borrow_out"
        },
        {
            "key_id": 33,
            "fqn": "src/hardware/basic_components.py/Subtractor/diff",
            "imports": [],
            "code": "def diff(self) -> list[bool]:\n        self.output = []\n        for i in range(len(self.input1)):\n            fs = FullSubtractor(self.input1[i], self.input2[i], self.borrow_in if i == 0 else self.borrow_out)\n            fs.calculate()\n            self.output.append(fs.diff)\n            self.borrow_out = fs.borrow_out\n\n        if len(self.input1) > len(self.input2):\n            for i in range(len(self.input2), len(self.input1)):\n                fs = FullSubtractor(self.input1[i], False, self.borrow_out)\n                fs.calculate()\n                self.output.append(fs.diff)\n                self.borrow_out = fs.borrow_out\n        return self.output"
        },
        {
            "key_id": 34,
            "fqn": "src/hardware/basic_components.py/Subtractor/borrow_out",
            "imports": [],
            "code": "def borrow_out(self) -> bool:\n        return self.borrow_out"
        },
        {
            "key_id": 36,
            "fqn": "src/hardware/basic_components.py/Mux/output",
            "imports": [],
            "code": "def output(self) -> bool:\n        return self.input2 if self.sel else self.input1"
        },
        {
            "key_id": 38,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n        return [self.input2[i] if self.sel else self.input1[i] for i in range(len(self.input1))]"
        },
        {
            "key_id": 40,
            "fqn": "src/hardware/basic_components.py/AddSub/output",
            "imports": [
                "from src.hardware.basic_components import Adder",
                "from src.hardware.basic_components import Subtractor"
            ],
            "code": "def output(self) -> list[bool]:\n        if self.operation:  # If operation is True, perform addition\n            adder = Adder(self.input1, self.input2)\n            self.output = adder.sum()\n            self.overflow = adder.carry_out()\n        else:  # If operation is False, perform subtraction\n            subtractor = Subtractor(self.input1, self.input2)\n            self.output = subtractor.diff()\n            self.overflow = subtractor.borrow_out()\n        return self.output"
        },
        {
            "key_id": 41,
            "fqn": "src/hardware/basic_components.py/AddSub/overflow",
            "imports": [],
            "code": "def overflow(self) -> bool:\n        return self.overflow"
        },
        {
            "key_id": 42,
            "fqn": "src/hardware/basic_components.py/AddSub/borrow_out",
            "imports": [],
            "code": "def borrow_out(self) -> bool:\n        return self.overflow"
        },
        {
            "key_id": 44,
            "fqn": "src/hardware/basic_components.py/Decoder/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n        index = 0\n        for i, bit in enumerate(reversed(self.input)):\n            if bit:\n                index += 2 ** i\n        self.output = [False] * (2 ** len(self.input))\n        self.output[index] = True\n        return self.output"
        },
        {
            "key_id": 46,
            "fqn": "src/hardware/basic_components.py/Control/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n        # Assuming a simple control logic for demonstration\n        self.output = [not bit for bit in self.input]\n        return self.output"
        },
        {
            "key_id": 48,
            "fqn": "src/hardware/basic_components.py/Comparison/out",
            "imports": [],
            "code": "def out(self) -> bool:\n        # Example comparison logic\n        if self.control[0]:  # If MSB of control is True, check equality\n            return self.byte == [False] * len(self.byte)\n        else:\n            return self.byte != [False] * len(self.byte)"
        },
        {
            "key_id": 54,
            "fqn": "src/hardware/alu.py/ALU/out",
            "imports": [],
            "code": "def out(self):\n        # Example operation\n        if self.control1 and not self.control2:\n            # Perform AND operation\n            return [i and j for i, j in zip(self.input1, self.input2)]\n        elif not self.control1 and self.control2:\n            # Perform OR operation\n            return [i or j for i, j in zip(self.input1, self.input2)]"
        },
        {
            "key_id": 55,
            "fqn": "src/hardware/alu.py/ALU/zero",
            "imports": [],
            "code": "def zero(self):\n        # Check if all output bits are False\n        return all(not bit for bit in self.operate())"
        },
        {
            "key_id": 56,
            "fqn": "src/hardware/alu.py/ALU/negative",
            "imports": [],
            "code": "def negative(self):\n        # Check if the MSB (most significant bit) is True, indicating a negative number in two's complement\n        return self.operate()[0]"
        },
        {
            "key_id": 57,
            "fqn": "src/hardware/alu.py/ALU/overflow",
            "imports": [],
            "code": "def overflow(self):\n    # Assuming 8-bit signed integer range -128 to 127\n    result = self.operate()\n    # Convert binary to integer\n    result_int = int(''.join(str(int(b)) for b in result), 2)\n    # Check if result is outside the 8-bit signed integer range\n    if result_int > 127 or result_int < -128:\n        return True\n    return False"
        },
        {
            "key_id": 58,
            "fqn": "src/hardware/alu.py/ALU/carry_out",
            "imports": [],
            "code": "def carry_out(self):\n    # This method checks for carry out during subtraction\n    # Assuming 8-bit unsigned integer range 0 to 255\n    result = self.operate()\n    # Convert binary to integer\n    result_int = int(''.join(str(int(b)) for b in result), 2)\n    # Check if subtraction result is negative, indicating a borrow\n    if result_int < 0:\n        return True\n    return False"
        },
        {
            "key_id": 50,
            "fqn": "src/hardware/registers.py/Registers/read",
            "imports": [],
            "code": "def read(self, register_id):\n    if register_id < 0 or register_id >= len(self.registers):\n        raise ValueError('Register ID out of range')\n    return self.registers[register_id]"
        },
        {
            "key_id": 51,
            "fqn": "src/hardware/registers.py/Registers/write",
            "imports": [],
            "code": "def write(self, register_id, data):\n    if register_id < 0 or register_id >= len(self.registers):\n        raise ValueError('Register ID out of range')\n    if not all(isinstance(bit, bool) for bit in data):\n        raise ValueError('Data must be a list of boolean values')\n    if len(data) != 8:\n        raise ValueError('Data must be 8 bits long')\n    self.registers[register_id] = data"
        },
        {
            "key_id": 52,
            "fqn": "src/hardware/registers.py/Registers/write_to_register",
            "imports": [],
            "code": "def write_to_register(self, register, data):\n    # Validate register\n    if not (0 <= register < len(self.registers)):\n        raise ValueError('Invalid register index')\n    # Validate data length\n    if len(data) != 8:\n        raise ValueError('Data must be 8 bits long')\n    self.write(register, data)"
        },
        {
            "key_id": 2,
            "fqn": "src/assembler.py/get_labels",
            "imports": [
                "re"
            ],
            "code": "def get_labels(file) -> dict:\n    labels = {}\n    pc = 0\n    with open(file, 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line.endswith(':'):\n                label = line[:-1]\n                labels[label] = pc\n            else:\n                if line and not line.startswith('#'):\n                    pc += 1\n    return labels"
        },
        {
            "key_id": 3,
            "fqn": "src/assembler.py/immediate_values",
            "imports": [],
            "code": "def immediate_values(line, labels):\n    parts = line.split()\n    if parts[0] in labels:\n        return labels[parts[0]]\n    try:\n        return int(parts[0])\n    except ValueError:\n        return None"
        },
        {
            "key_id": 4,
            "fqn": "src/assembler.py/copy_instructions",
            "imports": [],
            "code": "def copy_instructions(line):\n    parts = line.split()\n    if parts[0] == 'copy':\n        src = int(parts[1])\n        dest = int(parts[2])\n        return {'op': 'copy', 'src': src, 'dest': dest}\n    return None"
        },
        {
            "key_id": 5,
            "fqn": "src/assembler.py/operate_instructions",
            "imports": [],
            "code": "def operate_instructions(line):\n    operations = {'add': 0, 'sub': 1, 'and': 2, 'or': 3}\n    parts = line.split()\n    if parts[0] in operations:\n        return {'op': parts[0]}\n    return None"
        },
        {
            "key_id": 6,
            "fqn": "src/assembler.py/jump_instructions",
            "imports": [],
            "code": "def jump_instructions(line):\n    conditions = {'always': 0, 'never': 1, '==': 2, '!=': 3, '<': 4, '<=': 5, '>': 6, '>=': 7}\n    parts = line.split()\n    if parts[0] == 'eval':\n        condition = parts[1]\n        if condition in conditions:\n            return {'op': 'eval', 'condition': conditions[condition]}\n    return None"
        },
        {
            "key_id": 7,
            "fqn": "src/assembler.py/assemble_binary",
            "imports": [
                "from .get_labels import get_labels",
                "from .immediate_values import immediate_values",
                "from .copy_instructions import copy_instructions",
                "from .operate_instructions import operate_instructions",
                "from .jump_instructions import jump_instructions"
            ],
            "code": "def assemble_binary(filename: str):\n    labels = get_labels(filename)\n    binary_program = []\n    with open(filename, 'r') as file:\n        for line in file:\n            line = line.strip()\n            if not line or line.startswith('#'): continue\n            if line in labels:\n                continue\n            if any(line.startswith(op) for op in ['add', 'sub', 'and', 'or']):\n                binary_program.extend(operate_instructions(line))\n            elif any(line.startswith(op) for op in ['copy']):\n                binary_program.extend(copy_instructions(line))\n            elif any(line.startswith(op) for op in ['eval']):\n                binary_program.extend(jump_instructions(line, labels))\n            else:\n                binary_program.extend(immediate_values(line, labels))\n    return binary_program"
        },
        {
            "key_id": 67,
            "fqn": "src/hardware/cpu.py/CPU/run",
            "imports": [
                "from .registers import Registers",
                "from .alu import ALU",
                "from .control import Control",
                "from .comparison import Comparison"
            ],
            "code": "class CPU:\n    def __init__(self, program, verbose=True):\n        self.program = program\n        self.verbose = verbose\n        self.registers = Registers()\n        self.alu = ALU([], [], False, False)\n        self.control = Control([])\n        self.comparison = Comparison([], [])\n\n    def run(self, write_to_input=None, read_from_output=None):\n        # Example run logic\n        if write_to_input:\n            input_data = write_to_input()\n            print(f'Input: {input_data}')\n        if read_from_output:\n            output_data = [True, False, True]  # Example output\n            read_from_output(output_data)"
        },
        {
            "key_id": 69,
            "fqn": "src/hardware/cpu.py/Cycle/execute",
            "imports": [],
            "code": "def __init__(self, cpu, program_instruction_byte):\n    self.cpu = cpu\n    self.program_instruction_byte = program_instruction_byte\n    self.current_operation = None\n    self.decode_instruction()\n\ndef decode_instruction(self):\n    # Assuming a method exists to decode the instruction byte\n    # This is a placeholder logic for decoding\n    opcode = self.program_instruction_byte[:4]\n    operand = self.program_instruction_byte[4:]\n    if opcode == [0,0,0,0]:  # Example opcode for 'NOP'\n        self.current_operation = self.cpu.nop\n    elif opcode == [1,0,0,0]:  # Example opcode for 'ADD'\n        self.current_operation = self.cpu.add\n    # Add more elif blocks for other opcodes\n    else:\n        raise ValueError('Unknown opcode')"
        },
        {
            "key_id": 0,
            "fqn": "src/run.py/write_to_input",
            "imports": [],
            "code": "def write_to_input():\n    # Example input function\n    return [0,0,0,0,0,0,0,1]"
        },
        {
            "key_id": 1,
            "fqn": "src/run.py/read_from_output",
            "imports": [],
            "code": "def read_from_output(value):\n    if value != [0,0,0,0,0,0,0,0]: # CPU always returns 0 by default\n        print('result:', value)"
        },
        {
            "key_id": 9,
            "fqn": "src/games/maze.py/Robot/event_check",
            "imports": [
                "import pygame",
                "from pygame.locals import KEYDOWN, K_LEFT, K_RIGHT, K_UP, K_DOWN"
            ],
            "code": "def event_check(self):\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            quit()\n        elif event.type == KEYDOWN:\n            if event.key == K_LEFT:\n                self.turn_left()\n            elif event.key == K_RIGHT:\n                self.turn_right()\n            elif event.key == K_UP:\n                self.move_forward()\n            elif event.key == K_DOWN:\n                pass  # Optionally, implement a move_backward method or similar behavior"
        },
        {
            "key_id": 10,
            "fqn": "src/games/maze.py/Robot/move_forward",
            "imports": [],
            "code": "def move_forward(self):\n    if self.direction == 'up':\n        self.position[1] -= 1\n    elif self.direction == 'down':\n        self.position[1] += 1\n    elif self.direction == 'left':\n        self.position[0] -= 1\n    elif self.direction == 'right':\n        self.position[0] += 1\n    self.check_collision()"
        },
        {
            "key_id": 11,
            "fqn": "src/games/maze.py/Robot/turn_left",
            "imports": [],
            "code": "def turn_left(self):\n    self.current_direction_index = (self.current_direction_index - 1) % 4\n    self.direction = self.directions[self.current_direction_index]"
        },
        {
            "key_id": 12,
            "fqn": "src/games/maze.py/Robot/turn_right",
            "imports": [],
            "code": "def turn_right(self):\n    self.current_direction_index = (self.current_direction_index + 1) % 4\n    self.direction = self.directions[self.current_direction_index]"
        },
        {
            "key_id": 13,
            "fqn": "src/games/maze.py/Robot/move",
            "imports": [],
            "code": "def move(self, instruction):\n    if instruction == 'forward':\n        self.move_forward()\n    elif instruction == 'left':\n        self.turn_left()\n    elif instruction == 'right':\n        self.turn_right()\n    else:\n        print('Unknown instruction:', instruction)"
        },
        {
            "key_id": 14,
            "fqn": "src/games/maze.py/Robot/get_front_cell",
            "imports": [
                "import pygame"
            ],
            "code": "def get_front_cell(self):\n    x, y = self.position\n    if self.direction == 'up':\n        y -= 1\n    elif self.direction == 'down':\n        y += 1\n    elif self.direction == 'left':\n        x -= 1\n    elif self.direction == 'right':\n        x += 1\n    if x < 0 or y < 0 or x >= len(self.maze[0]) or y >= len(self.maze):\n        return 1  # Wall\n    return self.maze[y][x]"
        },
        {
            "key_id": 15,
            "fqn": "src/games/maze.py/Robot/get_front_cell_bit",
            "imports": [
                "import pygame"
            ],
            "code": "def get_front_cell_bit(self):\n    front_cell = self.get_front_cell()\n    if front_cell == 1:  # Wall\n        return [0,0,0,0,0,0,0,1]\n    else:  # Path\n        return [0,0,0,0,0,0,0,0]"
        },
        {
            "key_id": 16,
            "fqn": "src/games/maze.py/draw",
            "imports": [
                "import pygame"
            ],
            "code": "def draw(robot):\n    robot.screen.fill((0, 0, 0))\n    for y, row in enumerate(robot.maze):\n        for x, cell in enumerate(row):\n            color = (255, 255, 255) if cell == 0 else (0, 0, 0)\n            pygame.draw.rect(robot.screen, color, pygame.Rect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE))\n    robot_position = (robot.position[0]*CELL_SIZE, robot.position[1]*CELL_SIZE)\n    robot.screen.blit(robot.robot_image, robot_position)\n    pygame.display.update()"
        }
    ]
}