{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "translategram/translategram/translator_services.py/MtranslateTranslatorService/__init__",
            "imports": [
                "import mtranslate"
            ],
            "code": "class MtranslateTranslatorService:\n    def __init__(self) -> None:\n        try:\n            import mtranslate\n        except ImportError as e:\n            raise ImportError('The mtranslate package is required for MtranslateTranslatorService but is not installed.') from e\n        self.service = mtranslate"
        },
        {
            "key_id": 1,
            "fqn": "translategram/translategram/cache.py/PickleCache/__init__",
            "imports": [
                "import pickle",
                "from pathlib import Path"
            ],
            "code": "class PickleCache:\n    def __init__(self, obj: object, filename: str = 'translation.data') -> None:\n        self.obj = obj\n        self.filename = filename\n        self._save()\n\n    def _save(self):\n        with open(self.filename, 'wb') as file:\n            pickle.dump(self.obj, file)\n\n    def load(self):\n        if Path(self.filename).exists():\n            with open(self.filename, 'rb') as file:\n                return pickle.load(file)\n        return None"
        },
        {
            "key_id": 3,
            "fqn": "translategram/translategram/translator.py/Translator/__init__",
            "imports": [
                "from typing import Type, Union",
                "from .cache import Cache",
                "from .translator_services import TranslatorService"
            ],
            "code": "class Translator:\n    def __init__(self, translator_service: TranslatorService, cache_system: Union[Type[Cache], None] = None) -> None:\n        self.translator_service = translator_service\n        self.cache_system = cache_system if cache_system is not None else None"
        },
        {
            "key_id": 6,
            "fqn": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/__init__",
            "imports": [
                "from typing import Type, Union",
                "from asyncio import iscoroutinefunction",
                "from translategram.translator import Translator",
                "from translategram.cache import Cache",
                "from translategram.translator_services import TranslatorService"
            ],
            "code": "class PythonTelegramBotAdapter:\n    def __init__(self, translator_service: Type[TranslatorService], cache_system: Union[Type[Cache], None] = None) -> None:\n        self.translator_service = translator_service()\n        self.cache_system = cache_system() if cache_system is not None else None\n\n    async def translate_message(self, message: str, source_lang: str = 'auto', target_lang: str = 'en') -> str:\n        if self.cache_system:\n            cached_msg = self.cache_system.load(message + '_' + source_lang + '_' + target_lang)\n            if cached_msg:\n                return cached_msg\n        translated_msg = self.translator_service.translate(message, from_language=source_lang, to_language=target_lang)\n        if iscoroutinefunction(translated_msg):\n            translated_msg = await translated_msg\n        if self.cache_system:\n            self.cache_system.save(translated_msg, message + '_' + source_lang + '_' + target_lang)\n        return translated_msg"
        },
        {
            "key_id": 2,
            "fqn": "translategram/translategram/cache.py/PickleCache/__del__",
            "imports": [
                "import os",
                "from pathlib import Path"
            ],
            "code": "class PickleCache:\n    def __init__(self, obj: object, filename: str = 'translation.data') -> None:\n        self.obj = obj\n        self.filename = filename\n        self._save()\n\n    def _save(self):\n        with open(self.filename, 'wb') as file:\n            pickle.dump(self.obj, file)\n\n    def load(self):\n        if Path(self.filename).exists():\n            with open(self.filename, 'rb') as file:\n                return pickle.load(file)\n        return None\n\n    def __del__(self):\n        if Path(self.filename).exists():\n            os.remove(self.filename)"
        },
        {
            "key_id": 4,
            "fqn": "translategram/translategram/translator.py/Translator/handler_translator",
            "imports": [
                "from typing import Callable, Coroutine, Any",
                "from functools import wraps"
            ],
            "code": "class Translator:\n    def __init__(self, translator_service: TranslatorService, cache_system: Union[Type[Cache], None] = None) -> None:\n        self.translator_service = translator_service\n        self.cache_system = cache_system if cache_system is not None else None\n\n    def handler_translator(self, message: str, source_lang: str) -> Callable[[Callable[..., object]], Callable[[Any, Any, str], Coroutine[Any, Any, Any]]]:\n        @wraps(func)\n        async def wrapper(update: Any, context: Any, *args, **kwargs):\n            user_lang = update.effective_user.language_code if update.effective_user else 'en'\n            translated_message = await self.translator_service.translate(message, source_lang, user_lang)\n            return await func(update, context, translated_message, *args, **kwargs)\n        return wrapper"
        },
        {
            "key_id": 5,
            "fqn": "translategram/translategram/translator.py/Translator/dynamic_handler_translator",
            "imports": [
                "from typing import Callable, Coroutine, Any",
                "from functools import wraps"
            ],
            "code": "class Translator:\n    def __init__(self, translator_service: TranslatorService, cache_system: Union[Type[Cache], None] = None) -> None:\n        self.translator_service = translator_service\n        self.cache_system = cache_system if cache_system is not None else None\n\n    def dynamic_handler_translator(self, message_func: Callable[[str, Any], str], source_lang: str = 'auto') -> Callable[[Callable[..., object]], Callable[[Any, Any], Coroutine[Any, Any, Any]]]:\n        @wraps(func)\n        async def wrapper(update: Any, context: Any, *args, **kwargs):\n            user_lang = update.effective_user.language_code if update.effective_user else 'en'\n            original_message = message_func(*args, **kwargs)\n            translated_message = await self.translator_service.translate(original_message, source_lang, user_lang)\n            return await func(update, context, translated_message, *args, **kwargs)\n        return wrapper"
        },
        {
            "key_id": 7,
            "fqn": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/handler_translator",
            "imports": [
                "from typing import Callable, Coroutine, Any",
                "from functools import wraps",
                "from telegram import Update",
                "from telegram.ext import CallbackContext"
            ],
            "code": "class PythonTelegramBotAdapter:\n    def __init__(self, translator_service: Type[TranslatorService], cache_system: Union[Type[Cache], None] = None) -> None:\n        self.translator_service = translator_service()\n        self.cache_system = cache_system() if cache_system is not None else None\n\n    def handler_translator(self, message: str, source_lang: str = 'auto') -> Callable[[Callable[[Any, Any, str], object]], Callable[[Any, Any, str], Coroutine[Any, Any, Any]]]:\n        @wraps(func)\n        async def wrapper(update: Update, context: CallbackContext, *args, **kwargs):\n            user_lang = update.effective_user.language_code if update.effective_user else 'en'\n            if self.cache_system:\n                translated_message = self.cache_system.load(f'{func.__name__}_{user_lang}')\n            if not translated_message:\n                translated_message = await self.translator_service.translate(message, source_lang, user_lang)\n                if self.cache_system:\n                    self.cache_system.save(translated_message, f'{func.__name__}_{user_lang}')\n            await func(update, context, translated_message, *args, **kwargs)\n        return wrapper"
        },
        {
            "key_id": 8,
            "fqn": "translategram/python_telegram_bot_translator/adapter.py/PythonTelegramBotAdapter/dynamic_handler_translator",
            "imports": [
                "from typing import Callable, Coroutine, Any",
                "from functools import wraps",
                "from telegram import Update",
                "from telegram.ext import CallbackContext"
            ],
            "code": "class PythonTelegramBotAdapter:\n    def __init__(self, translator_service: Type[TranslatorService], cache_system: Union[Type[Cache], None] = None) -> None:\n        self.translator_service = translator_service()\n        self.cache_system = cache_system() if cache_system is not None else None\n\n    def dynamic_handler_translator(self, message_func: Callable[[str, Any], str], source_lang: str = 'auto') -> Callable[[Callable[..., object]], Callable[[Any, Any], Coroutine[Any, Any, Any]]]:\n        @wraps(func)\n        async def wrapper(update: Update, context: CallbackContext, *args, **kwargs):\n            user_lang = update.effective_user.language_code if update.effective_user else 'en'\n            original_message = message_func(*args, **kwargs)\n            if self.cache_system:\n                translated_message = self.cache_system.load(f'{func.__name__}_{user_lang}')\n            if not translated_message:\n                translated_message = await self.translator_service.translate(original_message, source_lang, user_lang)\n                if self.cache_system:\n                    self.cache_system.save(translated_message, f'{func.__name__}_{user_lang}')\n            await func(update, context, translated_message, *args, **kwargs)\n        return wrapper"
        }
    ]
}