{
    "implementation": [
        {
            "key_id": 3,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/__init__",
            "imports": [
                "from typing import Union",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.core.module import Module",
                "from nest.core.module_compiler import ModuleCompiler"
            ],
            "code": "def __init__(self, container: PyNestContainer, context_module: Union[Module, None] = None):\n    self._container = container\n    self._context_module = context_module\n    self._is_initialized = False\n    self._module_compiler = ModuleCompiler()\n\n    if context_module is not None:\n        self.init()"
        },
        {
            "key_id": 9,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/__init__",
            "imports": [
                "from typing import Dict, Type"
            ],
            "code": "def __init__(self):\n    self._instances: Dict[Type, object] = {}\n    self._dependencies: Dict[str, Type] = {}"
        },
        {
            "key_id": 30,
            "fqn": "nest/core/pynest_application.py/PyNestApp/__init__",
            "imports": [
                "from fastapi import FastAPI",
                "from nest.core.pynest_container import PyNestContainer"
            ],
            "code": "def __init__(self, container: PyNestContainer, http_server: FastAPI):\n    self._container = container\n    self._http_server = http_server\n    self._is_listening = False\n\n    self.register_routes()"
        },
        {
            "key_id": 55,
            "fqn": "nest/core/decorators/module.py/Module/__init__",
            "imports": [
                "from typing import Optional, List, Type"
            ],
            "code": "def __init__(self, imports: Optional[List[Type]] = None, controllers: Optional[List[Type]] = None, providers: Optional[List[Type]] = None, exports: Optional[List[Type]] = None, is_global: bool = False):\n    self.imports = imports or []\n    self.controllers = controllers or []\n    self.providers = providers or []\n    self.exports = exports or []\n    self.is_global = is_global"
        },
        {
            "key_id": 63,
            "fqn": "nest/core/database/base_config.py/ConfigFactoryBase/__init__",
            "imports": [],
            "code": "def __init__(self, db_type: str):\n    self.db_type = db_type\n    self.config = None\n\n    def get_config(self):\n        if self.config is None:\n            raise NotImplementedError('You must implement the get_config method')\n        return self.config"
        },
        {
            "key_id": 66,
            "fqn": "nest/core/database/base_config.py/BaseProvider/__init__",
            "imports": [
                "from typing import Optional"
            ],
            "code": "class BaseProvider:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.config_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        raise NotImplementedError('Subclasses must implement this method to return the correct engine URL.')"
        },
        {
            "key_id": 68,
            "fqn": "nest/core/database/odm_provider.py/OdmProvider/__init__",
            "imports": [
                "from motor.motor_asyncio import AsyncIOMotorClient",
                "from beanie import Document",
                "from typing import List, Optional, Dict"
            ],
            "code": "class OdmProvider:\n    def __init__(self, db_type: str = 'mongodb', config_params: Optional[Dict] = None, document_models: Optional[List[Document]] = None):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.document_models = document_models or []\n        self.client = None\n        self.config_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        return f'mongodb://{self.config_params['host']}:{self.config_params['port']}'\n\n    def check_document_models(self):\n        if not self.document_models:\n            raise ValueError('No document models provided')"
        },
        {
            "key_id": 70,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from typing import Optional, Dict"
            ],
            "code": "class BaseOrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: Optional[Dict] = None, async_mode: bool = False, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.async_mode = async_mode\n        self.engine = self.create_engine()\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession if self.async_mode else None)\n\n    def create_engine(self):\n        if self.async_mode:\n            return create_async_engine(self.get_engine_url(), echo=True, future=True)\n        else:\n            raise NotImplementedError('Synchronous mode not implemented.')\n\n    def get_engine_url(self) -> str:\n        return f'{self.db_type}://{self.config_params['user']}:{self.config_params['password']}@{self.config_params['host']}:{self.config_params['port']}/{self.config_params['db_name']}'"
        },
        {
            "key_id": 74,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/__init__",
            "imports": [
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy import create_engine",
                "from typing import Optional, Dict"
            ],
            "code": "class OrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: Optional[Dict] = None):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.engine = create_engine(self.get_engine_url())\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)\n\n    def get_engine_url(self) -> str:\n        return f'{self.db_type}://{self.config_params['user']}:{self.config_params['password']}@{self.config_params['host']}:{self.config_params['port']}/{self.config_params['db_name']}'"
        },
        {
            "key_id": 78,
            "fqn": "nest/core/database/orm_provider.py/AsyncOrmProvider/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession",
                "from sqlalchemy.orm import sessionmaker",
                "from typing import Optional, Dict"
            ],
            "code": "class AsyncOrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: Optional[Dict] = None, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.engine = create_async_engine(self.get_engine_url(), echo=True, future=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    def get_engine_url(self) -> str:\n        return f'{self.db_type}://{self.config_params['user']}:{self.config_params['password']}@{self.config_params['host']}:{self.config_params['port']}/{self.config_params['db_name']}'"
        },
        {
            "key_id": 79,
            "fqn": "nest/core/database/odm_config.py/MongoDBConfig/__init__",
            "imports": [
                "from pymongo import MongoClient"
            ],
            "code": "class MongoDBConfig:\n    def __init__(self, host: str, db_name: str, user: str = None, password: str = None, port: int = 27017, srv: bool = False):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.srv = srv\n        self.client = None\n\n    def connect(self):\n        try:\n            connection_string = f'mongodb+srv://{self.user}:{self.password}@{self.host}/{self.db_name}' if self.srv else f'mongodb://{self.user}:{self.password}@{self.host}:{self.port}'\n            self.client = MongoClient(connection_string)\n            print('MongoDB connection successful.')\n        except Exception as e:\n            print(f'Error connecting to MongoDB: {e}')"
        },
        {
            "key_id": 81,
            "fqn": "nest/core/database/odm_config.py/ConfigFactory/__init__",
            "imports": [],
            "code": "class ConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n\n    def get_config(self):\n        if self.db_type == 'mongodb':\n            return MongoDBConfig\n        else:\n            raise ValueError(f'Unsupported database type: {self.db_type}')"
        },
        {
            "key_id": 83,
            "fqn": "nest/core/database/orm_config.py/PostgresConfig/__init__",
            "imports": [
                "from sqlalchemy import create_engine"
            ],
            "code": "class PostgresConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine = None\n\n    def create_engine(self):\n        self.engine = create_engine(f'postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}')\n        print('PostgreSQL engine created successfully.')"
        },
        {
            "key_id": 85,
            "fqn": "nest/core/database/orm_config.py/MySQLConfig/__init__",
            "imports": [
                "from sqlalchemy import create_engine"
            ],
            "code": "class MySQLConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine = None\n\n    def create_engine(self):\n        self.engine = create_engine(f'mysql+pymysql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}')\n        print('MySQL engine created successfully.')"
        },
        {
            "key_id": 87,
            "fqn": "nest/core/database/orm_config.py/SQLiteConfig/__init__",
            "imports": [
                "from sqlalchemy import create_engine"
            ],
            "code": "class SQLiteConfig:\n    def __init__(self, db_name: str):\n        self.db_name = db_name\n        self.engine = None\n\n    def create_engine(self):\n        self.engine = create_engine(f'sqlite:///{self.db_name}')\n        print('SQLite engine created successfully.')"
        },
        {
            "key_id": 89,
            "fqn": "nest/core/database/orm_config.py/AsyncSQLiteConfig/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker"
            ],
            "code": "class AsyncSQLiteConfig:\n    def __init__(self, db_name: str):\n        self.db_name = db_name\n        self.engine_url = f'sqlite+aiosqlite:///{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)"
        },
        {
            "key_id": 91,
            "fqn": "nest/core/database/orm_config.py/AsyncPostgresConfig/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncPostgresConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine_url = f'postgresql+asyncpg://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)"
        },
        {
            "key_id": 93,
            "fqn": "nest/core/database/orm_config.py/AsyncMySQLConfig/__init__",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncMySQLConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine_url = f'mysql+aiomysql://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)"
        },
        {
            "key_id": 95,
            "fqn": "nest/core/database/orm_config.py/ConfigFactory/__init__",
            "imports": [
                "from .orm_config import AsyncSQLiteConfig, AsyncPostgresConfig, AsyncMySQLConfig"
            ],
            "code": "class ConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n        self.config = None\n        if db_type == 'sqlite':\n            self.config = AsyncSQLiteConfig\n        elif db_type == 'postgresql':\n            self.config = AsyncPostgresConfig\n        elif db_type == 'mysql':\n            self.config = AsyncMySQLConfig\n        else:\n            raise ValueError(f'Unsupported database type: {db_type}')"
        },
        {
            "key_id": 97,
            "fqn": "nest/core/database/orm_config.py/AsyncConfigFactory/__init__",
            "imports": [
                "from .orm_config import AsyncSQLiteConfig, AsyncPostgresConfig, AsyncMySQLConfig"
            ],
            "code": "class AsyncConfigFactory(ConfigFactory):\n    def __init__(self, db_type: str):\n        super().__init__(db_type)"
        },
        {
            "key_id": 2,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/init",
            "imports": [
                "from nest.core.pynest_container import PyNestContainer",
                "from typing import Union, Type",
                "from nest.core.module_compiler import ModuleCompiler"
            ],
            "code": "def __init__(self, container: PyNestContainer, context_module: Union[Type, None] = None):\n    self._container = container\n    self._context_module = context_module\n    self._is_initialized = False\n    self._module_compiler = ModuleCompiler()\n\n    if context_module is not None:\n        self.init()"
        },
        {
            "key_id": 4,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/select_context_module",
            "imports": [],
            "code": "def select_context_module(self):\n    if not self._container.modules:\n        raise Exception('No modules found in the container.')\n    self._context_module = next(iter(self._container.modules.values()))"
        },
        {
            "key_id": 5,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/select",
            "imports": [
                "from typing import TypeVar, Type"
            ],
            "code": "T = TypeVar('T')\n\ndef select(self, module: Type[T]) -> Type[T]:\n    if module not in self._container.modules.values():\n        raise Exception(f'Module {module.__name__} not found in the application.')\n    self._context_module = module\n    return module"
        },
        {
            "key_id": 0,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
            "imports": [],
            "code": "def is_initialized(self) -> bool:\n    return self._is_initialized"
        },
        {
            "key_id": 1,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
            "imports": [],
            "code": "def is_initialized(self, value: bool):\n    if not isinstance(value, bool):\n        raise ValueError('is_initialized must be a boolean value.')\n    self._is_initialized = value"
        },
        {
            "key_id": 6,
            "fqn": "nest/core/pynest_factory.py/PyNestFactory/create",
            "imports": [
                "from fastapi import FastAPI",
                "from typing import Type, TypeVar",
                "from nest.core.pynest_application import PyNestApp",
                "from nest.core.pynest_container import PyNestContainer"
            ],
            "code": "ModuleType = TypeVar('ModuleType')\n\ndef create(main_module: Type[ModuleType], **kwargs) -> PyNestApp:\n    container = PyNestContainer()\n    fastapi_app = FastAPI(**kwargs)\n    pynest_app = PyNestApp(container, fastapi_app)\n    container.add_module(main_module)\n    pynest_app.register_routes()\n    return pynest_app"
        },
        {
            "key_id": 7,
            "fqn": "nest/core/pynest_factory.py/PyNestFactory/_create_server",
            "imports": [
                "from fastapi import FastAPI"
            ],
            "code": "def _create_server(**kwargs) -> FastAPI:\n    return FastAPI(**kwargs)"
        },
        {
            "key_id": 8,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/__new__",
            "imports": [
                "from typing import Dict, Type"
            ],
            "code": "def __init__(self):\n    self._instances: Dict[Type, object] = {}\n    self._dependencies: Dict[str, Type] = {}\n\ndef __new__(cls):\n    if not hasattr(cls, '_instance'):\n        cls._instance = super(PyNestContainer, cls).__new__(cls)\n    return cls._instance"
        },
        {
            "key_id": 10,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/modules",
            "imports": [],
            "code": "def modules(self):\n    return self._instances.values()"
        },
        {
            "key_id": 11,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/module_token_factory",
            "imports": [
                "from typing import Any"
            ],
            "code": "def module_token_factory(self) -> Any:\n    # This method would generate a unique token for each module\n    # For simplicity, let's assume it returns a string representation of the module class\n    return 'unique_module_token'"
        },
        {
            "key_id": 12,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/modules_metadata",
            "imports": [
                "typing"
            ],
            "code": "def modules_metadata(self):\n    return {module.__name__: {'dependencies': module._dependencies, 'instances': module._instances} for module in self._instances.values()}"
        },
        {
            "key_id": 13,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/module_compiler",
            "imports": [
                "typing"
            ],
            "code": "def module_compiler(self):\n    compiled_modules = {}\n    for module_name, module in self._instances.items():\n        compiled_modules[module_name] = self.compile_module(module)\n    return compiled_modules\n\ndef compile_module(self, module):\n    # Assuming a compile_module method exists or needs to be implemented\n    # This is a placeholder for the actual compilation logic\n    compiled = 'compiled representation of ' + str(module)\n    return compiled"
        },
        {
            "key_id": 14,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/get_instance",
            "imports": [
                "typing"
            ],
            "code": "def get_instance(self, dependency: TProvider, provider: typing.Optional[typing.Union[TProvider, TController]] = None):\n    if dependency in self._dependencies:\n        return self._instances.get(dependency)\n    elif provider and provider in self._dependencies:\n        return self._instances.get(provider)\n    else:\n        raise ValueError(f'No instance found for dependency: {dependency}')"
        },
        {
            "key_id": 15,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_module",
            "imports": [
                "typing"
            ],
            "code": "def add_module(self, metaclass) -> dict:\n    module_name = metaclass.__name__\n    if module_name not in self._instances:\n        self._instances[module_name] = metaclass()\n        self._dependencies[module_name] = metaclass._dependencies\n        return {'module': module_name, 'new': True}\n    else:\n        return {'module': module_name, 'new': False}"
        },
        {
            "key_id": 16,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/register_module",
            "imports": [
                "typing"
            ],
            "code": "def register_module(self, module_factory: ModuleFactory) -> Module:\n    module = module_factory()\n    module_name = module.__name__\n    if module_name not in self._instances:\n        self._instances[module_name] = module\n        self._dependencies[module_name] = module._dependencies\n        # Assuming add_metadata, add_imports, add_providers, and add_controllers are methods to be implemented\n        self.add_metadata(module_name, module._metadata)\n        self.add_imports(module_name, module._imports)\n        self.add_providers(module_name, module._providers)\n        self.add_controllers(module_name, module._controllers)\n        return module\n    else:\n        raise ValueError(f'Module {module_name} is already registered')"
        },
        {
            "key_id": 17,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_metadata",
            "imports": [],
            "code": "def add_metadata(self, token: str, module_metadata) -> None:\n    if token not in self._dependencies:\n        self._dependencies[token] = module_metadata\n    else:\n        raise ValueError(f'Metadata for token {token} already exists.')"
        },
        {
            "key_id": 18,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_import",
            "imports": [],
            "code": "def add_import(self, token: str):\n    if token not in self._dependencies:\n        raise ValueError(f'Token {token} not found in dependencies.')\n    self._dependencies[token]['imports'] = self._dependencies.get(token, {}).get('imports', []) + [token]"
        },
        {
            "key_id": 19,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_modules",
            "imports": [
                "from typing import List"
            ],
            "code": "def add_modules(self, modules: List[Any]) -> None:\n    for module in modules:\n        module_token = self.module_token_factory(module)\n        if module_token not in self._dependencies:\n            self._dependencies[module_token] = {'module': module}\n        else:\n            raise ValueError(f'Module {module_token} already exists in dependencies.')"
        },
        {
            "key_id": 20,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_providers",
            "imports": [
                "from typing import List"
            ],
            "code": "def add_providers(self, providers: List[Any], module_token: str) -> None:\n    if module_token not in self._dependencies:\n        raise ValueError(f'Module token {module_token} not found in dependencies.')\n    if 'providers' not in self._dependencies[module_token]:\n        self._dependencies[module_token]['providers'] = []\n    self._dependencies[module_token]['providers'].extend(providers)"
        },
        {
            "key_id": 21,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_provider",
            "imports": [],
            "code": "def add_provider(self, token: str, provider):\n    if token not in self._dependencies:\n        self._dependencies[token] = {'providers': [provider]}\n    else:\n        if 'providers' in self._dependencies[token]:\n            self._dependencies[token]['providers'].append(provider)\n        else:\n            self._dependencies[token]['providers'] = [provider]"
        },
        {
            "key_id": 22,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_get_providers",
            "imports": [
                "from typing import List, Type"
            ],
            "code": "def _get_providers(self, token: str) -> List[Any]:\n    if token in self._dependencies:\n        provider_type = self._dependencies[token]\n        if provider_type in self._instances:\n            return [self._instances[provider_type]]\n        else:\n            raise ValueError(f'Provider for token {token} not found')\n    else:\n        raise ValueError(f'Token {token} does not exist')"
        },
        {
            "key_id": 23,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_controllers",
            "imports": [
                "from typing import List, Type"
            ],
            "code": "def add_controllers(self, controllers: List[Any], module_token: str) -> None:\n    if module_token not in self._dependencies:\n        self._dependencies[module_token] = []\n    for controller in controllers:\n        self._add_controller(module_token, controller)"
        },
        {
            "key_id": 24,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_add_controller",
            "imports": [
                "from typing import Type"
            ],
            "code": "def _add_controller(self, token: str, controller: TController) -> None:\n    if token not in self._dependencies:\n        self._dependencies[token] = []\n    if controller not in self._dependencies[token]:\n        self._dependencies[token].append(controller)\n        self._instances[controller] = controller()"
        },
        {
            "key_id": 25,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_get_controllers",
            "imports": [
                "from typing import List, Type"
            ],
            "code": "def _get_controllers(self, token: str) -> List[Any]:\n    if token in self._dependencies:\n        return [self._instances[ctrl] for ctrl in self._dependencies[token] if ctrl in self._instances]\n    else:\n        raise ValueError(f'No controllers found for token {token}')"
        },
        {
            "key_id": 26,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/clear",
            "imports": [],
            "code": "def clear(self):\n    self._instances.clear()\n    self._dependencies.clear()"
        },
        {
            "key_id": 27,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_related_module",
            "imports": [
                "from typing import Type"
            ],
            "code": "def add_related_module(self, related_module, token: str) -> None:\n    if token not in self._dependencies:\n        raise ValueError(f'Module {token} not registered in dependencies.')\n    self._dependencies[token] = related_module\n    if related_module not in self._instances:\n        self._instances[related_module] = related_module()"
        },
        {
            "key_id": 28,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/get_module_by_key",
            "imports": [
                "from typing import Type, Optional"
            ],
            "code": "def get_module_by_key(self, module_key: str) -> Optional[Type]:\n    return self._instances.get(self._dependencies.get(module_key))"
        },
        {
            "key_id": 29,
            "fqn": "nest/core/pynest_application.py/PyNestApp/is_listening",
            "imports": [],
            "code": "def is_listening(self) -> bool:\n    return self._is_listening"
        },
        {
            "key_id": 31,
            "fqn": "nest/core/pynest_application.py/PyNestApp/use",
            "imports": [
                "from fastapi import FastAPI"
            ],
            "code": "def use(self, middleware: type, **options) -> 'PyNestApp':\n    self._http_server.add_middleware(middleware, **options)\n    return self"
        },
        {
            "key_id": 32,
            "fqn": "nest/core/pynest_application.py/PyNestApp/get_server",
            "imports": [
                "from fastapi import FastAPI"
            ],
            "code": "def get_server(self) -> FastAPI:\n    return self._http_server"
        },
        {
            "key_id": 33,
            "fqn": "nest/core/pynest_application.py/PyNestApp/register_routes",
            "imports": [
                "from fastapi import APIRouter",
                "from nest.core.pynest_container import PyNestContainer",
                "from fastapi import FastAPI"
            ],
            "code": "def __init__(self, container: PyNestContainer, http_server: FastAPI):\n    self._container = container\n    self._http_server = http_server\n    self._is_listening = False\n\n    self.register_routes()\n\ndef register_routes(self):\n    for module in self._container.modules.values():\n        for controller in module.controllers:\n            router = APIRouter()\n            controller_cls = controller()\n            controller_cls.add_routes(router)\n            self._http_server.include_router(router)"
        },
        {
            "key_id": 34,
            "fqn": "nest/core/decorators/injectable.py/Injectable",
            "imports": [
                "from typing import Callable, Type, Optional"
            ],
            "code": "def Injectable(target_class: Optional[Type] = None, *args, **kwargs) -> Callable:\n    def decorator(cls):\n        # Here we could add logic to manage dependencies\n        return cls\n    if target_class is None:\n        return decorator\n    return decorator(target_class)"
        },
        {
            "key_id": 35,
            "fqn": "nest/core/decorators/controller.py/Controller",
            "imports": [
                "from typing import Optional, Type",
                "from fastapi import APIRouter"
            ],
            "code": "def Controller(prefix: Optional[str] = None, tag: Optional[str] = None):\n    def decorator(cls):\n        cls._prefix = prefix\n        cls._tag = tag\n        cls.router = APIRouter()\n        return cls\n    return decorator"
        },
        {
            "key_id": 36,
            "fqn": "nest/core/decorators/controller.py/process_prefix",
            "imports": [],
            "code": "def process_prefix(route_prefix: Optional[str], tag_name: Optional[str]) -> str:\n    prefix = '/' + route_prefix if route_prefix else ''\n    if tag_name:\n        prefix += f' ({tag_name})'\n    return prefix"
        },
        {
            "key_id": 37,
            "fqn": "nest/core/decorators/controller.py/process_dependencies",
            "imports": [
                "from typing import Type"
            ],
            "code": "def process_dependencies(cls: Type) -> None:\n    # Assuming this function processes and injects dependencies\n    # This is a placeholder for dependency injection logic\n    if hasattr(cls, 'dependencies'):\n        for dependency in cls.dependencies:\n            # Inject dependencies here\n            pass"
        },
        {
            "key_id": 38,
            "fqn": "nest/core/decorators/controller.py/set_instance_variables",
            "imports": [
                "from typing import Type",
                "from fastapi import APIRouter"
            ],
            "code": "def set_instance_variables(cls: Type) -> None:\n    if not hasattr(cls, '__annotations__'):\n        return\n    for var_name, var_type in cls.__annotations__.items():\n        if var_type == APIRouter:\n            setattr(cls, var_name, APIRouter())\n        else:\n            setattr(cls, var_name, None)"
        },
        {
            "key_id": 39,
            "fqn": "nest/core/decorators/controller.py/ensure_init_method",
            "imports": [
                "from typing import Type"
            ],
            "code": "def ensure_init_method(cls: Type) -> None:\n    if '__init__' not in cls.__dict__:\n        def __init__(self, *args, **kwargs):\n            super(cls, self).__init__(*args, **kwargs)\n        cls.__init__ = __init__"
        },
        {
            "key_id": 40,
            "fqn": "nest/core/decorators/controller.py/add_routes",
            "imports": [
                "from typing import Type",
                "from fastapi import APIRouter"
            ],
            "code": "def add_routes(cls: Type, router: APIRouter, route_prefix: str) -> None:\n    for name, method in cls.__dict__.items():\n        if callable(method) and hasattr(method, '__route__'):\n            path = route_prefix + getattr(method, '__path__', '')\n            router.add_api_route(path, method, methods=[getattr(method, '__method__', 'GET')], tags=[getattr(cls, '__tag__', '')])"
        },
        {
            "key_id": 41,
            "fqn": "nest/core/decorators/controller.py/validate_method_decorator",
            "imports": [
                "from typing import Callable"
            ],
            "code": "def validate_method_decorator(method_function: Callable, method_name: str) -> None:\n    if not hasattr(method_function, '__route__'):\n        raise ValueError(f'Method {method_name} is missing an HTTP method decorator')"
        },
        {
            "key_id": 42,
            "fqn": "nest/core/decorators/controller.py/configure_method_route",
            "imports": [
                "from typing import Callable"
            ],
            "code": "def configure_method_route(method_function: Callable, route_prefix: str) -> None:\n    if hasattr(method_function, '__route__'):\n        method_function.__path__ = route_prefix + (getattr(method_function, '__path__', '') or '/' + method_function.__name__.lower())"
        },
        {
            "key_id": 43,
            "fqn": "nest/core/decorators/controller.py/add_route_to_router",
            "imports": [
                "from fastapi import APIRouter"
            ],
            "code": "def add_route_to_router(router: APIRouter, method_function: callable) -> None:\n    try:\n        if hasattr(method_function, '__route__'):\n            route = method_function.__route__\n            router.add_api_route(route.path, method_function, methods=[route.method], name=route.name)\n        else:\n            raise AttributeError('Method function is missing the __route__ attribute')\n    except Exception as e:\n        raise RuntimeError(f'Failed to add route for method {method_function.__name__}: {str(e)}')"
        },
        {
            "key_id": 44,
            "fqn": "nest/core/decorators/http_method.py/route",
            "imports": [
                "from typing import Union, List, Callable, Any",
                "from fastapi import HTTPMethod"
            ],
            "code": "def route(http_method: HTTPMethod, route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable) -> Callable:\n        if not hasattr(func, '__route__'):\n            func.__route__ = {'path': route_path, 'method': http_method, **kwargs}\n        else:\n            raise AttributeError('Function already has a __route__ attribute')\n        return func\n    return decorator"
        },
        {
            "key_id": 45,
            "fqn": "nest/core/decorators/http_method.py/Get",
            "imports": [
                "from typing import Union, List, Callable, Any"
            ],
            "code": "def Get(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    return route('GET', route_path, **kwargs)"
        },
        {
            "key_id": 46,
            "fqn": "nest/core/decorators/http_method.py/Post",
            "imports": [
                "from typing import Union, List, Callable, Any"
            ],
            "code": "def Post(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    return route('POST', route_path, **kwargs)"
        },
        {
            "key_id": 47,
            "fqn": "nest/core/decorators/http_method.py/Delete",
            "imports": [
                "from typing import Union, List, Callable, Any"
            ],
            "code": "def Delete(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    return route('DELETE', route_path, **kwargs)"
        },
        {
            "key_id": 48,
            "fqn": "nest/core/decorators/http_method.py/Put",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Put(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '__routes__'):\n            func.__routes__ = []\n        func.__routes__.append((APIRouter.put, route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 49,
            "fqn": "nest/core/decorators/http_method.py/Patch",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Patch(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '__routes__'):\n            func.__routes__ = []\n        func.__routes__.append((APIRouter.patch, route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 50,
            "fqn": "nest/core/decorators/http_method.py/Head",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Head(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '__routes__'):\n            func.__routes__ = []\n        func.__routes__.append((APIRouter.head, route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 51,
            "fqn": "nest/core/decorators/http_method.py/Options",
            "imports": [
                "from typing import Callable, Union, List, Any",
                "from fastapi import APIRouter"
            ],
            "code": "def Options(route_path: Union[str, List[str]] = '/', **kwargs) -> Callable[..., Any]:\n    def decorator(func: Callable):\n        if not hasattr(func, '__routes__'):\n            func.__routes__ = []\n        func.__routes__.append((APIRouter.options, route_path, kwargs))\n        return func\n    return decorator"
        },
        {
            "key_id": 52,
            "fqn": "nest/core/decorators/database.py/db_request_handler",
            "imports": [
                "from sqlalchemy.orm import Session",
                "from fastapi import Depends",
                "from nest.core.database.orm_provider import get_db"
            ],
            "code": "def db_request_handler(func):\n    def wrapper(*args, **kwargs):\n        db: Session = Depends(get_db)\n        try:\n            result = func(db, *args, **kwargs)\n            db.commit()\n            return result\n        except Exception as e:\n            db.rollback()\n            raise e\n        finally:\n            db.close()\n    return wrapper"
        },
        {
            "key_id": 53,
            "fqn": "nest/core/decorators/database.py/async_db_request_handler",
            "imports": [
                "from fastapi import HTTPException",
                "from sqlalchemy.exc import SQLAlchemyError",
                "from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR",
                "import logging",
                "from contextlib import asynccontextmanager",
                "from typing import Callable, TypeVar, Awaitable"
            ],
            "code": "logger = logging.getLogger(__name__)\n\nF = TypeVar('F', bound=Callable[..., Awaitable])\n\n@asynccontextmanager\nasync def async_session_manager(db_session):\n    try:\n        yield db_session\n        await db_session.commit()\n    except Exception as e:\n        await db_session.rollback()\n        logger.error(f'Rollback due to: {e}')\n        raise HTTPException(status_code=HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n    finally:\n        await db_session.close()\n\ndef async_db_request_handler(func: F) -> F:\n    async def wrapper(*args, **kwargs):\n        async with async_session_manager(kwargs.get('db_session')) as session:\n            kwargs['db_session'] = session\n            return await func(*args, **kwargs)\n    return wrapper  # type: ignore"
        },
        {
            "key_id": 54,
            "fqn": "nest/core/decorators/http_code.py/HttpCode",
            "imports": [
                "from fastapi import status",
                "from fastapi.responses import JSONResponse"
            ],
            "code": "def HttpCode(status_code: int):\n    def decorator(func):\n        async def wrapper(*args, **kwargs):\n            response = await func(*args, **kwargs)\n            return JSONResponse(content=response, status_code=status_code)\n        return wrapper\n    return decorator"
        },
        {
            "key_id": 56,
            "fqn": "nest/core/decorators/module.py/Module/__call__",
            "imports": [
                "from typing import List, Type, Optional"
            ],
            "code": "class Module:\n    def __init__(self, imports: Optional[List[Type]] = None, controllers: Optional[List[Type]] = None, providers: Optional[List[Type]] = None, exports: Optional[List[Type]] = None, is_global: bool = False):\n        self.imports = imports or []\n        self.controllers = controllers or []\n        self.providers = providers or []\n        self.exports = exports or []\n        self.is_global = is_global\n\n    def __call__(self, cls):\n        cls.is_global = self.is_global\n        cls.imports = self.imports\n        cls.controllers = self.controllers\n        cls.providers = self.providers\n        cls.exports = self.exports\n        return cls"
        },
        {
            "key_id": 57,
            "fqn": "nest/core/decorators/utils.py/get_instance_variables",
            "imports": [
                "from typing import Type, Dict"
            ],
            "code": "def get_instance_variables(cls: Type) -> Dict[str, Type]:\n    return {k: v for k, v in cls.__dict__.items() if not k.startswith('_') and not callable(v)}"
        },
        {
            "key_id": 58,
            "fqn": "nest/core/decorators/utils.py/get_non_dependencies_params",
            "imports": [
                "from typing import Type, List, Any",
                "from inspect import signature"
            ],
            "code": "def get_non_dependencies_params(cls: Type) -> List[Any]:\n    sig = signature(cls.__init__)\n    return [param.name for param in sig.parameters.values() if param.name != 'self' and param.default is param.empty]"
        },
        {
            "key_id": 59,
            "fqn": "nest/core/decorators/utils.py/parse_dependencies",
            "imports": [
                "from typing import Type, List, Any",
                "from injector import inject"
            ],
            "code": "def parse_dependencies(cls: Type[Any]) -> None:\n    dependencies = getattr(cls, '__annotations__', {})\n    for attr_name, attr_type in dependencies.items():\n        if hasattr(attr_type, '__call__'):\n            setattr(cls, attr_name, inject(attr_type))"
        },
        {
            "key_id": 60,
            "fqn": "nest/core/decorators/class_based_view.py/class_based_view",
            "imports": [
                "from fastapi import APIRouter",
                "from typing import Type, TypeVar, Callable",
                "T = TypeVar('T')"
            ],
            "code": "def class_based_view(router: APIRouter, cls: Type[T]) -> Type[T]:\n    for route in router.routes:\n        if hasattr(cls, route.endpoint.__name__):\n            original_func = getattr(cls, route.endpoint.__name__)\n            route.endpoint = lambda *args, **kwargs: original_func(cls(), *args, **kwargs)\n    return cls"
        },
        {
            "key_id": 61,
            "fqn": "nest/core/decorators/class_based_view.py/_init_cbv",
            "imports": [
                "from typing import Type, Any",
                "from injector import Injector, inject"
            ],
            "code": "def _init_cbv(cls: Type[Any]) -> None:\n    injector = Injector()\n    for attr_name, attr_type in cls.__annotations__.items():\n        setattr(cls, attr_name, injector.get(attr_type))"
        },
        {
            "key_id": 62,
            "fqn": "nest/core/decorators/class_based_view.py/_update_cbv_route_endpoint_signature",
            "imports": [
                "from typing import Type, Any, Union",
                "from fastapi.routing import Route, WebSocketRoute"
            ],
            "code": "def _update_cbv_route_endpoint_signature(cls: Type[Any], route: Union[Route, WebSocketRoute]) -> None:\n    if hasattr(cls, route.endpoint.__name__):\n        original_func = getattr(cls, route.endpoint.__name__)\n        route.endpoint = lambda *args, **kwargs: original_func(cls(), *args, **kwargs)"
        },
        {
            "key_id": 64,
            "fqn": "nest/core/database/base_config.py/ConfigFactoryBase/get_config",
            "imports": [
                "from typing import Any"
            ],
            "code": "class ConfigFactoryBase:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n        self.config = None\n\n    def get_config(self) -> Any:\n        if self.config is None:\n            raise NotImplementedError('You must implement the get_config method')\n        return self.config"
        },
        {
            "key_id": 65,
            "fqn": "nest/core/database/base_config.py/BaseConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    raise NotImplementedError('This method should be implemented by subclasses to return the database engine URL.')"
        },
        {
            "key_id": 67,
            "fqn": "nest/core/database/base_config.py/BaseProvider/get_engine_url",
            "imports": [],
            "code": "class BaseProvider:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.config_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        raise NotImplementedError('Subclasses must implement this method to return the correct engine URL.')"
        },
        {
            "key_id": 69,
            "fqn": "nest/core/database/odm_provider.py/OdmProvider/check_document_models",
            "imports": [
                "from motor.motor_asyncio import AsyncIOMotorClient",
                "from typing import List, Optional, Dict",
                "from beanie import Document"
            ],
            "code": "class OdmProvider:\n    def __init__(self, db_type: str = 'mongodb', config_params: Optional[Dict] = None, document_models: Optional[List[Document]] = None):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.document_models = document_models or []\n        self.client = None\n        self.config_url = self.get_engine_url()\n\n    def get_engine_url(self) -> str:\n        return f'mongodb://{self.config_params['host']}:{self.config_params['port']}'\n\n    def check_document_models(self):\n        if not all(isinstance(model, Document) for model in self.document_models):\n            raise ValueError('All items in document_models must be instances of beanie.Document')"
        },
        {
            "key_id": 71,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/create_all",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession",
                "from sqlalchemy.orm import sessionmaker"
            ],
            "code": "class BaseOrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: Optional[Dict] = None, async_mode: bool = False, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.async_mode = async_mode\n        self.engine = self.create_engine()\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession if self.async_mode else None)\n\n    def create_engine(self):\n        if self.async_mode:\n            return create_async_engine(self.get_engine_url(), echo=True, future=True)\n        else:\n            return create_engine(self.get_engine_url(), echo=True)\n\n    async def create_all(self):\n        async with self.engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)"
        },
        {
            "key_id": 72,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/drop_all",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession",
                "from sqlalchemy.orm import sessionmaker"
            ],
            "code": "class BaseOrmProvider:\n    async def drop_all(self):\n        async with self.engine.begin() as conn:\n            await conn.run_sync(Base.metadata.drop_all)"
        },
        {
            "key_id": 73,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/get_db",
            "imports": [
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from sqlalchemy.ext.asyncio import create_async_engine"
            ],
            "code": "class BaseOrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: Optional[Dict] = None, async_mode: bool = False, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.async_mode = async_mode\n        self.engine = self.create_engine()\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession if self.async_mode else None)\n\n    def create_engine(self):\n        if self.async_mode:\n            return create_async_engine(self.get_engine_url(), echo=True, future=True)\n        else:\n            raise NotImplementedError('Synchronous mode not implemented.')\n\n    def get_engine_url(self) -> str:\n        return f'{self.db_type}://{self.config_params['user']}:{self.config_params['password']}@{self.config_params['host']}:{self.config_params['port']}/{self.config_params['db_name']}'\n\n    def get_db(self):\n        db = self.SessionLocal()\n        try:\n            yield db\n        finally:\n            db.close()"
        },
        {
            "key_id": 75,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/create_all",
            "imports": [
                "from sqlalchemy.ext.asyncio import AsyncEngine",
                "from sqlalchemy.ext.declarative import declarative_base",
                "import asyncio"
            ],
            "code": "class AsyncOrmProvider:\n    Base = declarative_base()\n\n    async def create_all(self):\n        async with self.engine.begin() as conn:\n            await conn.run_sync(self.Base.metadata.create_all)"
        },
        {
            "key_id": 76,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/drop_all",
            "imports": [
                "from sqlalchemy.ext.asyncio import AsyncEngine",
                "from sqlalchemy.ext.declarative import declarative_base",
                "import asyncio"
            ],
            "code": "class AsyncOrmProvider:\n    Base = declarative_base()\n\n    async def drop_all(self):\n        async with self.engine.begin() as conn:\n            await conn.run_sync(self.Base.metadata.drop_all)"
        },
        {
            "key_id": 77,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/get_db",
            "imports": [
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from contextlib import asynccontextmanager"
            ],
            "code": "class AsyncOrmProvider:\n    def __init__(self, db_type: str = 'postgresql', config_params: Optional[Dict] = None, **kwargs):\n        self.db_type = db_type\n        self.config_params = config_params\n        self.engine = create_async_engine(self.get_engine_url(), echo=True, future=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    def get_engine_url(self) -> str:\n        return f'{self.db_type}://{self.config_params['user']}:{self.config_params['password']}@{self.config_params['host']}:{self.config_params['port']}/{self.config_params['db_name']}'\n\n    @asynccontextmanager\n    async def get_db(self):\n        async with self.SessionLocal() as session:\n            yield session"
        },
        {
            "key_id": 80,
            "fqn": "nest/core/database/odm_config.py/MongoDBConfig/get_engine_url",
            "imports": [
                "from pymongo import MongoClient"
            ],
            "code": "class MongoDBConfig:\n    def __init__(self, host: str, db_name: str, user: str = None, password: str = None, port: int = 27017, srv: bool = False):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.srv = srv\n        self.client = None\n\n    def connect(self):\n        try:\n            connection_string = f'mongodb+srv://{self.user}:{self.password}@{self.host}/{self.db_name}' if self.srv else f'mongodb://{self.user}:{self.password}@{self.host}:{self.port}'\n            self.client = MongoClient(connection_string)\n            print('MongoDB connection successful.')\n        except Exception as e:\n            print(f'Error connecting to MongoDB: {e}')\n\n    def get_engine_url(self) -> str:\n        return f'mongodb+srv://{self.user}:{self.password}@{self.host}/{self.db_name}' if self.srv else f'mongodb://{self.user}:{self.password}@{self.host}:{self.port}'"
        },
        {
            "key_id": 82,
            "fqn": "nest/core/database/odm_config.py/ConfigFactory/get_config",
            "imports": [
                "from nest.core.database.odm_config import MongoDBConfig"
            ],
            "code": "class ConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n\n    def get_config(self):\n        if self.db_type == 'mongodb':\n            return MongoDBConfig()\n        else:\n            raise ValueError(f'Unsupported database type: {self.db_type}')"
        },
        {
            "key_id": 84,
            "fqn": "nest/core/database/orm_config.py/PostgresConfig/get_engine_url",
            "imports": [
                "from sqlalchemy import create_engine"
            ],
            "code": "class PostgresConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine = None\n\n    def get_engine_url(self) -> str:\n        return f'postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 86,
            "fqn": "nest/core/database/orm_config.py/MySQLConfig/get_engine_url",
            "imports": [
                "from sqlalchemy import create_engine"
            ],
            "code": "class MySQLConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine = None\n\n    def get_engine_url(self) -> str:\n        return f'mysql+pymysql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}'"
        },
        {
            "key_id": 88,
            "fqn": "nest/core/database/orm_config.py/SQLiteConfig/get_engine_url",
            "imports": [
                "from sqlalchemy import create_engine"
            ],
            "code": "class SQLiteConfig:\n    def __init__(self, db_name: str):\n        self.db_name = db_name\n        self.engine = None\n\n    def get_engine_url(self) -> str:\n        return f'sqlite:///{self.db_name}'"
        },
        {
            "key_id": 90,
            "fqn": "nest/core/database/orm_config.py/AsyncSQLiteConfig/get_engine_url",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncSQLiteConfig:\n    def __init__(self, db_name: str):\n        self.db_name = db_name\n        self.engine_url = f'sqlite+aiosqlite:///{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    def get_engine_url(self) -> str:\n        return self.engine_url"
        },
        {
            "key_id": 92,
            "fqn": "nest/core/database/orm_config.py/AsyncPostgresConfig/get_engine_url",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncPostgresConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine_url = f'postgresql+asyncpg://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    def get_engine_url(self) -> str:\n        return self.engine_url"
        },
        {
            "key_id": 94,
            "fqn": "nest/core/database/orm_config.py/AsyncMySQLConfig/get_engine_url",
            "imports": [
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession"
            ],
            "code": "class AsyncMySQLConfig:\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        self.host = host\n        self.db_name = db_name\n        self.user = user\n        self.password = password\n        self.port = port\n        self.engine_url = f'mysql+aiomysql://{user}:{password}@{host}:{port}/{db_name}'\n        self.engine = create_async_engine(self.engine_url, echo=True)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine, class_=AsyncSession)\n\n    def get_engine_url(self) -> str:\n        return self.engine_url"
        },
        {
            "key_id": 96,
            "fqn": "nest/core/database/orm_config.py/ConfigFactory/get_config",
            "imports": [
                "from .orm_config import AsyncPostgresConfig, AsyncMySQLConfig"
            ],
            "code": "class ConfigFactory:\n    def __init__(self, db_type: str):\n        self.db_type = db_type\n\n    def get_config(self):\n        if self.db_type == 'postgresql':\n            return AsyncPostgresConfig\n        elif self.db_type == 'mysql':\n            return AsyncMySQLConfig\n        else:\n            raise Exception(f'Unsupported database type: {self.db_type}')"
        },
        {
            "key_id": 98,
            "fqn": "nest/core/database/orm_config.py/AsyncConfigFactory/get_config",
            "imports": [
                "from .orm_config import AsyncPostgresConfig, AsyncMySQLConfig"
            ],
            "code": "class AsyncConfigFactory(ConfigFactory):\n    def __init__(self, db_type: str):\n        super().__init__(db_type)\n\n    def get_config(self):\n        return super().get_config()"
        }
    ]
}