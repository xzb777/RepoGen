{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "santorinai/board.py/Board/__init__",
            "imports": [
                "from typing import List"
            ],
            "code": "class Board:\n    def __init__(self, number_of_players: int):\n        self.number_of_players = number_of_players\n        self.board = [[0 for _ in range(5)] for _ in range(5)]\n        self.pawns = []  # List of Pawn objects\n        self.player_turn = 1\n        self.turn_number = 0\n        # Initialize board state or any other required variables\n\n        # Placeholder for initializing pawns based on number_of_players\n        # This is a simplified example. Actual implementation might require more details.\n        for player_number in range(1, number_of_players + 1):\n            for pawn_order in range(1, 3):\n                self.pawns.append(Pawn(player_number=player_number, order=pawn_order, number=pawn_order))"
        },
        {
            "key_id": 25,
            "fqn": "santorinai/pawn.py/Pawn/__init__",
            "imports": [],
            "code": "class Pawn:\n    def __init__(self, number: int, order: int, player_number: int):\n        self.number = number\n        self.order = order\n        self.player_number = player_number\n        self.pos = (None, None)  # Initial position is not placed on the board"
        },
        {
            "key_id": 21,
            "fqn": "santorinai/player.py/Player/__init__",
            "imports": [],
            "code": "class Player:\n    def __init__(self, player_number: int, log_level=0):\n        self.player_number = player_number\n        self.log_level = log_level\n        # Initialize player state or any other required variables\n        # This is a placeholder for player initialization logic"
        },
        {
            "key_id": 33,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/__init__",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class FirstChoicePlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n        # Additional initialization specific to FirstChoicePlayer"
        },
        {
            "key_id": 37,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/__init__",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n        # Additional initialization specific to RandomPlayer"
        },
        {
            "key_id": 41,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/__init__",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n        # Initialization logic for BasicPlayer\n        # You can initialize your player-specific variables here\n        self.log_level = log_level\n        # Example: self.strategy = 'aggressive'\n        # This is just a placeholder for whatever initialization you need\n        # for your player's strategy or state"
        },
        {
            "key_id": 19,
            "fqn": "santorinai/board.py/Board/copy",
            "imports": [
                "from copy import deepcopy"
            ],
            "code": "def copy(self) -> 'Board':\n        return deepcopy(self)"
        },
        {
            "key_id": 20,
            "fqn": "santorinai/board.py/Board/__repr__",
            "imports": [],
            "code": "def __repr__(self) -> str:\n        board_str = ''\n        for row in self.board:\n            board_str += ' '.join(str(cell) for cell in row) + '\\n'\n        return board_str"
        },
        {
            "key_id": 1,
            "fqn": "santorinai/board.py/Board/is_move_possible",
            "imports": [],
            "code": "def is_move_possible(self, start_pos: Tuple[int, int], end_pos: Tuple[int, int]) -> Tuple[bool, str]:\n        if not self.is_position_within_board(start_pos) or not self.is_position_within_board(end_pos):\n            return False, 'One of the positions is out of the board bounds.'\n        if not self.is_position_adjacent(start_pos, end_pos):\n            return False, 'The positions are not adjacent.'\n        if self.is_pawn_on_position(end_pos):\n            return False, 'The target position is already occupied by another pawn.'\n        return True, 'The move is possible.'"
        },
        {
            "key_id": 2,
            "fqn": "santorinai/board.py/Board/is_position_within_board",
            "imports": [],
            "code": "def is_position_within_board(self, position: Tuple[int, int]) -> bool:\n        x, y = position\n        return 0 <= x < 5 and 0 <= y < 5"
        },
        {
            "key_id": 3,
            "fqn": "santorinai/board.py/Board/is_position_adjacent",
            "imports": [],
            "code": "def is_position_adjacent(self, position1: Tuple[int, int], position2: Tuple[int, int]) -> bool:\n        x1, y1 = position1\n        x2, y2 = position2\n        return max(abs(x1 - x2), abs(y1 - y2)) == 1"
        },
        {
            "key_id": 4,
            "fqn": "santorinai/board.py/Board/is_pawn_on_position",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_pawn_on_position(self, position: Tuple[int, int]) -> bool:\n        for pawn in self.pawns:\n            if pawn.pos == position:\n                return True\n        return False"
        },
        {
            "key_id": 5,
            "fqn": "santorinai/board.py/Board/is_build_possible",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_build_possible(self, builder_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:\n        if not self.is_position_valid(build_position):\n            return False, 'Invalid build position.'\n        if not self.is_position_adjacent(builder_position, build_position):\n            return False, 'Build position is not adjacent to builder.'\n        if self.is_pawn_on_position(build_position):\n            return False, 'Another pawn is on the build position.'\n        if self.board[build_position[0]][build_position[1]] == 4:\n            return False, 'Cannot build on a terminated tower.'\n        return True, 'Build is possible.'"
        },
        {
            "key_id": 13,
            "fqn": "santorinai/board.py/Board/place_pawn",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def place_pawn(self, position: Tuple[int, int]) -> Tuple[bool, str]:\n        if not self.is_position_valid(position):\n            return False, 'Invalid position.'\n        if self.is_pawn_on_position(position):\n            return False, 'Position already occupied by another pawn.'\n        self.board[position[0]][position[1]] = 1  # Assuming 1 indicates a pawn's presence for simplification\n        return True, 'Pawn placed successfully.'"
        },
        {
            "key_id": 14,
            "fqn": "santorinai/board.py/Board/play_move",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def play_move(self, pawn_number: int, move_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:\n        pawn = next((p for p in self.pawns if p.number == pawn_number), None)\n        if pawn is None:\n            return False, 'Pawn does not exist.'\n        if not self.is_move_possible(pawn.pos, move_position):\n            return False, 'Move is not possible.'\n        if not self.is_build_possible(move_position, build_position)[0]:\n            return False, 'Build is not possible.'\n        pawn.move(move_position)\n        self.board[build_position[0]][build_position[1]] += 1  # Increment tower height\n        self.next_turn()\n        return True, 'Move and build successful.'"
        },
        {
            "key_id": 15,
            "fqn": "santorinai/board.py/Board/is_position_valid",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_position_valid(self, pos: Tuple[int, int]) -> Tuple[bool, str]:\n        if not (0 <= pos[0] < 5 and 0 <= pos[1] < 5):\n            return False, 'Position out of board boundaries.'\n        return True, 'Position is valid.'"
        },
        {
            "key_id": 16,
            "fqn": "santorinai/board.py/Board/is_game_over",
            "imports": [],
            "code": "def is_game_over(self):\n    # Check if any pawn has reached the top of a tower\n    for pawn in self.pawns:\n        x, y = pawn.pos\n        if self.board[x][y] == 3:  # 3 represents the top of a tower\n            return True\n    # Check if all players are stuck\n    if self.is_everyone_stuck():\n        return True\n    return False"
        },
        {
            "key_id": 17,
            "fqn": "santorinai/board.py/Board/is_everyone_stuck",
            "imports": [],
            "code": "def is_everyone_stuck(self):\n    for pawn in self.pawns:\n        if self.get_possible_movement_positions(pawn) or self.get_possible_building_positions(pawn):\n            return False\n    return True"
        },
        {
            "key_id": 18,
            "fqn": "santorinai/board.py/Board/next_turn",
            "imports": [],
            "code": "def next_turn(self):\n    self.player_turn = (self.player_turn % self.number_of_players) + 1\n    self.turn_number += 1"
        },
        {
            "key_id": 26,
            "fqn": "santorinai/pawn.py/Pawn/move",
            "imports": [],
            "code": "def move(self, new_pos):\n    if new_pos in self.board.get_possible_movement_positions(self):\n        self.pos = new_pos\n        return True\n    return False"
        },
        {
            "key_id": 27,
            "fqn": "santorinai/pawn.py/Pawn/copy",
            "imports": [],
            "code": "def copy(self):\n    return Pawn(self.number, self.order, self.player_number)"
        },
        {
            "key_id": 28,
            "fqn": "santorinai/pawn.py/Pawn/__repr__",
            "imports": [],
            "code": "def __repr__(self):\n    return f'Pawn{{number={self.number}, order={self.order}, player_number={self.player_number}, pos={self.pos}}}'"
        },
        {
            "key_id": 6,
            "fqn": "santorinai/board.py/Board/get_player_pawns",
            "imports": [],
            "code": "def get_player_pawns(self, player_number: int) -> List[Pawn]:\n    return [pawn for pawn in self.pawns if pawn.player_number == player_number]"
        },
        {
            "key_id": 7,
            "fqn": "santorinai/board.py/Board/get_player_pawn",
            "imports": [],
            "code": "def get_player_pawn(self, player_number: int, pawn_number: int) -> Pawn:\n    for pawn in self.pawns:\n        if pawn.player_number == player_number and pawn.number == pawn_number:\n            return pawn\n    return None"
        },
        {
            "key_id": 8,
            "fqn": "santorinai/board.py/Board/get_playing_pawn",
            "imports": [],
            "code": "def get_playing_pawn(self, pawn_number: int) -> Pawn:\n    for pawn in self.pawns:\n        if pawn.order == pawn_number and pawn.player_number == self.player_turn:\n            return pawn\n    return None"
        },
        {
            "key_id": 9,
            "fqn": "santorinai/board.py/Board/get_first_unplaced_player_pawn",
            "imports": [],
            "code": "def get_first_unplaced_player_pawn(self, player_number: int) -> Pawn:\n    for pawn in self.pawns:\n        if pawn.player_number == player_number and pawn.pos == (None, None):\n            return pawn\n    return None"
        },
        {
            "key_id": 10,
            "fqn": "santorinai/board.py/Board/get_possible_movement_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_movement_positions(self, pawn) -> List[Tuple[int, int]]:\n    possible_positions = []\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for dx, dy in directions:\n        new_x, new_y = pawn.pos[0] + dx, pawn.pos[1] + dy\n        if self.is_position_within_board((new_x, new_y)) and not self.is_pawn_on_position((new_x, new_y)) and self.is_position_adjacent(pawn.pos, (new_x, new_y)):\n            possible_positions.append((new_x, new_y))\n    return possible_positions"
        },
        {
            "key_id": 11,
            "fqn": "santorinai/board.py/Board/get_possible_building_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_building_positions(self, pawn) -> List[Tuple[int, int]]:\n    possible_positions = []\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for dx, dy in directions:\n        new_x, new_y = pawn.pos[0] + dx, pawn.pos[1] + dy\n        if self.is_position_within_board((new_x, new_y)) and not self.is_pawn_on_position((new_x, new_y)) and self.is_build_possible(pawn.pos, (new_x, new_y)):\n            possible_positions.append((new_x, new_y))\n    return possible_positions"
        },
        {
            "key_id": 12,
            "fqn": "santorinai/board.py/Board/get_possible_movement_and_building_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_movement_and_building_positions(self, pawn):\n    possible_moves_and_builds = []\n    possible_moves = self.get_possible_movement_positions(pawn)\n    for move in possible_moves:\n        self.board[move[0]][move[1]] = 1  # Temporarily simulate the move\n        possible_builds = self.get_possible_building_positions(pawn)\n        for build in possible_builds:\n            possible_moves_and_builds.append((move, build))\n        self.board[move[0]][move[1]] = 0  # Revert the move\n    return possible_moves_and_builds"
        },
        {
            "key_id": 22,
            "fqn": "santorinai/player.py/Player/name",
            "imports": [],
            "code": "def name(self):\n    return 'RandomPlayer'"
        },
        {
            "key_id": 23,
            "fqn": "santorinai/player.py/Player/place_pawn",
            "imports": [
                "from random import choice"
            ],
            "code": "def place_pawn(self, board, pawn) -> Tuple[int, int]:\n    possible_positions = board.get_possible_movement_positions(pawn)\n    if possible_positions:\n        chosen_position = choice(possible_positions)\n        success, message = board.place_pawn(chosen_position)\n        if success:\n            return chosen_position\n    return None, None"
        },
        {
            "key_id": 24,
            "fqn": "santorinai/player.py/Player/play_move",
            "imports": [
                "from random import choice"
            ],
            "code": "def play_move(self, board):\\n    my_pawn_1 = board.get_playing_pawn(1)\\n    my_pawn_2 = board.get_playing_pawn(2)\\n\\n    my_pawn_to_move_choice = choice([my_pawn_1, my_pawn_2])\\n    my_pawn_possible_moves = board.get_possible_movement_and_building_positions(my_pawn_to_move_choice)\\n\\n    if not my_pawn_possible_moves:\\n        return None, None, None\\n\\n    my_move_and_build_choice = choice(my_pawn_possible_moves)\\n\\n    my_move_position = my_move_and_build_choice[0]\\n    my_build_position = my_move_and_build_choice[1]\\n\\n    return my_pawn_to_move_choice.order, my_move_position, my_build_position"
        },
        {
            "key_id": 34,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/name",
            "imports": [],
            "code": "def name(self):\\n    return 'First Choice Player'"
        },
        {
            "key_id": 35,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/place_pawn",
            "imports": [
                "from random import choice"
            ],
            "code": "def place_pawn(self, board, pawn):\\n    available_positions = board.get_possible_movement_positions(pawn)\\n    if available_positions:\\n        return choice(available_positions)\\n    return None"
        },
        {
            "key_id": 36,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/play_move",
            "imports": [
                "from random import choice"
            ],
            "code": "def play_move(self, board):\\n    my_pawn_1 = board.get_playing_pawn(1)\\n    my_pawn_2 = board.get_playing_pawn(2)\\n\\n    my_pawn_to_move_choice = choice([my_pawn_1, my_pawn_2])\\n    my_pawn_possible_moves = board.get_possible_movement_and_building_positions(my_pawn_to_move_choice)\\n\\n    if not my_pawn_possible_moves:\\n        return None, None, None\\n\\n    my_move_and_build_choice = choice(my_pawn_possible_moves)\\n\\n    my_move_position = my_move_and_build_choice[0]\\n    my_build_position = my_move_and_build_choice[1]\\n\\n    return my_pawn_to_move_choice.order, my_move_position, my_build_position"
        },
        {
            "key_id": 38,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/name",
            "imports": [],
            "code": "def name(self):\\n    return 'Random Player'"
        },
        {
            "key_id": 39,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/place_pawn",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n\n    def place_pawn(self, board: Board, pawn: Pawn) -> tuple[int, int]:\n        possible_positions = board.get_possible_movement_positions(pawn)\n        if possible_positions:\n            return choice(possible_positions)\n        else:\n            raise Exception('No valid positions available for placing pawn')"
        },
        {
            "key_id": 40,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/play_move",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level)\n\n    def play_move(self, board: Board):\n        pawns = [pawn for pawn in board.pawns if pawn.player_number == self.player_number]\n        pawn = choice(pawns)\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        if possible_moves:\n            move_position, build_position = choice(possible_moves)\n            return pawn.order, move_position, build_position\n        else:\n            return None, None, None"
        },
        {
            "key_id": 42,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/name",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def name(self):\n        return 'Basic Player'"
        },
        {
            "key_id": 43,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_ally_pawn",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def get_ally_pawn(self, board: Board, our_pawn: Pawn) -> tuple[Pawn, None]:\n        for pawn in board.pawns:\n            if pawn.player_number == self.player_number and pawn != our_pawn:\n                return pawn, None\n        return None, None"
        },
        {
            "key_id": 44,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_enemy_pawns",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number, log_level)\n\n    def get_enemy_pawns(self, board: Board, our_pawn: Pawn):\n        enemy_pawns = [pawn for pawn in board.pawns if pawn.player_number != self.player_number]\n        return enemy_pawns"
        },
        {
            "key_id": 45,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_winning_moves",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_winning_moves(self, board: Board, pawn: Pawn) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    possible_moves = board.get_possible_movement_and_building_positions(pawn)\n    winning_moves = []\n    for move_position, build_position in possible_moves:\n        if move_position[1] == 3:  # Assuming level 3 is winning condition\n            winning_moves.append((move_position, build_position))\n    return winning_moves"
        },
        {
            "key_id": 46,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/place_pawn",
            "imports": [
                "from random import choice"
            ],
            "code": "def place_pawn(self, board: Board, pawn: Pawn):\n    possible_positions = board.get_possible_movement_positions(pawn)\n    if possible_positions:\n        chosen_position = choice(possible_positions)\n        return chosen_position\n    else:\n        return None, None  # No valid positions available"
        },
        {
            "key_id": 47,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/play_move",
            "imports": [
                "from random import choice"
            ],
            "code": "def play_move(self, board: Board):\n    for pawn_number in [1, 2]:\n        pawn = board.get_playing_pawn(pawn_number)\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        if possible_moves:\n            move_position, build_position = choice(possible_moves)\n            success, message = board.play_move(pawn.order, move_position, build_position)\n            if success:\n                return pawn.order, move_position, build_position\n    return None, None, None  # No valid moves available"
        },
        {
            "key_id": 29,
            "fqn": "santorinai/board_displayer/board_displayer.py/init_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def init_window(player_names):\n    layout = [[sg.Text('Santorini Game Display')], [sg.Graph(canvas_size=(800, 600), graph_bottom_left=(0,0), graph_top_right=(800, 600), key='graph')]]\n    window = sg.Window('Santorini Game', layout, finalize=True)\n    graph = window['graph']\n    for name in player_names:\n        graph.DrawText(name, (10, 10))  # Example positioning\n    return window"
        },
        {
            "key_id": 30,
            "fqn": "santorinai/board_displayer/board_displayer.py/draw_isometric_cube",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def draw_isometric_cube(window: sg.Window, x, y, size, cube_height, color, line_color, line_width):\n    graph = window['graph']\n    points = [(x, y), (x + size, y), (x + size, y + size), (x, y + size), (x, y)]\n    for point in points:\n        graph.DrawLine(point, (point[0], point[1] + cube_height), color=color, width=line_width)\n    graph.DrawPolygon(points, fill_color=color, line_color=line_color)"
        },
        {
            "key_id": 31,
            "fqn": "santorinai/board_displayer/board_displayer.py/update_board",
            "imports": [
                "import PySimpleGUI as sg",
                "from santorinai.board import Board"
            ],
            "code": "def update_board(window: sg.Window, board: Board):\n    for y in range(board.SIZE):\n        for x in range(board.SIZE):\n            cube_height = board.board[y][x]\n            color = 'grey' if cube_height == 0 else 'blue'\n            draw_isometric_cube(window, x, y, TILE_SIZE, cube_height, color, 'black', 2)\n    window.refresh()"
        },
        {
            "key_id": 32,
            "fqn": "santorinai/board_displayer/board_displayer.py/close_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def close_window(window: sg.Window):\n    window.close()"
        }
    ]
}