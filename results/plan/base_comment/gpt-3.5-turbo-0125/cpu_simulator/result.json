{
    "implementation": [
        {
            "key_id": 17,
            "fqn": "src/hardware/basic_components.py/HalfAdder/__init__",
            "imports": [],
            "code": "def __init__(self, input1: bool, input2: bool):\n    self.input1 = input1\n    self.input2 = input2"
        },
        {
            "key_id": 20,
            "fqn": "src/hardware/basic_components.py/FullAdder/__init__",
            "imports": [],
            "code": "def __init__(self, input1: bool, input2: bool, carry_in: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.carry_in = carry_in"
        },
        {
            "key_id": 23,
            "fqn": "src/hardware/basic_components.py/Adder/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], carry_in: bool = False):\n    self.input1 = input1\n    self.input2 = input2\n    self.carry_in = carry_in"
        },
        {
            "key_id": 26,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/__init__",
            "imports": [],
            "code": "def __init__(self, input1: bool, input2: bool):\n    self.input1 = input1\n    self.input2 = input2"
        },
        {
            "key_id": 29,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/__init__",
            "imports": [],
            "code": "def __init__(self, input1: bool, input2: bool, borrow_in: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.borrow_in = borrow_in"
        },
        {
            "key_id": 32,
            "fqn": "src/hardware/basic_components.py/Subtractor/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], borrow_in: bool = False):\n    self.input1 = input1\n    self.input2 = input2\n    self.borrow_in = borrow_in"
        },
        {
            "key_id": 35,
            "fqn": "src/hardware/basic_components.py/Mux/__init__",
            "imports": [],
            "code": "def __init__(self, input1: bool, input2: bool, sel: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.sel = sel"
        },
        {
            "key_id": 37,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], sel: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.sel = sel"
        },
        {
            "key_id": 39,
            "fqn": "src/hardware/basic_components.py/AddSub/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], operation: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.operation = operation"
        },
        {
            "key_id": 43,
            "fqn": "src/hardware/basic_components.py/Decoder/__init__",
            "imports": [],
            "code": "def __init__(self, input: list[bool]):\n    self.input = input"
        },
        {
            "key_id": 45,
            "fqn": "src/hardware/basic_components.py/Control/__init__",
            "imports": [],
            "code": "def __init__(self, input: list[bool]):\n    self.input = input"
        },
        {
            "key_id": 47,
            "fqn": "src/hardware/basic_components.py/Comparison/__init__",
            "imports": [],
            "code": "def __init__(self, control: list[bool], byte: list[bool]):\n    self.control = control\n    self.byte = byte"
        },
        {
            "key_id": 49,
            "fqn": "src/hardware/registers.py/Registers/__init__",
            "imports": [],
            "code": "def __init__(self):\n    self.registers = [0] * 6\n    self.input_register = [0] * 8\n    self.output_register = [0] * 8"
        },
        {
            "key_id": 53,
            "fqn": "src/hardware/alu.py/ALU/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], control1: bool, control2: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.control1 = control1\n    self.control2 = control2"
        },
        {
            "key_id": 49,
            "fqn": "src/hardware/registers.py/Registers/__init__",
            "imports": [],
            "code": "def __init__(self):\n    self.registers = [0] * 6\n    self.input_register = [0] * 8\n    self.output_register = [0] * 8"
        },
        {
            "key_id": 53,
            "fqn": "src/hardware/alu.py/ALU/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], control1: bool, control2: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.control1 = control1\n    self.control2 = control2"
        },
        {
            "key_id": 66,
            "fqn": "src/hardware/cpu.py/CPU/__init__",
            "imports": [
                "from src.hardware.alu import ALU",
                "from src.hardware.gates import and_, or_, not_, nor, nand, xor, xnor",
                "from src.hardware.registers import Registers",
                "from src.hardware.cpu import Cycle"
            ],
            "code": "def __init__(self, program, verbose=True):\n    self.program = program\n    self.verbose = verbose\n    self.alu = ALU([], [], False, False)\n    self.gates = {\n        'and': and_,\n        'or': or_,\n        'not': not_,\n        'nor': nor,\n        'nand': nand,\n        'xor': xor,\n        'xnor': xnor\n    }\n    self.registers = Registers()\n    self.cycle = Cycle(self, program[0])"
        },
        {
            "key_id": 68,
            "fqn": "src/hardware/cpu.py/Cycle/__init__",
            "imports": [],
            "code": "def __init__(self, cpu, program_instruction_byte):\n    self.cpu = cpu\n    self.program_instruction_byte = program_instruction_byte"
        },
        {
            "key_id": 4,
            "fqn": "src/assembler.py/copy_instructions",
            "imports": [],
            "code": "def copy_instructions(line):\n    # For each line determine if it is a copy instruction\n    pass"
        },
        {
            "key_id": 5,
            "fqn": "src/assembler.py/operate_instructions",
            "imports": [],
            "code": "def operate_instructions(line):\n    # For each line determine if it is an operate instruction\n    pass"
        },
        {
            "key_id": 6,
            "fqn": "src/assembler.py/jump_instructions",
            "imports": [],
            "code": "def jump_instructions(line):\n    # For each line determine if it is a jump instruction\n    pass"
        },
        {
            "key_id": 7,
            "fqn": "src/assembler.py/assemble_binary",
            "imports": [],
            "code": "def assemble_binary(filename: str):\n    # Takes in an assembly file and returns binary program\n    pass"
        },
        {
            "key_id": 18,
            "fqn": "src/hardware/basic_components.py/HalfAdder/sum",
            "imports": [],
            "code": "def sum(self) -> bool:\n    return self.input1 ^ self.input2"
        },
        {
            "key_id": 19,
            "fqn": "src/hardware/basic_components.py/HalfAdder/carry",
            "imports": [],
            "code": "def carry(self) -> bool:\n    return self.input1 & self.input2"
        },
        {
            "key_id": 21,
            "fqn": "src/hardware/basic_components.py/FullAdder/sum",
            "imports": [],
            "code": "def sum(self) -> bool:\n    s = self.input1 ^ self.input2 ^ self.carry_in\n    return s"
        },
        {
            "key_id": 22,
            "fqn": "src/hardware/basic_components.py/FullAdder/carry",
            "imports": [],
            "code": "def carry(self) -> bool:\n    c1 = self.input1 & self.input2\n    c2 = self.input1 & self.carry_in\n    c3 = self.input2 & self.carry_in\n    return c1 | c2 | c3"
        },
        {
            "key_id": 24,
            "fqn": "src/hardware/basic_components.py/Adder/sum",
            "imports": [],
            "code": "def sum(self) -> list[bool]:\n    result = []\n    carry = self.carry_in\n    for i in range(len(self.input1)):\n        s = self.input1[i] ^ self.input2[i] ^ carry\n        result.append(s)\n        carry = (self.input1[i] & self.input2[i]) | (self.input1[i] & carry) | (self.input2[i] & carry)\n    return result"
        },
        {
            "key_id": 25,
            "fqn": "src/hardware/basic_components.py/Adder/carry_out",
            "imports": [],
            "code": "def carry_out(self) -> bool:\n    carry = False\n    for i in range(len(self.input1)):\n        if self.input1[i] and self.input2[i] or (self.input1[i] or self.input2[i]) and carry:\n            carry = True\n        else:\n            carry = False\n    return carry"
        },
        {
            "key_id": 27,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/diff",
            "imports": [],
            "code": "def diff(self) -> bool:\n    return self.input1 != self.input2"
        },
        {
            "key_id": 28,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/borrow",
            "imports": [],
            "code": "def borrow(self) -> bool:\n    return not self.input1 and self.input2"
        },
        {
            "key_id": 30,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/diff",
            "imports": [],
            "code": "def diff(self) -> bool:\n    return (self.input1 and not self.input2 and not self.borrow_in) or (not self.input1 and self.input2 and self.borrow_in)"
        },
        {
            "key_id": 31,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/borrow",
            "imports": [],
            "code": "def borrow(self) -> bool:\n    return (not self.input1 and self.input2) or (not self.input1 and self.borrow_in) or (self.input2 and self.borrow_in)"
        },
        {
            "key_id": 33,
            "fqn": "src/hardware/basic_components.py/Subtractor/diff",
            "imports": [],
            "code": "def diff(self) -> list[bool]:\n    result = []\n    borrow = self.borrow_in\n    for i in range(8):\n        diff_bit = self.input1[i] ^ self.input2[i] ^ borrow\n        result.append(diff_bit)\n        borrow = (self.input2[i] & borrow) | ((self.input1[i] ^ self.input2[i]) & borrow)\n    return result"
        },
        {
            "key_id": 34,
            "fqn": "src/hardware/basic_components.py/Subtractor/borrow_out",
            "imports": [],
            "code": "def borrow_out(self) -> bool:\n    borrow = self.borrow_in\n    for i in range(8):\n        borrow = (self.input2[i] & borrow) | ((self.input1[i] ^ self.input2[i]) & borrow)\n    return borrow"
        },
        {
            "key_id": 36,
            "fqn": "src/hardware/basic_components.py/Mux/output",
            "imports": [],
            "code": "def output(self) -> bool:\n    if self.sel:\n        return self.input2\n    else:\n        return self.input1"
        },
        {
            "key_id": 38,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n    result = []\n    for i in range(8):\n        bit = self.input2[i] if self.sel else self.input1[i]\n        result.append(bit)\n    return result"
        },
        {
            "key_id": 40,
            "fqn": "src/hardware/basic_components.py/AddSub/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n    result = []\n    carry = 0\n    for i in range(8):\n        sum_bit = self.input1[i] ^ self.input2[i] ^ carry\n        result.append(sum_bit)\n        carry = (self.input1[i] & self.input2[i]) | (self.input1[i] & carry) | (self.input2[i] & carry)\n    return result"
        },
        {
            "key_id": 41,
            "fqn": "src/hardware/basic_components.py/AddSub/overflow",
            "imports": [],
            "code": "def overflow(self) -> bool:\n    # Logic for overflow detection during addition\n    # Add your implementation here\n    pass"
        },
        {
            "key_id": 42,
            "fqn": "src/hardware/basic_components.py/AddSub/borrow_out",
            "imports": [],
            "code": "def borrow_out(self) -> bool:\n    # Logic for borrow detection during subtraction\n    # Add your implementation here\n    pass"
        },
        {
            "key_id": 44,
            "fqn": "src/hardware/basic_components.py/Decoder/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n    # Logic for decoder output generation\n    # Add your implementation here\n    pass"
        },
        {
            "key_id": 46,
            "fqn": "src/hardware/basic_components.py/Control/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n    # Logic for control output generation\n    # Add your implementation here\n    pass"
        },
        {
            "key_id": 48,
            "fqn": "src/hardware/basic_components.py/Comparison/out",
            "imports": [],
            "code": "def out(self) -> bool:\n    # Logic for output comparison\n    # Add your implementation here\n    pass"
        },
        {
            "key_id": 50,
            "fqn": "src/hardware/registers.py/Registers/read",
            "imports": [],
            "code": "def read(self):\n    return self.registers"
        },
        {
            "key_id": 51,
            "fqn": "src/hardware/registers.py/Registers/write",
            "imports": [],
            "code": "def write(self, data):\n    self.registers = data"
        },
        {
            "key_id": 52,
            "fqn": "src/hardware/registers.py/Registers/write_to_register",
            "imports": [],
            "code": "def write_to_register(self, register, data):\n    self.registers[register] = data"
        },
        {
            "key_id": 54,
            "fqn": "src/hardware/alu.py/ALU/out",
            "imports": [],
            "code": "def out(self):\n    # Perform ALU operations based on input1, input2, control1, control2\n    # Return the output of the ALU"
        },
        {
            "key_id": 55,
            "fqn": "src/hardware/alu.py/ALU/zero",
            "imports": [],
            "code": "def zero(self):\n    # Check if all the output bits are False\n    # Return True if all bits are False, False otherwise"
        },
        {
            "key_id": 56,
            "fqn": "src/hardware/alu.py/ALU/negative",
            "imports": [],
            "code": "def negative(self):\n    # Check if the result of the ALU operation is negative\n    return self.out()[-1]"
        },
        {
            "key_id": 57,
            "fqn": "src/hardware/alu.py/ALU/overflow",
            "imports": [],
            "code": "def overflow(self):\n    # Check if the result of the ALU operation has overflowed\n    return self.carry_out()"
        },
        {
            "key_id": 58,
            "fqn": "src/hardware/alu.py/ALU/carry_out",
            "imports": [],
            "code": "def carry_out(self):\n    # Check if the result of the ALU operation has a carry out\n    return self.carry_out()"
        },
        {
            "key_id": 59,
            "fqn": "src/hardware/gates.py/and_",
            "imports": [],
            "code": "def and_(*args) -> int:\n    # Perform AND operation on the input bits\n    return int(all(args))"
        },
        {
            "key_id": 60,
            "fqn": "src/hardware/gates.py/or_",
            "imports": [],
            "code": "def or_(*args) -> int:\n    # Perform OR operation on the input bits\n    return int(any(args))"
        },
        {
            "key_id": 61,
            "fqn": "src/hardware/gates.py/not_",
            "imports": [],
            "code": "def not_(*args) -> int:\n    result = 1\n    for arg in args:\n        result &= ~arg\n    return result"
        },
        {
            "key_id": 62,
            "fqn": "src/hardware/gates.py/nor",
            "imports": [],
            "code": "def nor(*args) -> int:\n    result = 1\n    for arg in args:\n        result &= ~arg\n    return ~result"
        },
        {
            "key_id": 63,
            "fqn": "src/hardware/gates.py/nand",
            "imports": [],
            "code": "def nand(*args) -> int:\n    result = 1\n    for arg in args:\n        result &= arg\n    return ~result"
        },
        {
            "key_id": 64,
            "fqn": "src/hardware/gates.py/xor",
            "imports": [],
            "code": "def xor(a: bool, b: bool) -> int:\n    return int(a) ^ int(b)"
        },
        {
            "key_id": 65,
            "fqn": "src/hardware/gates.py/xnor",
            "imports": [],
            "code": "def xnor(a: bool, b: bool) -> int:\n    return int(not (a ^ b))"
        },
        {
            "key_id": 50,
            "fqn": "src/hardware/registers.py/Registers/read",
            "imports": [],
            "code": "def read(self):\n    return self.registers"
        },
        {
            "key_id": 51,
            "fqn": "src/hardware/registers.py/Registers/write",
            "imports": [],
            "code": "def write(self, data):\n    self.registers = data"
        },
        {
            "key_id": 52,
            "fqn": "src/hardware/registers.py/Registers/write_to_register",
            "imports": [],
            "code": "def write_to_register(self, register, data):\n    self.registers[register] = data"
        },
        {
            "key_id": 54,
            "fqn": "src/hardware/alu.py/ALU/out",
            "imports": [
                "from hardware.gates import and_",
                "from hardware.gates import or_",
                "from hardware.gates import not_",
                "from hardware.gates import nor",
                "from hardware.gates import nand",
                "from hardware.gates import xor",
                "from hardware.gates import xnor"
            ],
            "code": "def out(self):\n    # Perform ALU operations based on input1, input2, control1, and control2\n    # Return the output of the ALU"
        },
        {
            "key_id": 55,
            "fqn": "src/hardware/alu.py/ALU/zero",
            "imports": [
                "from hardware.gates import and_",
                "from hardware.gates import or_",
                "from hardware.gates import not_",
                "from hardware.gates import nor",
                "from hardware.gates import nand",
                "from hardware.gates import xor",
                "from hardware.gates import xnor"
            ],
            "code": "def zero(self):\n    # Check if all output bits are False\n    # Return True if all output bits are False, else False"
        },
        {
            "key_id": 56,
            "fqn": "src/hardware/alu.py/ALU/negative",
            "imports": [
                "from hardware.gates import and_"
            ],
            "code": "def negative(self):\n    result = and_(*self.input2)\n    return result"
        },
        {
            "key_id": 57,
            "fqn": "src/hardware/alu.py/ALU/overflow",
            "imports": [
                "from hardware.gates import or_"
            ],
            "code": "def overflow(self):\n    result = or_(*self.input2)\n    return result"
        },
        {
            "key_id": 58,
            "fqn": "src/hardware/alu.py/ALU/carry_out",
            "imports": [
                "from hardware.gates import or_"
            ],
            "code": "def carry_out(self):\n    result = or_(*self.input2)\n    return result"
        },
        {
            "key_id": 59,
            "fqn": "src/hardware/gates.py/and_",
            "imports": [],
            "code": "def and_(*args) -> int:\n    # Implementation logic for AND gate"
        },
        {
            "key_id": 60,
            "fqn": "src/hardware/gates.py/or_",
            "imports": [],
            "code": "def or_(*args) -> int:\n    # Implementation logic for OR gate"
        },
        {
            "key_id": 61,
            "fqn": "src/hardware/gates.py/not_",
            "imports": [],
            "code": "def not_(*args) -> int:\n    result = 1\n    for arg in args:\n        result = result & (not arg)\n    return int(result)"
        },
        {
            "key_id": 62,
            "fqn": "src/hardware/gates.py/nor",
            "imports": [],
            "code": "def nor(*args) -> int:\n    result = 1\n    for arg in args:\n        result = result & (not arg)\n    return int(not result)"
        },
        {
            "key_id": 63,
            "fqn": "src/hardware/gates.py/nand",
            "imports": [],
            "code": "def nand(*args) -> int:\n    result = 1\n    for arg in args:\n        result = result & arg\n    return int(not result)"
        },
        {
            "key_id": 64,
            "fqn": "src/hardware/gates.py/xor",
            "imports": [],
            "code": "def xor(a: bool, b: bool) -> int:\n    return int(a ^ b)"
        },
        {
            "key_id": 65,
            "fqn": "src/hardware/gates.py/xnor",
            "imports": [],
            "code": "def xnor(a: bool, b: bool) -> int:\n    return int(not (a ^ b))"
        },
        {
            "key_id": 0,
            "fqn": "src/run.py/write_to_input",
            "imports": [],
            "code": "def write_to_input():\n    return [0, 0, 0, 0, 0, 0, 0, 1]"
        },
        {
            "key_id": 1,
            "fqn": "src/run.py/read_from_output",
            "imports": [],
            "code": "def read_from_output(value):\n    if value != [0, 0, 0, 0, 0, 0, 0, 0]:\n        print('result:', value)"
        },
        {
            "key_id": 2,
            "fqn": "src/assembler.py/get_labels",
            "imports": [],
            "code": "def get_labels(file) -> dict:\n    # Finds the positions of each label relative to the pc\n    pass"
        },
        {
            "key_id": 67,
            "fqn": "src/hardware/cpu.py/CPU/run",
            "imports": [
                "from hardware.cpu import CPU",
                "from hardware.alu import ALU",
                "from hardware.registers import Registers",
                "from hardware.cpu import Cycle",
                "from hardware.gates import and_, or_, not_, nor, nand, xor, xnor"
            ],
            "code": "def run(self, write_to_input: callable = None, read_from_output: callable = None):\n    self.program = program\n    self.verbose = verbose\n    self.alu = ALU([], [], False, False)\n    self.gates = {\n        'and': and_,\n        'or': or_,\n        'not': not_,\n        'nor': nor,\n        'nand': nand,\n        'xor': xor,\n        'xnor': xnor\n    }\n    self.registers = Registers()\n    self.cycle = Cycle(self, program[0])"
        },
        {
            "key_id": 69,
            "fqn": "src/hardware/cpu.py/Cycle/execute",
            "imports": [],
            "code": "def execute(self):\n    pass"
        },
        {
            "key_id": 3,
            "fqn": "src/assembler.py/immediate_values",
            "imports": [],
            "code": "def immediate_values(line, labels):\n    # For each line determine if it is an immediate value\n    pass"
        },
        {
            "key_id": 9,
            "fqn": "src/games/maze.py/Robot/event_check",
            "imports": [],
            "code": "def event_check(self):\n    # Implementation for event check function\n    pass"
        },
        {
            "key_id": 10,
            "fqn": "src/games/maze.py/Robot/move_forward",
            "imports": [],
            "code": "def move_forward(self):\n    # Implementation for moving the robot forward\n    pass"
        },
        {
            "key_id": 11,
            "fqn": "src/games/maze.py/Robot/turn_left",
            "imports": [],
            "code": "def turn_left(self):\n    # Implementation for turning the robot left\n    pass"
        },
        {
            "key_id": 12,
            "fqn": "src/games/maze.py/Robot/turn_right",
            "imports": [],
            "code": "def turn_right(self):\n    # Implementation for turning the robot right\n    pass"
        },
        {
            "key_id": 13,
            "fqn": "src/games/maze.py/Robot/move",
            "imports": [],
            "code": "def move(self, instruction):\n    if instruction == 0:  # Move forward\n        self.move_forward()\n    elif instruction == 1:  # Turn left\n        self.turn_left()\n    elif instruction == 2:  # Turn right\n        self.turn_right()"
        },
        {
            "key_id": 14,
            "fqn": "src/games/maze.py/Robot/get_front_cell",
            "imports": [],
            "code": "def get_front_cell(self):\n    return self.maze[self.front_cell[0]][self.front_cell[1]]"
        },
        {
            "key_id": 15,
            "fqn": "src/games/maze.py/Robot/get_front_cell_bit",
            "imports": [],
            "code": "def get_front_cell_bit(self):\n    return self.get_front_cell() == 1"
        }
    ]
}