{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/__init__",
            "imports": [
                "from argparse import ArgumentParser, Namespace, Action",
                "from typing import List, Sequence",
                "import sys"
            ],
            "code": "def __init__(self, parser: ArgumentParser, namespace: Namespace, indent: int = 4):\n    self.parser = parser\n    self.namespace = namespace\n    self.indent = indent\n    self.args: List[List[str]] = []\n    self.BOOLEAN_OPTIONAL_ACTION_MINOR_VERSION = 9\n    self.SHORT_OPTION_LENGTH = 2\n    self._unparse_args()"
        },
        {
            "key_id": 12,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_indent_str",
            "imports": [],
            "code": "def _indent_str(self) -> str:\n    return \" \" * self.indent"
        },
        {
            "key_id": 23,
            "fqn": "reverse_argparse/reverse_argparse.py/quote_arg_if_necessary",
            "imports": [
                "import shlex"
            ],
            "code": "def quote_arg_if_necessary(arg: str) -> str:\n    if any(char.isspace() for char in arg) or any(char in \"\\\"'\" for char in arg):\n        return shlex.quote(arg)\n    return arg"
        },
        {
            "key_id": 6,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_get_long_option_strings",
            "imports": [
                "from typing import Sequence, List"
            ],
            "code": "def _get_long_option_strings(self, option_strings: Sequence[str]) -> List[str]:\n    return [opt for opt in option_strings if len(opt) > self.SHORT_OPTION_LENGTH]"
        },
        {
            "key_id": 7,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_get_short_option_strings",
            "imports": [
                "from typing import Sequence, List"
            ],
            "code": "def _get_short_option_strings(self, option_strings: Sequence[str]) -> List[str]:\n    return [opt for opt in option_strings if len(opt) == self.SHORT_OPTION_LENGTH]"
        },
        {
            "key_id": 8,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_get_option_string",
            "imports": [
                "from argparse import Action"
            ],
            "code": "def _get_option_string(self, action: Action, prefer_short: bool = False) -> str:\n    if prefer_short:\n        short_options = self._get_short_option_strings(action.option_strings)\n        if short_options:\n            return short_options[0]\n    long_options = self._get_long_option_strings(action.option_strings)\n    if long_options:\n        return long_options[0]\n    short_options = self._get_short_option_strings(action.option_strings)\n    if short_options:\n        return short_options[0]\n    return action.option_strings[0] if action.option_strings else \"\""
        },
        {
            "key_id": 9,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_append_list_of_list_of_args",
            "imports": [],
            "code": "def _append_list_of_list_of_args(self, args: List[List[str]]) -> None:\n    for arg_list in args:\n        self._append_list_of_args(arg_list)\n    self.args.append([])"
        },
        {
            "key_id": 10,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_append_list_of_args",
            "imports": [],
            "code": "def _append_list_of_args(self, args: List[str]) -> None:\n    if not self.args:\n        self.args.append([])\n    for arg in args:\n        self._append_arg(arg)\n    self.args[-1].append(self._indent_str())"
        },
        {
            "key_id": 11,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_append_arg",
            "imports": [],
            "code": "def _append_arg(self, arg: str) -> None:\n    if not self.args:\n        self.args.append([])\n    self.args[-1].append(quote_arg_if_necessary(arg))"
        },
        {
            "key_id": 13,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_action",
            "imports": [],
            "code": "def _unparse_store_action(self, action: Action) -> None:\n    if self._arg_is_default_and_help_is_suppressed(action):\n        return\n    value = getattr(self.namespace, action.dest)\n    if value is not None:\n        option_string = self._get_option_string(action)\n        if action.nargs in (None, 1):\n            self._append_arg(option_string)\n            self._append_arg(str(value))\n        elif action.nargs == '?':\n            if value != action.default:\n                self._append_arg(option_string)\n                self._append_arg(str(value))\n        else:\n            self._append_arg(option_string)\n            for item in value:\n                self._append_arg(str(item))"
        },
        {
            "key_id": 14,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_const_action",
            "imports": [],
            "code": "def _unparse_store_const_action(self, action: Action) -> None:\n    if self._arg_is_default_and_help_is_suppressed(action):\n        return\n    value = getattr(self.namespace, action.dest)\n    if value == action.const:\n        option_string = self._get_option_string(action)\n        self._append_arg(option_string)"
        },
        {
            "key_id": 15,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_true_action",
            "imports": [
                "from argparse import Action",
                "from typing import List"
            ],
            "code": "def _unparse_store_true_action(self, action: Action) -> None:\n    if not self._arg_is_default_and_help_is_suppressed(action):\n        if getattr(self.namespace, action.dest):\n            option_string = self._get_option_string(action)\n            self._append_arg(option_string)"
        },
        {
            "key_id": 16,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_store_false_action",
            "imports": [
                "from argparse import Action",
                "from typing import List"
            ],
            "code": "def _unparse_store_false_action(self, action: Action) -> None:\n    if not self._arg_is_default_and_help_is_suppressed(action):\n        if not getattr(self.namespace, action.dest):\n            option_string = self._get_option_string(action)\n            self._append_arg(option_string)"
        },
        {
            "key_id": 17,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_append_action",
            "imports": [
                "from argparse import Action",
                "from typing import List"
            ],
            "code": "def _unparse_append_action(self, action: Action) -> None:\n    if not self._arg_is_default_and_help_is_suppressed(action):\n        values = getattr(self.namespace, action.dest)\n        if values is not None:\n            option_string = self._get_option_string(action)\n            for value in values:\n                args = [option_string, quote_arg_if_necessary(str(value))]\n                self._append_list_of_args(args)"
        },
        {
            "key_id": 18,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_append_const_action",
            "imports": [
                "from argparse import Action",
                "from typing import List"
            ],
            "code": "def _unparse_append_const_action(self, action: Action) -> None:\n    if not self._arg_is_default_and_help_is_suppressed(action):\n        values = getattr(self.namespace, action.dest)\n        if values is not None:\n            option_string = self._get_option_string(action)\n            for _ in range(len(values)):\n                self._append_arg(option_string)"
        },
        {
            "key_id": 19,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_count_action",
            "imports": [
                "from argparse import Action",
                "from typing import List"
            ],
            "code": "def _unparse_count_action(self, action: Action) -> None:\n    if not self._arg_is_default_and_help_is_suppressed(action):\n        count = getattr(self.namespace, action.dest)\n        if count is not None and count > 0:\n            option_string = self._get_option_string(action)\n            for _ in range(count):\n                self._append_arg(option_string)"
        },
        {
            "key_id": 20,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_sub_parsers_action",
            "imports": [
                "from argparse import Action, ArgumentParser, Namespace",
                "from typing import List, Sequence",
                "import sys"
            ],
            "code": "def _unparse_sub_parsers_action(self, action: Action) -> None:\n    if not isinstance(action.choices, dict):\n        return\n\n    for name, subparser in action.choices.items():\n        if name == getattr(self.namespace, action.dest):\n            option_string = self._get_option_string(action)\n            self._append_arg(option_string)\n            self._append_arg(name)\n            sub_namespace = getattr(self.namespace, name)\n            sub_unparser = ReverseArgumentParser(subparser, sub_namespace, self.indent)\n            sub_args = sub_unparser.get_effective_command_line_invocation().split()\n            self._append_list_of_list_of_args([sub_args])\n            break"
        },
        {
            "key_id": 21,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_extend_action",
            "imports": [
                "from argparse import Action",
                "from typing import List",
                "from reverse_argparse.reverse_argparse import quote_arg_if_necessary"
            ],
            "code": "def _unparse_extend_action(self, action: Action) -> None:\n    values = getattr(self.namespace, action.dest)\n    if not values:\n        return\n\n    option_string = self._get_option_string(action)\n    for value in values:\n        if isinstance(value, list):\n            self._append_list_of_args([option_string] + [quote_arg_if_necessary(str(v)) for v in value])\n        else:\n            self._append_list_of_args([option_string, quote_arg_if_necessary(str(value))])"
        },
        {
            "key_id": 22,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_boolean_optional_action",
            "imports": [
                "from argparse import Action",
                "import sys"
            ],
            "code": "def _unparse_boolean_optional_action(self, action: Action) -> None:\n    if sys.version_info.minor >= self.BOOLEAN_OPTIONAL_ACTION_MINOR_VERSION:\n        value = getattr(self.namespace, action.dest)\n        if value is not None:\n            option_string = self._get_option_string(action, prefer_short=True)\n            if value:\n                self._append_arg(option_string)\n            else:\n                no_prefix = '--no-'\n                long_option = self._get_long_option_strings(action.option_strings)[0]\n                self._append_arg(f\"{no_prefix}{long_option[2:]}\")\n    else:\n        raise NotImplementedError(\"BooleanOptionalAction is not supported in this Python version.\")"
        },
        {
            "key_id": 1,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_args",
            "imports": [
                "from argparse import Action"
            ],
            "code": "def _unparse_args(self) -> None:\n    for action in self.parser._actions:\n        if not self._arg_is_default_and_help_is_suppressed(action):\n            self._unparse_action(action)"
        },
        {
            "key_id": 2,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_unparse_action",
            "imports": [
                "from argparse import Action, _StoreAction, _StoreTrueAction, _StoreFalseAction, _AppendAction, _AppendConstAction, _CountAction, _ExtendAction",
                "import sys"
            ],
            "code": "def _unparse_action(self, action: Action) -> None:\n    if isinstance(action, _StoreAction):\n        self._unparse_store_action(action)\n    elif isinstance(action, _StoreTrueAction):\n        self._unparse_store_true_action(action)\n    elif isinstance(action, _StoreFalseAction):\n        self._unparse_store_false_action(action)\n    elif isinstance(action, _AppendAction):\n        self._unparse_append_action(action)\n    elif isinstance(action, _AppendConstAction):\n        self._unparse_append_const_action(action)\n    elif isinstance(action, _CountAction):\n        self._unparse_count_action(action)\n    elif action.choices is not None and isinstance(action.choices, dict):\n        self._unparse_sub_parsers_action(action)\n    elif sys.version_info >= (3, 8) and isinstance(action, _ExtendAction):\n        self._unparse_extend_action(action)\n    elif sys.version_info >= (3, 9) and action.__class__.__name__ == 'BooleanOptionalAction':\n        self._unparse_boolean_optional_action(action)\n    else:\n        raise NotImplementedError(f\"Unsupported action type: {type(action)}\")"
        },
        {
            "key_id": 3,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/_arg_is_default_and_help_is_suppressed",
            "imports": [
                "from argparse import Action, SUPPRESS"
            ],
            "code": "def _arg_is_default_and_help_is_suppressed(self, action: Action) -> bool:\n    if action.help is SUPPRESS:\n        return False\n    \n    if action.default is None:\n        return False\n    \n    if isinstance(action.default, (list, tuple)):\n        return len(action.default) == 0\n    \n    if hasattr(self.namespace, action.dest):\n        value = getattr(self.namespace, action.dest)\n        return value == action.default\n    \n    return False"
        },
        {
            "key_id": 4,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/get_effective_command_line_invocation",
            "imports": [
                "import sys",
                "from typing import List"
            ],
            "code": "def get_effective_command_line_invocation(self) -> str:\n    self._unparse_args()\n    flattened_args: List[str] = []\n    for arg_group in self.args:\n        flattened_args.extend(arg_group)\n    \n    script_name = sys.argv[0] if sys.argv else \"script.py\"\n    command = [script_name] + flattened_args\n    return \" \".join(command)"
        },
        {
            "key_id": 5,
            "fqn": "reverse_argparse/reverse_argparse.py/ReverseArgumentParser/get_pretty_command_line_invocation",
            "imports": [
                "import sys",
                "from typing import List"
            ],
            "code": "def get_pretty_command_line_invocation(self) -> str:\n    effective_command = self.get_effective_command_line_invocation()\n    parts = effective_command.split()\n    script_name = parts[0]\n    args = parts[1:]\n    \n    pretty_command = [script_name]\n    current_line = self._indent_str()\n    \n    for arg in args:\n        if len(current_line) + len(arg) + 1 > 80:  # +1 for space\n            pretty_command.append(current_line.rstrip())\n            current_line = self._indent_str()\n        current_line += arg + \" \"\n    \n    if current_line.strip():\n        pretty_command.append(current_line.rstrip())\n    \n    return \" \\\n\".join(pretty_command)"
        }
    ]
}