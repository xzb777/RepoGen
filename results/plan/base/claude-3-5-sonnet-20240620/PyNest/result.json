{
    "implementation": [
        {
            "key_id": 3,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/__init__",
            "imports": [
                "from typing import Union",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.core.decorators.module import Module",
                "from nest.core.module_compiler import ModuleCompiler"
            ],
            "code": "def __init__(self, container: PyNestContainer, context_module: Union[Module, None] = None):\n    self._container = container\n    self._context_module = context_module\n    self._is_initialized = False\n    self._module_compiler = ModuleCompiler()"
        },
        {
            "key_id": 30,
            "fqn": "nest/core/pynest_application.py/PyNestApp/__init__",
            "imports": [
                "from fastapi import FastAPI",
                "from nest.core.pynest_container import PyNestContainer"
            ],
            "code": "def __init__(self, container: PyNestContainer, http_server: FastAPI):\n    self._container = container\n    self._http_server = http_server\n    self._is_listening = False"
        },
        {
            "key_id": 9,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/__init__",
            "imports": [
                "from typing import Dict, List, Any",
                "from nest.core.module_token_factory import ModuleTokenFactory",
                "from nest.core.module_compiler import ModuleCompiler"
            ],
            "code": "def __init__(self):\n    self._instance = None\n    self._dependencies: Dict[str, Any] = {}\n    self._modules: Dict[str, Any] = {}\n    self._modules_metadata: Dict[str, Any] = {}\n    self._module_token_factory = ModuleTokenFactory()\n    self._module_compiler = ModuleCompiler()"
        },
        {
            "key_id": 55,
            "fqn": "nest/core/decorators/module.py/Module/__init__",
            "imports": [
                "from typing import List, Optional"
            ],
            "code": "def __init__(self, imports: Optional[List] = None, controllers: Optional[List] = None, providers: Optional[List] = None, exports: Optional[List] = None, is_global: bool = False):\n    self.imports = imports or []\n    self.controllers = controllers or []\n    self.providers = providers or []\n    self.exports = exports or []\n    self.is_global = is_global"
        },
        {
            "key_id": 63,
            "fqn": "nest/core/database/base_config.py/ConfigFactoryBase/__init__",
            "imports": [],
            "code": "def __init__(self, db_type: str):\n    self.db_type = db_type\n    self.config_map = {}\n\n    if not hasattr(self, 'register_configs'):\n        raise NotImplementedError(\"Subclasses must implement register_configs method\")\n    \n    self.register_configs()"
        },
        {
            "key_id": 66,
            "fqn": "nest/core/database/base_config.py/BaseProvider/__init__",
            "imports": [
                "from typing import Optional"
            ],
            "code": "def __init__(self, host: str, db_name: str, user: Optional[str] = None, password: Optional[str] = None, port: int = 5432):\n    self.host = host\n    self.db_name = db_name\n    self.user = user\n    self.password = password\n    self.port = port"
        },
        {
            "key_id": 68,
            "fqn": "nest/core/database/odm_provider.py/OdmProvider/__init__",
            "imports": [
                "from typing import List, Optional",
                "from beanie import Document",
                "from motor.motor_asyncio import AsyncIOMotorClient",
                "from nest.core.database.base_config import ConfigFactoryBase"
            ],
            "code": "def __init__(self, db_type: str = \"mongodb\", config_params: Optional[dict] = None, document_models: Optional[List[Document]] = None):\n    self.db_type = db_type\n    self.config_params = config_params or {}\n    self.document_models = document_models or []\n    self.config_factory = ConfigFactoryBase(self.db_type)\n    self.config = self.config_factory.get_config()\n    self.config_url = self.config.get_engine_url()\n    self.client = AsyncIOMotorClient(self.config_url)\n    self.db = self.client[self.config.db_name]\n    self.check_document_models()"
        },
        {
            "key_id": 70,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/__init__",
            "imports": [
                "from typing import Optional",
                "from sqlalchemy import create_engine",
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession",
                "from nest.core.database.base_config import ConfigFactoryBase"
            ],
            "code": "def __init__(self, db_type: str = \"postgresql\", config_params: Optional[dict] = None, async_mode: bool = False, **kwargs):\n    self.db_type = db_type\n    self.config_params = config_params or {}\n    self.async_mode = async_mode\n    self.config_factory = ConfigFactoryBase(self.db_type)\n    self.config = self.config_factory.get_config()\n    self.engine_url = self.config.get_engine_url()\n    \n    if self.async_mode:\n        self.engine = create_async_engine(self.engine_url, **kwargs)\n        self.session = sessionmaker(self.engine, class_=AsyncSession, expire_on_commit=False)\n    else:\n        self.engine = create_engine(self.engine_url, **kwargs)\n        self.session = sessionmaker(bind=self.engine)"
        },
        {
            "key_id": 74,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/__init__",
            "imports": [
                "from typing import Optional",
                "from nest.core.database.orm_provider import BaseOrmProvider"
            ],
            "code": "def __init__(self, db_type: str = \"postgresql\", config_params: Optional[dict] = None):\n    super().__init__(db_type=db_type, config_params=config_params, async_mode=False)"
        },
        {
            "key_id": 78,
            "fqn": "nest/core/database/orm_provider.py/AsyncOrmProvider/__init__",
            "imports": [
                "from typing import Optional",
                "from nest.core.database.orm_provider import BaseOrmProvider"
            ],
            "code": "def __init__(self, db_type: str = \"postgresql\", config_params: Optional[dict] = None, **kwargs):\n    super().__init__(db_type=db_type, config_params=config_params, async_mode=True, **kwargs)"
        },
        {
            "key_id": 79,
            "fqn": "nest/core/database/odm_config.py/MongoDBConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider"
            ],
            "code": "class MongoDBConfig(BaseProvider):\n    def __init__(self, host: str, db_name: str, user: str = None, password: str = None, port: int = 27017, srv: bool = False):\n        super().__init__(host, db_name, user, password, port)\n        self.srv = srv\n\n    def get_engine_url(self) -> str:\n        scheme = \"mongodb+srv\" if self.srv else \"mongodb\"\n        auth = f\"{self.user}:{self.password}@\" if self.user and self.password else \"\"\n        return f\"{scheme}://{auth}{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 81,
            "fqn": "nest/core/database/odm_config.py/ConfigFactory/__init__",
            "imports": [
                "from nest.core.database.base_config import ConfigFactoryBase",
                "from nest.core.database.odm_config import MongoDBConfig"
            ],
            "code": "class ConfigFactory(ConfigFactoryBase):\n    def __init__(self, db_type: str):\n        super().__init__(db_type)\n\n    def get_config(self):\n        if self.db_type.lower() == \"mongodb\":\n            return MongoDBConfig\n        else:\n            raise ValueError(f\"Unsupported database type: {self.db_type}\")"
        },
        {
            "key_id": 83,
            "fqn": "nest/core/database/orm_config.py/PostgresConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider"
            ],
            "code": "class PostgresConfig(BaseProvider):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        super().__init__(host, db_name, user, password, port)\n\n    def get_engine_url(self) -> str:\n        return f\"postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 85,
            "fqn": "nest/core/database/orm_config.py/MySQLConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider"
            ],
            "code": "class MySQLConfig(BaseProvider):\n    def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n        super().__init__(host, db_name, user, password, port)\n\n    def get_engine_url(self) -> str:\n        return f\"mysql+pymysql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 87,
            "fqn": "nest/core/database/orm_config.py/SQLiteConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider"
            ],
            "code": "class SQLiteConfig(BaseProvider):\n    def __init__(self, db_name: str):\n        super().__init__(host=\"\", db_name=db_name, user=\"\", password=\"\", port=0)\n\n    def get_engine_url(self) -> str:\n        return f\"sqlite:///{self.db_name}.db\""
        },
        {
            "key_id": 89,
            "fqn": "nest/core/database/orm_config.py/AsyncSQLiteConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider"
            ],
            "code": "def __init__(self, db_name: str):\n    super().__init__(host=\"\", db_name=db_name, user=\"\", password=\"\", port=0)\n    self.db_name = db_name"
        },
        {
            "key_id": 91,
            "fqn": "nest/core/database/orm_config.py/AsyncPostgresConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider"
            ],
            "code": "def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n    super().__init__(host, db_name, user, password, port)\n    self.host = host\n    self.db_name = db_name\n    self.user = user\n    self.password = password\n    self.port = port"
        },
        {
            "key_id": 93,
            "fqn": "nest/core/database/orm_config.py/AsyncMySQLConfig/__init__",
            "imports": [
                "from nest.core.database.base_config import BaseProvider"
            ],
            "code": "def __init__(self, host: str, db_name: str, user: str, password: str, port: int):\n    super().__init__(host, db_name, user, password, port)\n    self.host = host\n    self.db_name = db_name\n    self.user = user\n    self.password = password\n    self.port = port"
        },
        {
            "key_id": 95,
            "fqn": "nest/core/database/orm_config.py/ConfigFactory/__init__",
            "imports": [
                "from nest.core.database.base_config import ConfigFactoryBase",
                "from nest.core.database.orm_config import PostgresConfig, MySQLConfig, SQLiteConfig"
            ],
            "code": "def __init__(self, db_type: str):\n    super().__init__(db_type)\n    self.db_type = db_type\n    self.config_map = {\n        \"postgresql\": PostgresConfig,\n        \"mysql\": MySQLConfig,\n        \"sqlite\": SQLiteConfig\n    }"
        },
        {
            "key_id": 97,
            "fqn": "nest/core/database/orm_config.py/AsyncConfigFactory/__init__",
            "imports": [
                "from nest.core.database.base_config import ConfigFactoryBase",
                "from nest.core.database.orm_config import AsyncPostgresConfig, AsyncMySQLConfig, AsyncSQLiteConfig"
            ],
            "code": "def __init__(self, db_type: str):\n    super().__init__(db_type)\n    self.db_type = db_type\n    self.config_map = {\n        \"postgresql\": AsyncPostgresConfig,\n        \"mysql\": AsyncMySQLConfig,\n        \"sqlite\": AsyncSQLiteConfig\n    }"
        },
        {
            "key_id": 0,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
            "imports": [],
            "code": "def is_initialized(self) -> bool:\n    return self._is_initialized"
        },
        {
            "key_id": 1,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/is_initialized",
            "imports": [],
            "code": "def is_initialized(self, value: bool) -> None:\n    self._is_initialized = value"
        },
        {
            "key_id": 2,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/init",
            "imports": [],
            "code": "def init(self) -> None:\n    if self.is_initialized():\n        return\n    \n    self.select_context_module()\n    self._module_compiler.compile(self._container, self._context_module)\n    self.is_initialized(True)"
        },
        {
            "key_id": 4,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/select_context_module",
            "imports": [],
            "code": "def select_context_module(self) -> None:\n    if self._context_module is None:\n        modules = self._container.modules()\n        if not modules:\n            raise ValueError(\"No modules found in the container\")\n        self._context_module = modules[0]"
        },
        {
            "key_id": 5,
            "fqn": "nest/core/pynest_app_context.py/PyNestApplicationContext/select",
            "imports": [
                "from typing import TypeVar, Type"
            ],
            "code": "T = TypeVar('T')\n\ndef select(self, module: Type[T]) -> T:\n    if not self.is_initialized():\n        self.init()\n    \n    instance = self._container.get_instance(module)\n    if instance is None:\n        raise ValueError(f\"Module {module.__name__} not found in the container\")\n    \n    return instance"
        },
        {
            "key_id": 6,
            "fqn": "nest/core/pynest_factory.py/PyNestFactory/create",
            "imports": [
                "from typing import Type, TypeVar",
                "from fastapi import FastAPI",
                "from nest.core.pynest_app_context import PyNestApplicationContext",
                "from nest.core.pynest_container import PyNestContainer",
                "from nest.core.pynest_application import PyNestApp"
            ],
            "code": "ModuleType = TypeVar(\"ModuleType\")\n\n@staticmethod\ndef create(main_module: Type[ModuleType], **kwargs) -> PyNestApp:\n    container = PyNestContainer()\n    context = PyNestApplicationContext(container, main_module)\n    context.init()\n    server = PyNestFactory._create_server(**kwargs)\n    app = PyNestApp(container, server)\n    app.register_routes()\n    return app"
        },
        {
            "key_id": 7,
            "fqn": "nest/core/pynest_factory.py/PyNestFactory/_create_server",
            "imports": [
                "from fastapi import FastAPI",
                "from fastapi.middleware.cors import CORSMiddleware"
            ],
            "code": "@staticmethod\ndef _create_server(**kwargs) -> FastAPI:\n    app = FastAPI(**kwargs)\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n    return app"
        },
        {
            "key_id": 29,
            "fqn": "nest/core/pynest_application.py/PyNestApp/is_listening",
            "imports": [],
            "code": "def is_listening(self) -> bool:\n    return self._is_listening"
        },
        {
            "key_id": 31,
            "fqn": "nest/core/pynest_application.py/PyNestApp/use",
            "imports": [
                "from typing import Type",
                "from starlette.middleware.base import BaseHTTPMiddleware"
            ],
            "code": "def use(self, middleware: Type[BaseHTTPMiddleware], **options) -> \"PyNestApp\":\n    if self._is_listening:\n        raise RuntimeError(\"Cannot add middleware after the application has started listening\")\n    self._http_server.add_middleware(middleware, **options)\n    return self"
        },
        {
            "key_id": 32,
            "fqn": "nest/core/pynest_application.py/PyNestApp/get_server",
            "imports": [
                "from fastapi import FastAPI"
            ],
            "code": "def get_server(self) -> FastAPI:\n    return self._http_server"
        },
        {
            "key_id": 33,
            "fqn": "nest/core/pynest_application.py/PyNestApp/register_routes",
            "imports": [
                "from fastapi import FastAPI",
                "from nest.core.pynest_container import PyNestContainer"
            ],
            "code": "def register_routes(self):\n    for module_token, module in self._container.modules().items():\n        controllers = self._container._get_controllers(module_token)\n        for controller in controllers:\n            controller_instance = self._container.get_instance(controller)\n            prefix = getattr(controller, '__prefix__', '')\n            router = FastAPI()\n            for method_name, method in controller.__dict__.items():\n                if hasattr(method, '__route__'):\n                    route_info = getattr(method, '__route__')\n                    http_method = route_info['method']\n                    path = route_info['path']\n                    full_path = f\"{prefix}{path}\"\n                    router.add_api_route(\n                        path=full_path,\n                        endpoint=getattr(controller_instance, method_name),\n                        methods=[http_method]\n                    )\n            self._http_server.include_router(router)\n    self._is_listening = True"
        },
        {
            "key_id": 8,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/__new__",
            "imports": [],
            "code": "def __new__(cls):\n    if not cls._instance:\n        cls._instance = super().__new__(cls)\n        cls._instance._dependencies = {}\n        cls._instance._modules = {}\n        cls._instance._modules_metadata = {}\n        cls._instance._module_token_factory = ModuleTokenFactory()\n        cls._instance._module_compiler = ModuleCompiler()\n    return cls._instance"
        },
        {
            "key_id": 10,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/modules",
            "imports": [],
            "code": "def modules(self):\n    return self._modules"
        },
        {
            "key_id": 11,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/module_token_factory",
            "imports": [],
            "code": "def module_token_factory(self):\n    return self._module_token_factory"
        },
        {
            "key_id": 12,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/modules_metadata",
            "imports": [],
            "code": "def modules_metadata(self):\n    return self._modules_metadata"
        },
        {
            "key_id": 13,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/module_compiler",
            "imports": [
                "from typing import Dict, Any",
                "from nest.core.module_compiler import ModuleCompiler"
            ],
            "code": "def module_compiler(self) -> ModuleCompiler:\n    if not hasattr(self, '_module_compiler'):\n        self._module_compiler = ModuleCompiler()\n    return self._module_compiler"
        },
        {
            "key_id": 14,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/get_instance",
            "imports": [
                "from typing import Optional, Union, Any",
                "from nest.core.types import TProvider, TController"
            ],
            "code": "def get_instance(self, dependency: TProvider, provider: Optional[Union[TProvider, TController]] = None) -> Any:\n    if isinstance(dependency, type):\n        dependency_key = dependency.__name__\n    else:\n        dependency_key = str(dependency)\n    \n    if dependency_key in self._dependencies:\n        return self._dependencies[dependency_key]\n    \n    if provider is None:\n        provider = dependency\n    \n    if isinstance(provider, type):\n        instance = provider()\n    else:\n        instance = provider\n    \n    self._dependencies[dependency_key] = instance\n    return instance"
        },
        {
            "key_id": 15,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_module",
            "imports": [
                "from typing import Dict, Any",
                "from nest.core.module_factory import ModuleFactory"
            ],
            "code": "def add_module(self, metaclass) -> Dict[str, Any]:\n    module_factory = ModuleFactory(metaclass)\n    module = self.register_module(module_factory)\n    token = self._module_token_factory.create(metaclass)\n    \n    self._modules[token] = module\n    \n    return {\n        \"token\": token,\n        \"module\": module\n    }"
        },
        {
            "key_id": 16,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/register_module",
            "imports": [
                "from nest.core.module import Module",
                "from nest.core.module_factory import ModuleFactory"
            ],
            "code": "def register_module(self, module_factory: ModuleFactory) -> Module:\n    module = module_factory.create()\n    token = self._module_token_factory.create(module.__class__)\n    \n    self.add_metadata(token, module_factory.get_metadata())\n    \n    if hasattr(module, 'imports') and module.imports:\n        for imported_module in module.imports:\n            self.add_module(imported_module)\n    \n    if hasattr(module, 'providers') and module.providers:\n        self.add_providers(module.providers, token)\n    \n    if hasattr(module, 'controllers') and module.controllers:\n        self.add_controllers(module.controllers, token)\n    \n    return module"
        },
        {
            "key_id": 17,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_metadata",
            "imports": [
                "from typing import Any"
            ],
            "code": "def add_metadata(self, token: str, module_metadata: Any) -> None:\n    if token not in self._modules_metadata:\n        self._modules_metadata[token] = {}\n    \n    self._modules_metadata[token].update(module_metadata)"
        },
        {
            "key_id": 18,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_import",
            "imports": [
                "from typing import Dict, Any, List"
            ],
            "code": "def add_import(self, token: str):\n    if token not in self._modules_metadata:\n        self._modules_metadata[token] = {\"imports\": []}\n    else:\n        if \"imports\" not in self._modules_metadata[token]:\n            self._modules_metadata[token][\"imports\"] = []\n    \n    if token not in self._modules_metadata[token][\"imports\"]:\n        self._modules_metadata[token][\"imports\"].append(token)"
        },
        {
            "key_id": 19,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_modules",
            "imports": [
                "from typing import Dict, Any, List"
            ],
            "code": "def add_modules(self, modules: List[Any]) -> None:\n    for module in modules:\n        metaclass = type(module)\n        self.add_module(metaclass)"
        },
        {
            "key_id": 20,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_providers",
            "imports": [
                "from typing import Dict, Any, List"
            ],
            "code": "def add_providers(self, providers: List[Any], module_token: str) -> None:\n    for provider in providers:\n        provider_token = self._module_token_factory.create(provider)\n        self.add_provider(provider_token, provider)\n    \n    existing_providers = self._get_providers(module_token)\n    existing_providers.extend(providers)\n    self._modules[module_token][\"providers\"] = existing_providers"
        },
        {
            "key_id": 21,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_provider",
            "imports": [
                "from typing import Dict, Any"
            ],
            "code": "def add_provider(self, token: str, provider):\n    if token not in self._modules:\n        self._modules[token] = {\"providers\": []}\n    \n    if provider not in self._modules[token][\"providers\"]:\n        self._modules[token][\"providers\"].append(provider)\n    \n    self._dependencies[token] = provider"
        },
        {
            "key_id": 22,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_get_providers",
            "imports": [
                "from typing import Dict, Any, List"
            ],
            "code": "def _get_providers(self, token: str) -> List[Any]:\n    if token not in self._modules:\n        return []\n    \n    return self._modules[token].get(\"providers\", [])"
        },
        {
            "key_id": 23,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_controllers",
            "imports": [
                "from typing import List, Any",
                "from nest.core.pynest_container import TController"
            ],
            "code": "def add_controllers(self, controllers: List[Any], module_token: str) -> None:\n    if not isinstance(controllers, list):\n        raise TypeError(\"Controllers must be provided as a list\")\n    \n    for controller in controllers:\n        if not isinstance(controller, type):\n            raise TypeError(f\"Controller {controller} must be a class\")\n        \n        self._add_controller(module_token, controller)\n    \n    existing_controllers = self._get_controllers(module_token)\n    existing_controllers.extend(controllers)\n    self._modules[module_token]['controllers'] = existing_controllers"
        },
        {
            "key_id": 24,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_add_controller",
            "imports": [
                "from typing import Dict, Any",
                "from nest.core.pynest_container import TController"
            ],
            "code": "def _add_controller(self, token: str, controller: TController) -> None:\n    if token not in self._modules:\n        raise ValueError(f\"Module with token {token} does not exist\")\n    \n    module = self._modules[token]\n    if 'controllers' not in module:\n        module['controllers'] = []\n    \n    if controller not in module['controllers']:\n        module['controllers'].append(controller)\n    \n    # Add controller to dependencies\n    controller_name = controller.__name__\n    if controller_name not in self._dependencies:\n        self._dependencies[controller_name] = controller"
        },
        {
            "key_id": 25,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/_get_controllers",
            "imports": [
                "from typing import List, Any"
            ],
            "code": "def _get_controllers(self, token: str) -> List[Any]:\n    if token not in self._modules:\n        raise ValueError(f\"Module with token {token} does not exist\")\n    \n    module = self._modules[token]\n    return module.get('controllers', [])"
        },
        {
            "key_id": 26,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/clear",
            "imports": [],
            "code": "def clear(self):\n    self._modules.clear()\n    self._modules_metadata.clear()\n    self._dependencies.clear()\n    self._module_token_factory.reset()\n    self._module_compiler.clear()"
        },
        {
            "key_id": 27,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/add_related_module",
            "imports": [
                "from typing import Any"
            ],
            "code": "def add_related_module(self, related_module: Any, token: str) -> None:\n    if token not in self._modules:\n        raise ValueError(f\"Module with token {token} does not exist\")\n    \n    module = self._modules[token]\n    if 'related_modules' not in module:\n        module['related_modules'] = []\n    \n    if related_module not in module['related_modules']:\n        module['related_modules'].append(related_module)\n    \n    # Add related module to dependencies\n    related_module_name = related_module.__name__\n    if related_module_name not in self._dependencies:\n        self._dependencies[related_module_name] = related_module"
        },
        {
            "key_id": 28,
            "fqn": "nest/core/pynest_container.py/PyNestContainer/get_module_by_key",
            "imports": [
                "from typing import Dict, Any",
                "from nest.core.module import Module"
            ],
            "code": "def get_module_by_key(self, module_key: str) -> Module:\n    if module_key not in self._modules:\n        raise KeyError(f\"Module with key '{module_key}' not found\")\n    return self._modules[module_key]"
        },
        {
            "key_id": 34,
            "fqn": "nest/core/decorators/injectable.py/Injectable",
            "imports": [
                "from typing import Optional, Type, Callable",
                "from functools import wraps"
            ],
            "code": "def Injectable(target_class: Optional[Type] = None, *args, **kwargs) -> Callable:\n    def decorator(cls: Type) -> Type:\n        @wraps(cls)\n        def wrapper(*args, **kwargs):\n            return cls(*args, **kwargs)\n        wrapper.__injectable__ = True\n        return wrapper\n    \n    if target_class is None:\n        return decorator\n    return decorator(target_class)"
        },
        {
            "key_id": 35,
            "fqn": "nest/core/decorators/controller.py/Controller",
            "imports": [
                "from typing import Optional, Type",
                "from fastapi import APIRouter",
                "from functools import wraps"
            ],
            "code": "def Controller(prefix: Optional[str] = None, tag: Optional[str] = None):\n    def decorator(cls: Type) -> Type:\n        route_prefix = process_prefix(prefix, tag)\n        router = APIRouter(prefix=route_prefix, tags=[tag] if tag else None)\n        \n        process_dependencies(cls)\n        set_instance_variables(cls)\n        ensure_init_method(cls)\n        add_routes(cls, router, route_prefix)\n        \n        @wraps(cls)\n        def wrapper(*args, **kwargs):\n            instance = cls(*args, **kwargs)\n            instance.router = router\n            return instance\n        \n        wrapper.__controller__ = True\n        wrapper.__prefix__ = route_prefix\n        wrapper.__router__ = router\n        return wrapper\n    return decorator"
        },
        {
            "key_id": 44,
            "fqn": "nest/core/decorators/http_method.py/route",
            "imports": [
                "from typing import Union, List, Callable",
                "from fastapi import APIRouter"
            ],
            "code": "def route(http_method: HTTPMethod, route_path: Union[str, List[str]] = \"/\", **kwargs):\n    def decorator(func: Callable) -> Callable:\n        setattr(func, \"__route__\", {\n            \"method\": http_method,\n            \"path\": route_path,\n            \"kwargs\": kwargs\n        })\n        return func\n    return decorator"
        },
        {
            "key_id": 45,
            "fqn": "nest/core/decorators/http_method.py/Get",
            "imports": [
                "from typing import Union, List, Callable"
            ],
            "code": "def Get(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    return route(HTTPMethod.GET, route_path, **kwargs)"
        },
        {
            "key_id": 46,
            "fqn": "nest/core/decorators/http_method.py/Post",
            "imports": [
                "from typing import Union, List, Callable, Any",
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Post(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    return route(HTTPMethod.POST, route_path, **kwargs)"
        },
        {
            "key_id": 47,
            "fqn": "nest/core/decorators/http_method.py/Delete",
            "imports": [
                "from typing import Union, List, Callable, Any",
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Delete(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    return route(HTTPMethod.DELETE, route_path, **kwargs)"
        },
        {
            "key_id": 48,
            "fqn": "nest/core/decorators/http_method.py/Put",
            "imports": [
                "from typing import Union, List, Callable, Any",
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Put(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    return route(HTTPMethod.PUT, route_path, **kwargs)"
        },
        {
            "key_id": 49,
            "fqn": "nest/core/decorators/http_method.py/Patch",
            "imports": [
                "from typing import Union, List, Callable, Any",
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Patch(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    return route(HTTPMethod.PATCH, route_path, **kwargs)"
        },
        {
            "key_id": 50,
            "fqn": "nest/core/decorators/http_method.py/Head",
            "imports": [
                "from typing import Union, List, Callable, Any",
                "from .http_method import route, HTTPMethod"
            ],
            "code": "def Head(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    return route(HTTPMethod.HEAD, route_path, **kwargs)"
        },
        {
            "key_id": 51,
            "fqn": "nest/core/decorators/http_method.py/Options",
            "imports": [
                "from typing import Union, List, Callable, Any",
                "from nest.core.decorators.http_method import route, HTTPMethod"
            ],
            "code": "def Options(route_path: Union[str, List[str]] = \"/\", **kwargs) -> Callable[..., Any]:\n    return route(HTTPMethod.OPTIONS, route_path, **kwargs)"
        },
        {
            "key_id": 52,
            "fqn": "nest/core/decorators/database.py/db_request_handler",
            "imports": [
                "import logging",
                "from functools import wraps",
                "from sqlalchemy.exc import SQLAlchemyError"
            ],
            "code": "logger = logging.getLogger(__name__)\n\ndef db_request_handler(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except SQLAlchemyError as e:\n            logger.error(f\"Database error occurred: {str(e)}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error occurred: {str(e)}\")\n            raise\n    return wrapper"
        },
        {
            "key_id": 53,
            "fqn": "nest/core/decorators/database.py/async_db_request_handler",
            "imports": [
                "import logging",
                "from functools import wraps",
                "from sqlalchemy.exc import SQLAlchemyError"
            ],
            "code": "logger = logging.getLogger(__name__)\n\ndef async_db_request_handler(func):\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)\n        except SQLAlchemyError as e:\n            logger.error(f\"Database error occurred: {str(e)}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error occurred: {str(e)}\")\n            raise\n    return wrapper"
        },
        {
            "key_id": 54,
            "fqn": "nest/core/decorators/http_code.py/HttpCode",
            "imports": [
                "from typing import Callable",
                "from fastapi import status"
            ],
            "code": "def HttpCode(status_code: int):\n    def decorator(func: Callable) -> Callable:\n        setattr(func, \"status_code\", status_code)\n        return func\n    return decorator"
        },
        {
            "key_id": 56,
            "fqn": "nest/core/decorators/module.py/Module/__call__",
            "imports": [
                "from typing import List, Optional",
                "from nest.core.pynest_container import PyNestContainer"
            ],
            "code": "def __call__(self, cls):\n    setattr(cls, \"__module_metadata__\", {\n        \"imports\": self.imports,\n        \"controllers\": self.controllers,\n        \"providers\": self.providers,\n        \"exports\": self.exports,\n        \"is_global\": self.is_global\n    })\n    \n    PyNestContainer().add_module(cls)\n    \n    return cls"
        },
        {
            "key_id": 57,
            "fqn": "nest/core/decorators/utils.py/get_instance_variables",
            "imports": [
                "from typing import Dict, Any",
                "import inspect"
            ],
            "code": "def get_instance_variables(cls) -> Dict[str, Any]:\n    return {name: value for name, value in inspect.getmembers(cls)\n            if not name.startswith('__') and not inspect.ismethod(value)}"
        },
        {
            "key_id": 58,
            "fqn": "nest/core/decorators/utils.py/get_non_dependencies_params",
            "imports": [
                "from typing import List",
                "import inspect"
            ],
            "code": "def get_non_dependencies_params(cls) -> List[str]:\n    init_signature = inspect.signature(cls.__init__)\n    return [param.name for param in init_signature.parameters.values()\n            if param.name != 'self' and param.annotation == inspect.Parameter.empty]"
        },
        {
            "key_id": 59,
            "fqn": "nest/core/decorators/utils.py/parse_dependencies",
            "imports": [
                "from typing import Dict, Any",
                "import inspect"
            ],
            "code": "def parse_dependencies(cls) -> Dict[str, Any]:\n    init_signature = inspect.signature(cls.__init__)\n    return {param.name: param.annotation for param in init_signature.parameters.values()\n            if param.name != 'self' and param.annotation != inspect.Parameter.empty}"
        },
        {
            "key_id": 60,
            "fqn": "nest/core/decorators/class_based_view.py/class_based_view",
            "imports": [
                "from typing import Type, TypeVar, Callable, Any",
                "from fastapi import APIRouter",
                "from starlette.routing import Route, WebSocketRoute"
            ],
            "code": "T = TypeVar(\"T\")\nK = TypeVar(\"K\", bound=Callable[..., Any])\nCBV_CLASS_KEY = \"__cbv_class__\"\n\ndef class_based_view(router: APIRouter, cls: Type[T]) -> Type[T]:\n    _init_cbv(cls)\n    for route in router.routes:\n        if isinstance(route, (Route, WebSocketRoute)):\n            _update_cbv_route_endpoint_signature(cls, route)\n    return cls"
        },
        {
            "key_id": 61,
            "fqn": "nest/core/decorators/class_based_view.py/_init_cbv",
            "imports": [
                "from typing import Type, Any",
                "import inspect"
            ],
            "code": "def _init_cbv(cls: Type[Any]) -> None:\n    if hasattr(cls, CBV_CLASS_KEY):\n        return\n    old_init = cls.__init__\n    def new_init(self: Any, *args: Any, **kwargs: Any) -> None:\n        for dep in getattr(self, \"dependencies\", []):\n            if not hasattr(self, dep):\n                setattr(self, dep, kwargs.get(dep))\n        old_init(self, *args, **kwargs)\n    cls.__init__ = new_init\n    setattr(cls, CBV_CLASS_KEY, True)"
        },
        {
            "key_id": 62,
            "fqn": "nest/core/decorators/class_based_view.py/_update_cbv_route_endpoint_signature",
            "imports": [
                "from typing import Any, Type, Union",
                "from fastapi import APIRouter",
                "from fastapi.routing import Route, WebSocketRoute",
                "from inspect import signature, Parameter"
            ],
            "code": "def _update_cbv_route_endpoint_signature(cls: Type[Any], route: Union[Route, WebSocketRoute]) -> None:\n    old_endpoint = route.endpoint\n    old_signature = signature(old_endpoint)\n    old_parameters: list[Parameter] = list(old_signature.parameters.values())\n    old_first_parameter = old_parameters[0]\n    new_first_parameter = Parameter(\n        old_first_parameter.name,\n        Parameter.POSITIONAL_OR_KEYWORD,\n        annotation=cls,\n        default=old_first_parameter.default,\n    )\n    new_parameters = [new_first_parameter] + old_parameters[1:]\n    new_signature = old_signature.replace(parameters=new_parameters)\n    setattr(route.endpoint, \"__signature__\", new_signature)"
        },
        {
            "key_id": 64,
            "fqn": "nest/core/database/base_config.py/ConfigFactoryBase/get_config",
            "imports": [],
            "code": "def get_config(self):\n    if self.db_type not in self.config_map:\n        raise ValueError(f\"Unsupported database type: {self.db_type}\")\n    return self.config_map[self.db_type]()"
        },
        {
            "key_id": 65,
            "fqn": "nest/core/database/base_config.py/BaseConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    raise NotImplementedError(\"Subclasses must implement get_engine_url method\")"
        },
        {
            "key_id": 67,
            "fqn": "nest/core/database/base_config.py/BaseProvider/get_engine_url",
            "imports": [
                "from urllib.parse import quote_plus"
            ],
            "code": "def get_engine_url(self) -> str:\n    user_pass = f\"{quote_plus(self.user)}:{quote_plus(self.password)}@\" if self.user and self.password else \"\"\n    return f\"postgresql://{user_pass}{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 69,
            "fqn": "nest/core/database/odm_provider.py/OdmProvider/check_document_models",
            "imports": [
                "from beanie import init_beanie",
                "from motor.motor_asyncio import AsyncIOMotorClient"
            ],
            "code": "def check_document_models(self):\n    if not self.document_models:\n        raise ValueError(\"No document models provided\")\n    \n    async def init_db():\n        await init_beanie(\n            database=self.db,\n            document_models=self.document_models\n        )\n    \n    import asyncio\n    asyncio.get_event_loop().run_until_complete(init_db())"
        },
        {
            "key_id": 71,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/create_all",
            "imports": [
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy import create_engine",
                "from sqlalchemy.ext.declarative import declarative_base"
            ],
            "code": "async def create_all(self):\n    Base = declarative_base()\n    if self.async_mode:\n        async with self.engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)\n    else:\n        Base.metadata.create_all(self.engine)"
        },
        {
            "key_id": 72,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/drop_all",
            "imports": [
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from sqlalchemy.ext.asyncio import create_async_engine",
                "from sqlalchemy import create_engine",
                "from sqlalchemy.ext.declarative import declarative_base"
            ],
            "code": "async def drop_all(self):\n    Base = declarative_base()\n    if self.async_mode:\n        async with self.engine.begin() as conn:\n            await conn.run_sync(Base.metadata.drop_all)\n    else:\n        Base.metadata.drop_all(self.engine)"
        },
        {
            "key_id": 73,
            "fqn": "nest/core/database/orm_provider.py/BaseOrmProvider/get_db",
            "imports": [
                "from sqlalchemy.orm import sessionmaker",
                "from sqlalchemy.ext.asyncio import AsyncSession",
                "from contextlib import contextmanager, asynccontextmanager"
            ],
            "code": "def get_db(self):\n    if self.async_mode:\n        @asynccontextmanager\n        async def get_async_db():\n            async with self.session() as session:\n                try:\n                    yield session\n                    await session.commit()\n                except Exception:\n                    await session.rollback()\n                    raise\n                finally:\n                    await session.close()\n        return get_async_db()\n    else:\n        @contextmanager\n        def get_sync_db():\n            session = self.session()\n            try:\n                yield session\n                session.commit()\n            except Exception:\n                session.rollback()\n                raise\n            finally:\n                session.close()\n        return get_sync_db()"
        },
        {
            "key_id": 75,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/create_all",
            "imports": [
                "from sqlalchemy.ext.declarative import declarative_base"
            ],
            "code": "async def create_all(self):\n    Base = declarative_base()\n    async with self.engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)"
        },
        {
            "key_id": 76,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/drop_all",
            "imports": [
                "from sqlalchemy.ext.declarative import declarative_base"
            ],
            "code": "async def drop_all(self):\n    Base = declarative_base()\n    async with self.engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)"
        },
        {
            "key_id": 77,
            "fqn": "nest/core/database/orm_provider.py/OrmProvider/get_db",
            "imports": [
                "from sqlalchemy.orm import Session"
            ],
            "code": "def get_db(self) -> Session:\n    try:\n        db = self.session()\n        yield db\n    finally:\n        db.close()"
        },
        {
            "key_id": 80,
            "fqn": "nest/core/database/odm_config.py/MongoDBConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    scheme = \"mongodb+srv\" if self.srv else \"mongodb\"\n    auth = f\"{self.user}:{self.password}@\" if self.user and self.password else \"\"\n    return f\"{scheme}://{auth}{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 82,
            "fqn": "nest/core/database/odm_config.py/ConfigFactory/get_config",
            "imports": [
                "from nest.core.database.odm_config import MongoDBConfig"
            ],
            "code": "def get_config(self):\n    if self.db_type.lower() == \"mongodb\":\n        return MongoDBConfig\n    else:\n        raise ValueError(f\"Unsupported database type: {self.db_type}\")"
        },
        {
            "key_id": 84,
            "fqn": "nest/core/database/orm_config.py/PostgresConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f\"postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 86,
            "fqn": "nest/core/database/orm_config.py/MySQLConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f\"mysql+pymysql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 88,
            "fqn": "nest/core/database/orm_config.py/SQLiteConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f\"sqlite:///{self.db_name}.db\""
        },
        {
            "key_id": 90,
            "fqn": "nest/core/database/orm_config.py/AsyncSQLiteConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f\"sqlite+aiosqlite:///{self.db_name}.db\""
        },
        {
            "key_id": 92,
            "fqn": "nest/core/database/orm_config.py/AsyncPostgresConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f\"postgresql+asyncpg://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 94,
            "fqn": "nest/core/database/orm_config.py/AsyncMySQLConfig/get_engine_url",
            "imports": [],
            "code": "def get_engine_url(self) -> str:\n    return f\"mysql+aiomysql://{self.user}:{self.password}@{self.host}:{self.port}/{self.db_name}\""
        },
        {
            "key_id": 96,
            "fqn": "nest/core/database/orm_config.py/ConfigFactory/get_config",
            "imports": [],
            "code": "def get_config(self):\n    config_class = self.config_map.get(self.db_type)\n    if not config_class:\n        raise ValueError(f\"Unsupported database type: {self.db_type}\")\n    return config_class"
        },
        {
            "key_id": 98,
            "fqn": "nest/core/database/orm_config.py/AsyncConfigFactory/get_config",
            "imports": [],
            "code": "def get_config(self):\n    if self.db_type not in self.config_map:\n        raise ValueError(f\"Unsupported database type: {self.db_type}\")\n    return self.config_map[self.db_type]"
        },
        {
            "key_id": 36,
            "fqn": "nest/core/decorators/controller.py/process_prefix",
            "imports": [
                "from typing import Optional"
            ],
            "code": "def process_prefix(route_prefix: Optional[str], tag_name: Optional[str]) -> str:\n    if route_prefix is None:\n        return \"/\" + (tag_name.lower() if tag_name else \"\")\n    return route_prefix if route_prefix.startswith(\"/\") else \"/\" + route_prefix"
        },
        {
            "key_id": 37,
            "fqn": "nest/core/decorators/controller.py/process_dependencies",
            "imports": [
                "from typing import Type",
                "from inspect import signature"
            ],
            "code": "def process_dependencies(cls: Type) -> None:\n    init_signature = signature(cls.__init__)\n    cls.__dependencies__ = [param for param in init_signature.parameters.values() if param.name != 'self']"
        },
        {
            "key_id": 38,
            "fqn": "nest/core/decorators/controller.py/set_instance_variables",
            "imports": [
                "from typing import Type"
            ],
            "code": "def set_instance_variables(cls: Type) -> None:\n    original_init = cls.__init__\n    def new_init(self, *args, **kwargs):\n        original_init(self, *args, **kwargs)\n        for param in cls.__dependencies__:\n            if param.name in kwargs:\n                setattr(self, param.name, kwargs[param.name])\n            elif len(args) > param.index - 1:\n                setattr(self, param.name, args[param.index - 1])\n    cls.__init__ = new_init"
        },
        {
            "key_id": 39,
            "fqn": "nest/core/decorators/controller.py/ensure_init_method",
            "imports": [
                "from typing import Type"
            ],
            "code": "def ensure_init_method(cls: Type) -> None:\n    if not hasattr(cls, '__init__') or cls.__init__ is object.__init__:\n        def __init__(self):\n            pass\n        cls.__init__ = __init__"
        },
        {
            "key_id": 40,
            "fqn": "nest/core/decorators/controller.py/add_routes",
            "imports": [
                "from typing import Type",
                "from fastapi import APIRouter",
                "import inspect"
            ],
            "code": "def add_routes(cls: Type, router: APIRouter, route_prefix: str) -> None:\n    for name, method in inspect.getmembers(cls, predicate=inspect.isfunction):\n        if hasattr(method, \"__route_info__\"):\n            validate_method_decorator(method, name)\n            configure_method_route(method, route_prefix)\n            add_route_to_router(router, method)"
        },
        {
            "key_id": 41,
            "fqn": "nest/core/decorators/controller.py/validate_method_decorator",
            "imports": [],
            "code": "def validate_method_decorator(method_function: callable, method_name: str) -> None:\n    if not hasattr(method_function, \"__route_info__\"):\n        raise ValueError(f\"Method {method_name} is missing route decorator\")\n    \n    route_info = method_function.__route_info__\n    if not all(key in route_info for key in [\"path\", \"methods\"]):\n        raise ValueError(f\"Invalid route information for method {method_name}\")"
        },
        {
            "key_id": 42,
            "fqn": "nest/core/decorators/controller.py/configure_method_route",
            "imports": [],
            "code": "def configure_method_route(method_function: callable, route_prefix: str) -> None:\n    route_info = method_function.__route_info__\n    path = route_info[\"path\"]\n    \n    if isinstance(path, str):\n        route_info[\"path\"] = f\"{route_prefix.rstrip('/')}/{path.lstrip('/')}\"\n    elif isinstance(path, list):\n        route_info[\"path\"] = [f\"{route_prefix.rstrip('/')}/{p.lstrip('/')}\" for p in path]\n    else:\n        raise ValueError(f\"Invalid path type for route: {type(path)}\")"
        },
        {
            "key_id": 43,
            "fqn": "nest/core/decorators/controller.py/add_route_to_router",
            "imports": [
                "from fastapi import APIRouter"
            ],
            "code": "def add_route_to_router(router: APIRouter, method_function: callable) -> None:\n    route_info = method_function.__route_info__\n    path = route_info[\"path\"]\n    methods = route_info[\"methods\"]\n    \n    if \"status_code\" in route_info:\n        router.add_api_route(path, method_function, methods=methods, status_code=route_info[\"status_code\"])\n    else:\n        router.add_api_route(path, method_function, methods=methods)\n    \n    # Add OpenAPI documentation if available\n    if \"summary\" in route_info or \"description\" in route_info:\n        for route in router.routes:\n            if route.endpoint == method_function:\n                route.summary = route_info.get(\"summary\")\n                route.description = route_info.get(\"description\")\n                break"
        }
    ]
}