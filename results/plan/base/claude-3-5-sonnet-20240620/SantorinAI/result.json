{
    "implementation": [
        {
            "key_id": 25,
            "fqn": "santorinai/pawn.py/Pawn/__init__",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def __init__(self, number: int, order: int, player_number: int):\n    self.number = number\n    self.order = order\n    self.player_number = player_number\n    self.pos: Tuple[int, int] | None = None"
        },
        {
            "key_id": 0,
            "fqn": "santorinai/board.py/Board/__init__",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def __init__(self, number_of_players: int):\n    if number_of_players not in [2, 3]:\n        raise ValueError(\"Number of players must be 2 or 3\")\n    self.nb_players = number_of_players\n    self.nb_pawns = 4 if number_of_players == 2 else 6\n    self.board = [[0 for _ in range(5)] for _ in range(5)]\n    self.pawns: List[Pawn] = []\n    for player in range(1, number_of_players + 1):\n        for i in range(1, 3):\n            self.pawns.append(Pawn(number=len(self.pawns) + 1, order=i, player_number=player))\n    self.player_turn = 1\n    self.turn_number = 0\n    self.winner_player_number = None"
        },
        {
            "key_id": 21,
            "fqn": "santorinai/player.py/Player/__init__",
            "imports": [],
            "code": "def __init__(self, player_number: int, log_level = 0) -> None:\n    self.player_number = player_number\n    self.log_level = log_level"
        },
        {
            "key_id": 33,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/__init__",
            "imports": [
                "from santorinai import Player"
            ],
            "code": "def __init__(self, player_number, log_level = 0) -> None:\n    super().__init__(player_number, log_level)\n    self.player_name = \"First Choice Player\""
        },
        {
            "key_id": 37,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/__init__",
            "imports": [
                "from santorinai import Player"
            ],
            "code": "def __init__(self, player_number, log_level = 0) -> None:\n    super().__init__(player_number, log_level)\n    self.player_name = \"Randy Random\""
        },
        {
            "key_id": 41,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/__init__",
            "imports": [
                "from santorinai import Player",
                "from typing import Tuple"
            ],
            "code": "def __init__(self, player_number: int, log_level: int = 0) -> None:\n    super().__init__(player_number, log_level)\n    self.player_number = player_number\n    self.log_level = log_level\n    self.name_str = \"Basic Player\"\n\n    # Initialize any additional attributes specific to BasicPlayer\n    self.last_move: Tuple[int, Tuple[int, int], Tuple[int, int]] = None\n    self.move_history = []\n\n    if self.log_level > 0:\n        print(f\"Initialized BasicPlayer with player number {self.player_number}\")"
        },
        {
            "key_id": 2,
            "fqn": "santorinai/board.py/Board/is_position_within_board",
            "imports": [],
            "code": "def is_position_within_board(self, position: Tuple[int, int]):\n    x, y = position\n    return 0 <= x < 5 and 0 <= y < 5"
        },
        {
            "key_id": 3,
            "fqn": "santorinai/board.py/Board/is_position_adjacent",
            "imports": [],
            "code": "def is_position_adjacent(self, position1: Tuple[int, int], position2: Tuple[int, int]):\n    if not self.is_position_within_board(position1) or not self.is_position_within_board(position2):\n        return False\n    x1, y1 = position1\n    x2, y2 = position2\n    return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1 and (x1, y1) != (x2, y2)"
        },
        {
            "key_id": 4,
            "fqn": "santorinai/board.py/Board/is_pawn_on_position",
            "imports": [],
            "code": "def is_pawn_on_position(self, position: Tuple[int, int]):\n    return any(pawn.pos == position for pawn in self.pawns)"
        },
        {
            "key_id": 1,
            "fqn": "santorinai/board.py/Board/is_move_possible",
            "imports": [],
            "code": "def is_move_possible(self, start_pos: Tuple[int, int], end_pos: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_within_board(start_pos):\n        return False, \"Start position is not within the board\"\n    if not self.is_position_within_board(end_pos):\n        return False, \"End position is not within the board\"\n    if not self.is_position_adjacent(start_pos, end_pos):\n        return False, \"End position is not adjacent to start position\"\n    if self.is_pawn_on_position(end_pos):\n        return False, \"End position is occupied by another pawn\"\n    start_height = self.board[start_pos[0]][start_pos[1]]\n    end_height = self.board[end_pos[0]][end_pos[1]]\n    if end_height > start_height + 1:\n        return False, \"Height difference is too large\"\n    if end_height == 4:\n        return False, \"Cannot move to a dome\"\n    return True, \"\""
        },
        {
            "key_id": 5,
            "fqn": "santorinai/board.py/Board/is_build_possible",
            "imports": [],
            "code": "def is_build_possible(self, builder_position: Tuple[int, int], build_position: Tuple[int, int]):\n    if not self.is_position_within_board(builder_position):\n        return False, \"Builder position is not within the board\"\n    if not self.is_position_within_board(build_position):\n        return False, \"Build position is not within the board\"\n    if not self.is_position_adjacent(builder_position, build_position):\n        return False, \"Build position is not adjacent to builder position\"\n    if self.is_pawn_on_position(build_position):\n        return False, \"Cannot build on a position occupied by a pawn\"\n    if self.board[build_position[0]][build_position[1]] == 4:\n        return False, \"Cannot build on a dome\"\n    return True, \"\""
        },
        {
            "key_id": 6,
            "fqn": "santorinai/board.py/Board/get_player_pawns",
            "imports": [
                "from typing import List",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_player_pawns(self, player_number: int) -> List[Pawn]:\n    return [pawn for pawn in self.pawns if pawn.player_number == player_number]"
        },
        {
            "key_id": 7,
            "fqn": "santorinai/board.py/Board/get_player_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_player_pawn(self, player_number: int, pawn_number: int) -> Pawn:\n    player_pawns = self.get_player_pawns(player_number)\n    for pawn in player_pawns:\n        if pawn.order == pawn_number:\n            return pawn\n    raise ValueError(f\"No pawn found for player {player_number} with number {pawn_number}\")"
        },
        {
            "key_id": 8,
            "fqn": "santorinai/board.py/Board/get_playing_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_playing_pawn(self, pawn_number: int) -> Pawn:\n    return self.get_player_pawn(self.player_turn, pawn_number)"
        },
        {
            "key_id": 9,
            "fqn": "santorinai/board.py/Board/get_first_unplaced_player_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_first_unplaced_player_pawn(self, player_number: int) -> Pawn:\n    player_pawns = self.get_player_pawns(player_number)\n    for pawn in player_pawns:\n        if pawn.pos == (None, None):\n            return pawn\n    raise ValueError(f\"All pawns for player {player_number} are already placed\")"
        },
        {
            "key_id": 10,
            "fqn": "santorinai/board.py/Board/get_possible_movement_positions",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_possible_movement_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:\n    if pawn.pos == (None, None):\n        return []\n    possible_positions = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue\n            new_x, new_y = pawn.pos[0] + dx, pawn.pos[1] + dy\n            if self.is_position_within_board((new_x, new_y)):\n                is_possible, _ = self.is_move_possible(pawn.pos, (new_x, new_y))\n                if is_possible:\n                    possible_positions.append((new_x, new_y))\n    return possible_positions"
        },
        {
            "key_id": 11,
            "fqn": "santorinai/board.py/Board/get_possible_building_positions",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_possible_building_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:\n    possible_positions = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue\n            build_pos = (pawn.pos[0] + dx, pawn.pos[1] + dy)\n            if self.is_build_possible(pawn.pos, build_pos):\n                possible_positions.append(build_pos)\n    return possible_positions"
        },
        {
            "key_id": 12,
            "fqn": "santorinai/board.py/Board/get_possible_movement_and_building_positions",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_possible_movement_and_building_positions(self, pawn: Pawn) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    possible_moves = self.get_possible_movement_positions(pawn)\n    possible_moves_and_builds = []\n    for move in possible_moves:\n        temp_pawn = pawn.copy()\n        temp_pawn.move(move)\n        possible_builds = self.get_possible_building_positions(temp_pawn)\n        for build in possible_builds:\n            possible_moves_and_builds.append((move, build))\n    return possible_moves_and_builds"
        },
        {
            "key_id": 13,
            "fqn": "santorinai/board.py/Board/place_pawn",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def place_pawn(self, position: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_valid(position):\n        return False, \"Invalid position\"\n    \n    pawn = self.get_first_unplaced_player_pawn(self.player_turn)\n    if pawn is None:\n        return False, \"No unplaced pawns for the current player\"\n    \n    if self.is_pawn_on_position(position):\n        return False, \"Position already occupied by another pawn\"\n    \n    pawn.move(position)\n    self.next_turn()\n    return True, \"Pawn placed successfully\""
        },
        {
            "key_id": 14,
            "fqn": "santorinai/board.py/Board/play_move",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def play_move(self, pawn_number: int, move_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:\n    pawn = self.get_playing_pawn(pawn_number)\n    if pawn is None:\n        return False, \"Invalid pawn number\"\n    \n    move_possible, move_message = self.is_move_possible(pawn.pos, move_position)\n    if not move_possible:\n        return False, move_message\n    \n    if not self.is_build_possible(move_position, build_position):\n        return False, \"Invalid build position\"\n    \n    old_pos = pawn.pos\n    pawn.move(move_position)\n    self.board[old_pos[0]][old_pos[1]] = 0\n    self.board[build_position[0]][build_position[1]] += 1\n    \n    if self.board[move_position[0]][move_position[1]] == 3:\n        self.winner_player_number = self.player_turn\n    \n    self.next_turn()\n    return True, \"Move played successfully\""
        },
        {
            "key_id": 15,
            "fqn": "santorinai/board.py/Board/is_position_valid",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_position_valid(self, pos: Tuple[int, int]) -> bool:\n    if not self.is_position_within_board(pos):\n        return False\n    x, y = pos\n    return self.board[x][y] < 4"
        },
        {
            "key_id": 16,
            "fqn": "santorinai/board.py/Board/is_game_over",
            "imports": [
                "from typing import List, Tuple",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def is_game_over(self):\n    # Check if any pawn has reached the top of a tower\n    for pawn in self.pawns:\n        if pawn.pos and self.board[pawn.pos[0]][pawn.pos[1]] == 3:\n            self.winner_player_number = pawn.player_number\n            return True\n    \n    # Check if all players are stuck\n    if self.is_everyone_stuck():\n        # The winner is the last player who was able to move\n        self.winner_player_number = self.player_turn - 1 if self.player_turn > 1 else self.nb_players\n        return True\n    \n    return False"
        },
        {
            "key_id": 17,
            "fqn": "santorinai/board.py/Board/is_everyone_stuck",
            "imports": [
                "from typing import List",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def is_everyone_stuck(self):\n    for player in range(1, self.nb_players + 1):\n        player_pawns = self.get_player_pawns(player)\n        for pawn in player_pawns:\n            if pawn.pos and self.get_possible_movement_positions(pawn):\n                return False\n    return True"
        },
        {
            "key_id": 18,
            "fqn": "santorinai/board.py/Board/next_turn",
            "imports": [],
            "code": "def next_turn(self):\n    self.player_turn = (self.player_turn % self.nb_players) + 1\n    self.turn_number += 1"
        },
        {
            "key_id": 19,
            "fqn": "santorinai/board.py/Board/copy",
            "imports": [
                "from copy import deepcopy",
                "from santorinai.pawn import Pawn"
            ],
            "code": "def copy(self) -> \"Board\":\n    new_board = Board(self.nb_players)\n    new_board.board = deepcopy(self.board)\n    new_board.pawns = [pawn.copy() for pawn in self.pawns]\n    new_board.player_turn = self.player_turn\n    new_board.turn_number = self.turn_number\n    new_board.winner_player_number = self.winner_player_number\n    return new_board"
        },
        {
            "key_id": 20,
            "fqn": "santorinai/board.py/Board/__repr__",
            "imports": [],
            "code": "def __repr__(self) -> str:\n    board_str = \"\"\n    for row in self.board:\n        board_str += \" \".join(str(cell) for cell in row) + \"\\n\"\n    \n    pawn_positions = {(pawn.pos[0], pawn.pos[1]): f\"P{pawn.player_number}\" for pawn in self.pawns if pawn.pos}\n    \n    for i, row in enumerate(self.board):\n        row_str = \"\"\n        for j, cell in enumerate(row):\n            if (i, j) in pawn_positions:\n                row_str += f\"{pawn_positions[(i, j)]:2} \"\n            else:\n                row_str += f\"{cell:2} \"\n        board_str += row_str + \"\\n\"\n    \n    return f\"Board State:\\n{board_str}\\nPlayer Turn: {self.player_turn}\\nTurn Number: {self.turn_number}\""
        },
        {
            "key_id": 26,
            "fqn": "santorinai/pawn.py/Pawn/move",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def move(self, new_pos: Tuple[int, int]):\n    if isinstance(new_pos, tuple) and len(new_pos) == 2:\n        self.pos = new_pos\n    else:\n        raise ValueError(\"Invalid position. Expected a tuple of two integers.\")"
        },
        {
            "key_id": 27,
            "fqn": "santorinai/pawn.py/Pawn/copy",
            "imports": [],
            "code": "def copy(self) -> \"Pawn\":\n    new_pawn = Pawn(self.number, self.order, self.player_number)\n    new_pawn.pos = self.pos\n    return new_pawn"
        },
        {
            "key_id": 28,
            "fqn": "santorinai/pawn.py/Pawn/__repr__",
            "imports": [],
            "code": "def __repr__(self):\n    return f\"Pawn(number={self.number}, order={self.order}, player_number={self.player_number}, pos={self.pos})\""
        },
        {
            "key_id": 22,
            "fqn": "santorinai/player.py/Player/name",
            "imports": [],
            "code": "def name(self):\n    return self.player_name"
        },
        {
            "key_id": 23,
            "fqn": "santorinai/player.py/Player/place_pawn",
            "imports": [
                "from typing import Tuple",
                "from santorinai import Board, Pawn"
            ],
            "code": "def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n    possible_positions = board.get_possible_movement_positions(pawn)\n    if not possible_positions:\n        raise ValueError(\"No valid positions available for pawn placement.\")\n    chosen_position = possible_positions[0]  # Choose the first available position\n    success, message = board.place_pawn(chosen_position)\n    if not success:\n        raise ValueError(f\"Failed to place pawn: {message}\")\n    return chosen_position"
        },
        {
            "key_id": 24,
            "fqn": "santorinai/player.py/Player/play_move",
            "imports": [
                "from typing import Tuple",
                "from santorinai import Board, Pawn",
                "import random"
            ],
            "code": "def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n    my_pawn_1 = board.get_playing_pawn(1)\n    my_pawn_2 = board.get_playing_pawn(2)\n\n    # Randomly choose which pawn to move\n    pawn_to_move = random.choice([my_pawn_1, my_pawn_2])\n\n    # Get possible moves for the chosen pawn\n    possible_moves = board.get_possible_movement_and_building_positions(pawn_to_move)\n\n    if not possible_moves:\n        return None, None, None\n\n    # Randomly choose a move from the possible moves\n    move, build = random.choice(possible_moves)\n\n    return pawn_to_move.order, move, build"
        },
        {
            "key_id": 29,
            "fqn": "santorinai/board_displayer/board_displayer.py/init_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def init_window(player_names):\n    sg.theme('DarkBlue3')\n    layout = [\n        [sg.Text(f'Player 1: {player_names[0]}', font=('Helvetica', 20))],\n        [sg.Text(f'Player 2: {player_names[1]}', font=('Helvetica', 20))],\n        [sg.Graph((SIZE_X, SIZE_Y), (0, 0), (SIZE_X, SIZE_Y), key='graph')],\n        [sg.Button('Exit')]\n    ]\n    return sg.Window('Santorini Board', layout, finalize=True)"
        },
        {
            "key_id": 30,
            "fqn": "santorinai/board_displayer/board_displayer.py/draw_isometric_cube",
            "imports": [
                "import PySimpleGUI as sg",
                "import math"
            ],
            "code": "def draw_isometric_cube(window: sg.Window, x, y, size, cube_height, color, line_color, line_width):\n    graph = window['graph']\n    angle = math.pi / 6\n    cos_angle = math.cos(angle)\n    sin_angle = math.sin(angle)\n\n    # Calculate points\n    points = [\n        (x, y),\n        (x + size * cos_angle, y + size * sin_angle),\n        (x + size * cos_angle * 2, y),\n        (x + size * cos_angle, y - size * sin_angle)\n    ]\n\n    # Draw base\n    graph.draw_polygon(points, fill_color=color, line_color=line_color, line_width=line_width)\n\n    # Draw top\n    top_points = [(p[0], p[1] - cube_height) for p in points]\n    graph.draw_polygon(top_points, fill_color=color, line_color=line_color, line_width=line_width)\n\n    # Draw sides\n    for i in range(4):\n        graph.draw_line(points[i], top_points[i], color=line_color, width=line_width)\n\n    # Draw top lines\n    graph.draw_line(top_points[0], top_points[1], color=line_color, width=line_width)\n    graph.draw_line(top_points[1], top_points[2], color=line_color, width=line_width)"
        },
        {
            "key_id": 31,
            "fqn": "santorinai/board_displayer/board_displayer.py/update_board",
            "imports": [
                "import PySimpleGUI as sg",
                "from santorinai import Board"
            ],
            "code": "def update_board(window: sg.Window, board: Board):\n    graph = window['graph']\n    graph.erase()\n\n    for y in range(5):\n        for x in range(5):\n            pos_x = x * TILE_SIZE + TILE_SIZE / 2\n            pos_y = (4 - y) * TILE_SIZE + TILE_SIZE / 2\n            height = board.board[y][x]\n            color = 'lightblue' if height > 0 else 'lightgrey'\n            draw_isometric_cube(window, pos_x, pos_y, TILE_SIZE / 2, height * 10, color, 'black', 1)\n\n    for pawn in board.pawns:\n        if pawn.pos is not None:\n            x, y = pawn.pos\n            pos_x = x * TILE_SIZE + TILE_SIZE / 2\n            pos_y = (4 - y) * TILE_SIZE + TILE_SIZE / 2\n            height = board.board[y][x]\n            color = pawns_colors[pawn.player_number]\n            draw_isometric_cube(window, pos_x, pos_y - height * 10, TILE_SIZE / 4, 20, color, 'black', 1)\n\n    window.refresh()\n    return window.read(timeout=10)"
        },
        {
            "key_id": 32,
            "fqn": "santorinai/board_displayer/board_displayer.py/close_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def close_window(window):\n    window.close()"
        },
        {
            "key_id": 34,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/name",
            "imports": [],
            "code": "def name(self):\n    return self.player_name"
        },
        {
            "key_id": 35,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/place_pawn",
            "imports": [],
            "code": "def place_pawn(self, board: Board, pawn: Pawn):\n    possible_positions = board.get_possible_movement_positions(pawn)\n    if possible_positions:\n        return possible_positions[0]\n    return None"
        },
        {
            "key_id": 36,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/play_move",
            "imports": [],
            "code": "def play_move(self, board: Board):\n    for pawn_number in [1, 2]:\n        pawn = board.get_playing_pawn(pawn_number)\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        if possible_moves:\n            move_position, build_position = possible_moves[0]\n            return pawn_number, move_position, build_position\n    return None, None, None"
        },
        {
            "key_id": 38,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/name",
            "imports": [],
            "code": "def name(self):\n    return self.player_name"
        },
        {
            "key_id": 39,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/place_pawn",
            "imports": [
                "from random import choice"
            ],
            "code": "def place_pawn(self, board: Board, pawn: Pawn):\n    possible_positions = board.get_possible_movement_positions(pawn)\n    if possible_positions:\n        return choice(possible_positions)\n    return None"
        },
        {
            "key_id": 40,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/play_move",
            "imports": [
                "from santorinai import Board, Pawn",
                "from random import choice"
            ],
            "code": "def play_move(self, board: Board):\n    my_pawn_1 = board.get_playing_pawn(1)\n    my_pawn_2 = board.get_playing_pawn(2)\n\n    # Choose a random pawn to move\n    pawn_to_move = choice([my_pawn_1, my_pawn_2])\n\n    # Get possible moves for the chosen pawn\n    possible_moves = board.get_possible_movement_and_building_positions(pawn_to_move)\n\n    if not possible_moves:\n        return None, None, None\n\n    # Choose a random move from the possible moves\n    chosen_move = choice(possible_moves)\n\n    return pawn_to_move.order, chosen_move[0], chosen_move[1]"
        },
        {
            "key_id": 42,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/name",
            "imports": [],
            "code": "def name(self):\n    return self.name_str"
        },
        {
            "key_id": 43,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_ally_pawn",
            "imports": [
                "from santorinai import Board, Pawn",
                "from typing import Tuple"
            ],
            "code": "def get_ally_pawn(self, board: Board, our_pawn: Pawn) -> Tuple[Pawn, None]:\n    ally_pawns = board.get_player_pawns(self.player_number)\n    for pawn in ally_pawns:\n        if pawn.number != our_pawn.number:\n            return pawn\n    return None"
        },
        {
            "key_id": 44,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_enemy_pawns",
            "imports": [
                "from santorinai import Board, Pawn",
                "from typing import List"
            ],
            "code": "def get_enemy_pawns(self, board: Board, our_pawn: Pawn) -> List[Pawn]:\n    enemy_pawns = []\n    for player_num in range(1, board.nb_players + 1):\n        if player_num != self.player_number:\n            enemy_pawns.extend(board.get_player_pawns(player_num))\n    return enemy_pawns"
        },
        {
            "key_id": 45,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_winning_moves",
            "imports": [
                "from santorinai import Board, Pawn",
                "from typing import List, Tuple"
            ],
            "code": "def get_winning_moves(self, board: Board, pawn: Pawn) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    winning_moves = []\n    possible_moves = board.get_possible_movement_and_building_positions(pawn)\n\n    for move, build in possible_moves:\n        # Check if the move leads to a win\n        temp_board = board.copy()\n        temp_board.play_move(pawn.order, move, build)\n        if temp_board.is_game_over() and temp_board.winner_player_number == self.player_number:\n            winning_moves.append((move, build))\n\n    return winning_moves"
        },
        {
            "key_id": 46,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/place_pawn",
            "imports": [
                "from typing import Tuple, List",
                "from santorinai import Board, Pawn"
            ],
            "code": "def place_pawn(self, board: Board, pawn: Pawn) -> Tuple[int, int]:\n    possible_positions = board.get_possible_movement_positions(pawn)\n    \n    # Get ally and enemy pawns\n    ally_pawn = self.get_ally_pawn(board, pawn)\n    enemy_pawns = self.get_enemy_pawns(board, pawn)\n    \n    # Strategy: Try to place the pawn as far as possible from enemy pawns\n    # and close to the ally pawn (if placed)\n    best_position = None\n    max_distance_from_enemies = -1\n    \n    for pos in possible_positions:\n        min_distance_from_enemies = float('inf')\n        for enemy in enemy_pawns:\n            if enemy.pos is not None:\n                distance = max(abs(pos[0] - enemy.pos[0]), abs(pos[1] - enemy.pos[1]))\n                min_distance_from_enemies = min(min_distance_from_enemies, distance)\n        \n        if min_distance_from_enemies > max_distance_from_enemies:\n            max_distance_from_enemies = min_distance_from_enemies\n            best_position = pos\n        elif min_distance_from_enemies == max_distance_from_enemies:\n            # If equidistant from enemies, prefer positions closer to ally\n            if ally_pawn and ally_pawn.pos is not None:\n                current_distance_to_ally = max(abs(best_position[0] - ally_pawn.pos[0]), abs(best_position[1] - ally_pawn.pos[1]))\n                new_distance_to_ally = max(abs(pos[0] - ally_pawn.pos[0]), abs(pos[1] - ally_pawn.pos[1]))\n                if new_distance_to_ally < current_distance_to_ally:\n                    best_position = pos\n    \n    if best_position is None:\n        # Fallback to the first available position if no best position found\n        best_position = possible_positions[0] if possible_positions else (0, 0)\n    \n    if self.log_level > 0:\n        print(f\"Placing pawn {pawn.number} at position {best_position}\")\n    \n    return best_position"
        },
        {
            "key_id": 47,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/play_move",
            "imports": [
                "from typing import Tuple, List",
                "from santorinai import Board, Pawn"
            ],
            "code": "def play_move(self, board: Board) -> Tuple[int, Tuple[int, int], Tuple[int, int]]:\n    # Get our pawns\n    pawn1 = board.get_playing_pawn(1)\n    pawn2 = board.get_playing_pawn(2)\n    \n    # Check for winning moves\n    for pawn in [pawn1, pawn2]:\n        winning_moves = self.get_winning_moves(board, pawn)\n        if winning_moves:\n            move, build = winning_moves[0]\n            if self.log_level > 0:\n                print(f\"Playing winning move with pawn {pawn.order}: Move to {move}, Build at {build}\")\n            return pawn.order, move, build\n    \n    # If no winning moves, use a heuristic approach\n    best_move = None\n    best_score = float('-inf')\n    \n    for pawn in [pawn1, pawn2]:\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        for move, build in possible_moves:\n            score = self.evaluate_move(board, pawn, move, build)\n            if score > best_score:\n                best_score = score\n                best_move = (pawn.order, move, build)\n    \n    if best_move is None:\n        # Fallback to first available move if no move is found\n        for pawn in [pawn1, pawn2]:\n            possible_moves = board.get_possible_movement_and_building_positions(pawn)\n            if possible_moves:\n                best_move = (pawn.order, possible_moves[0][0], possible_moves[0][1])\n                break\n    \n    if best_move is None:\n        # If still no move found, return None to indicate no possible moves\n        return None, None, None\n    \n    if self.log_level > 0:\n        print(f\"Playing move: Pawn {best_move[0]}, Move to {best_move[1]}, Build at {best_move[2]}\")\n    \n    return best_move\n\ndef evaluate_move(self, board: Board, pawn: Pawn, move: Tuple[int, int], build: Tuple[int, int]) -> float:\n    score = 0\n    \n    # Prefer moving up\n    current_height = board.board[pawn.pos[0]][pawn.pos[1]]\n    new_height = board.board[move[0]][move[1]]\n    score += (new_height - current_height) * 10\n    \n    # Prefer building up, but not to level 4\n    build_height = board.board[build[0]][build[1]]\n    if build_height < 3:\n        score += build_height * 5\n    \n    # Prefer moves that block opponents\n    enemy_pawns = self.get_enemy_pawns(board, pawn)\n    for enemy in enemy_pawns:\n        if enemy.pos is not None:\n            if board.is_position_adjacent(move, enemy.pos):\n                score += 3\n            if board.is_position_adjacent(build, enemy.pos):\n                score += 2\n    \n    # Prefer central positions\n    center_x, center_y = 2, 2\n    distance_to_center = max(abs(move[0] - center_x), abs(move[1] - center_y))\n    score -= distance_to_center * 2\n    \n    return score"
        }
    ]
}