{
    "implementation": [
        {
            "key_id": 17,
            "fqn": "src/hardware/basic_components.py/HalfAdder/__init__",
            "imports": [
                "from src.hardware.gates import and_, xor"
            ],
            "code": "class HalfAdder:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n\n    def sum(self) -> bool:\n        return xor(self.input1, self.input2)\n\n    def carry(self) -> bool:\n        return and_(self.input1, self.input2)"
        },
        {
            "key_id": 20,
            "fqn": "src/hardware/basic_components.py/FullAdder/__init__",
            "imports": [
                "from src.hardware.basic_components import HalfAdder"
            ],
            "code": "class FullAdder:\n    def __init__(self, input1: bool, input2: bool, carry_in: bool):\n        self.ha1 = HalfAdder(input1, input2)\n        self.ha2 = HalfAdder(self.ha1.sum(), carry_in)\n\n    def sum(self):\n        return self.ha2.sum()\n\n    def carry(self):\n        return self.ha1.carry() or self.ha2.carry()"
        },
        {
            "key_id": 23,
            "fqn": "src/hardware/basic_components.py/Adder/__init__",
            "imports": [
                "from src.hardware.basic_components import FullAdder"
            ],
            "code": "class Adder:\n    def __init__(self, input1: list[bool], input2: list[bool], carry_in: bool = False):\n        self.input1 = input1\n        self.input2 = input2\n        self.carry_in = carry_in\n        self.adders = []\n        self._sum = []\n        self._carry_out = False\n        self._calculate()\n\n    def _calculate(self):\n        carry = self.carry_in\n        for i in range(len(self.input1)):\n            fa = FullAdder(self.input1[i], self.input2[i], carry)\n            self.adders.append(fa)\n            self._sum.append(fa.sum())\n            carry = fa.carry()\n        self._carry_out = carry\n\n    def sum(self) -> list[bool]:\n        return self._sum\n\n    def carry_out(self) -> bool:\n        return self._carry_out"
        },
        {
            "key_id": 26,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/__init__",
            "imports": [
                "from src.hardware.gates import and_, not_, xor"
            ],
            "code": "class HalfSubtractor:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n\n    def diff(self) -> bool:\n        return xor(self.input1, self.input2)\n\n    def borrow(self) -> bool:\n        return and_(not_(self.input1), self.input2)"
        },
        {
            "key_id": 29,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/__init__",
            "imports": [
                "from src.hardware.basic_components import HalfSubtractor",
                "from src.hardware.gates import or_"
            ],
            "code": "class FullSubtractor:\n    def __init__(self, input1: bool, input2: bool, borrow_in: bool):\n        self.hs1 = HalfSubtractor(input1, input2)\n        self.hs2 = HalfSubtractor(self.hs1.diff(), borrow_in)\n\n    def diff(self):\n        return self.hs2.diff()\n\n    def borrow(self):\n        return or_(self.hs1.borrow(), self.hs2.borrow())"
        },
        {
            "key_id": 32,
            "fqn": "src/hardware/basic_components.py/Subtractor/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], borrow_in: bool = False):\n    self.input1 = input1\n    self.input2 = input2\n    self.borrow_in = borrow_in\n    self.full_subtractors = []\n    for i in range(8):\n        if i == 0:\n            self.full_subtractors.append(FullSubtractor(input1[i], input2[i], borrow_in))\n        else:\n            self.full_subtractors.append(FullSubtractor(input1[i], input2[i], self.full_subtractors[i-1].borrow()))"
        },
        {
            "key_id": 35,
            "fqn": "src/hardware/basic_components.py/Mux/__init__",
            "imports": [
                "from src.hardware.gates import and_, or_, not_"
            ],
            "code": "def __init__(self, input1: bool, input2: bool, sel: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.sel = sel"
        },
        {
            "key_id": 37,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], sel: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.sel = sel\n    self.muxes = [Mux(input1[i], input2[i], sel) for i in range(8)]"
        },
        {
            "key_id": 39,
            "fqn": "src/hardware/basic_components.py/AddSub/__init__",
            "imports": [],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], operation: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.operation = operation\n    self.adder = Adder(input1, input2)\n    self.subtractor = Subtractor(input1, input2)\n    self.mux = Mux8Bit(self.adder.sum(), self.subtractor.diff(), operation)"
        },
        {
            "key_id": 43,
            "fqn": "src/hardware/basic_components.py/Decoder/__init__",
            "imports": [
                "from src.hardware.gates import and_, or_, not_"
            ],
            "code": "def __init__(self, input: list[bool]):\n    self.input = input\n    self.output_lines = []\n    for i in range(8):\n        binary = format(i, '03b')\n        and_gates = []\n        for j in range(3):\n            if binary[j] == '0':\n                and_gates.append(not_(input[j]))\n            else:\n                and_gates.append(input[j])\n        self.output_lines.append(and_(*and_gates))"
        },
        {
            "key_id": 45,
            "fqn": "src/hardware/basic_components.py/Control/__init__",
            "imports": [
                "from src.hardware.basic_components.py import Decoder"
            ],
            "code": "def __init__(self, input: list[bool]):\n    self.decoder = Decoder(input)\n    self.control_signals = {\n        \"add\": [False, False],\n        \"sub\": [False, True],\n        \"and\": [True, False],\n        \"or\": [True, True]\n    }\n\n    self.decoded_output = self.decoder.output()"
        },
        {
            "key_id": 47,
            "fqn": "src/hardware/basic_components.py/Comparison/__init__",
            "imports": [
                "from src.hardware.basic_components import AddSub, Control"
            ],
            "code": "def __init__(self, control: list[bool], byte: list[bool]):\n    self.control = Control(control)\n    self.byte = byte\n    self.zero = [False] * 8\n    self.addsub = AddSub(self.byte, self.zero, True)  # Subtract mode\n    \n    self.result = self.addsub.output()\n    self.overflow = self.addsub.overflow()\n    self.borrow = self.addsub.borrow_out()\n    \n    self.is_zero = all(not bit for bit in self.result)\n    self.is_negative = self.result[0]  # MSB indicates sign in two's complement"
        },
        {
            "key_id": 49,
            "fqn": "src/hardware/registers.py/Registers/__init__",
            "imports": [],
            "code": "def __init__(self):\n    self.registers = [\n        [False] * 8 for _ in range(6)  # 6 8-bit registers\n    ]\n    self.input_register = [False] * 8\n    self.output_register = [False] * 8"
        },
        {
            "key_id": 53,
            "fqn": "src/hardware/alu.py/ALU/__init__",
            "imports": [
                "from src.hardware.basic_components import AddSub",
                "from src.hardware.gates import and_, or_"
            ],
            "code": "def __init__(self, input1: list[bool], input2: list[bool], control1: bool, control2: bool):\n    self.input1 = input1\n    self.input2 = input2\n    self.control1 = control1\n    self.control2 = control2\n    \n    self.addsub = AddSub(input1, input2, control2)\n    \n    self.result = [False] * 8\n    self.zero_flag = False\n    self.negative_flag = False\n    self.overflow_flag = False\n    self.carry_out_flag = False\n    \n    self._compute()"
        },
        {
            "key_id": 66,
            "fqn": "src/hardware/cpu.py/CPU/__init__",
            "imports": [
                "from src.hardware.registers import Registers",
                "from src.hardware.alu import ALU",
                "from src.hardware.basic_components import Control"
            ],
            "code": "def __init__(self, program, verbose=True):\n    self.registers = Registers()\n    self.alu = ALU([False]*8, [False]*8, False, False)\n    self.control = Control([False]*8)\n    \n    self.program = program\n    self.program_counter = 0\n    self.instruction_register = [False] * 8\n    \n    self.verbose = verbose\n    \n    # Flags\n    self.zero_flag = False\n    self.negative_flag = False\n    self.overflow_flag = False\n    self.carry_flag = False\n    \n    if self.verbose:\n        print(\"CPU initialized with program length:\", len(program))"
        },
        {
            "key_id": 68,
            "fqn": "src/hardware/cpu.py/Cycle/__init__",
            "imports": [],
            "code": "def __init__(self, cpu, program_instruction_byte):\n    self.cpu = cpu\n    self.instruction = program_instruction_byte\n    self.control = Control(self.instruction)\n    self.control_signals = self.control.output()\n    self.decoder = Decoder(self.instruction[:2])\n    self.register_select = self.decoder.output()\n    self.immediate_value = self.instruction[2:]\n    self.alu = ALU(self.cpu.registers.read()[1], self.cpu.registers.read()[2], self.control_signals[2], self.control_signals[3])\n    self.comparison = Comparison(self.control_signals[4:8], self.cpu.registers.read()[3])"
        },
        {
            "key_id": 8,
            "fqn": "src/games/maze.py/Robot/__init__",
            "imports": [
                "import pygame",
                "from src.hardware.cpu import CPU",
                "from src.assembler import assemble_binary"
            ],
            "code": "def __init__(self, initial_pos=[1,1], initial_dir='up', delay=0):\n    self.pos = initial_pos\n    self.dir = initial_dir\n    self.delay = delay\n    self.program = assemble_binary('robot.asm')\n    self.cpu = CPU(self.program)\n    self.move_count = 0\n\n    def write_to_input():\n        return self.get_front_cell_bit()\n\n    def read_from_output(value):\n        if value == [0,0,0,0,0,0,0,1]:\n            self.move_forward()\n        elif value == [0,0,0,0,0,0,1,0]:\n            self.turn_left()\n        elif value == [0,0,0,0,0,0,1,1]:\n            self.turn_right()\n\n    self.cpu.run(write_to_input=write_to_input, read_from_output=read_from_output)"
        },
        {
            "key_id": 59,
            "fqn": "src/hardware/gates.py/and_",
            "imports": [],
            "code": "def and_(*args) -> int:\n    result = 1\n    for arg in args:\n        result = result & arg\n    return result"
        },
        {
            "key_id": 60,
            "fqn": "src/hardware/gates.py/or_",
            "imports": [],
            "code": "def or_(*args) -> int:\n    result = 0\n    for arg in args:\n        result = result | arg\n    return result"
        },
        {
            "key_id": 61,
            "fqn": "src/hardware/gates.py/not_",
            "imports": [],
            "code": "def not_(*args) -> int:\n    if len(args) != 1:\n        raise ValueError(\"not_ gate takes exactly one argument\")\n    return int(not args[0])"
        },
        {
            "key_id": 62,
            "fqn": "src/hardware/gates.py/nor",
            "imports": [],
            "code": "def nor(*args) -> int:\n    return not_(or_(*args))"
        },
        {
            "key_id": 63,
            "fqn": "src/hardware/gates.py/nand",
            "imports": [],
            "code": "def nand(*args) -> int:\n    return not_(and_(*args))"
        },
        {
            "key_id": 64,
            "fqn": "src/hardware/gates.py/xor",
            "imports": [],
            "code": "def xor(a: bool, b: bool) -> int:\n    return and_(or_(a, b), not_(and_(a, b)))"
        },
        {
            "key_id": 65,
            "fqn": "src/hardware/gates.py/xnor",
            "imports": [],
            "code": "def xnor(a: bool, b: bool) -> int:\n    return not_(xor(a, b))"
        },
        {
            "key_id": 50,
            "fqn": "src/hardware/registers.py/Registers/read",
            "imports": [],
            "code": "def read(self):\n    return self.registers + [self.input_register, self.output_register]"
        },
        {
            "key_id": 51,
            "fqn": "src/hardware/registers.py/Registers/write",
            "imports": [],
            "code": "def write(self, data):\n    if len(data) != 8:\n        raise ValueError(\"Data must be 8 bits long\")\n    for i in range(6):\n        self.write_to_register(i, data)\n    self.input_register = data.copy()\n    self.output_register = data.copy()"
        },
        {
            "key_id": 52,
            "fqn": "src/hardware/registers.py/Registers/write_to_register",
            "imports": [],
            "code": "def write_to_register(self, register, data):\n    if register < 0 or register >= 6:\n        raise ValueError(\"Invalid register number\")\n    if len(data) != 8:\n        raise ValueError(\"Data must be 8 bits long\")\n    self.registers[register] = data.copy()"
        },
        {
            "key_id": 54,
            "fqn": "src/hardware/alu.py/ALU/out",
            "imports": [
                "from src.hardware.basic_components import Mux8Bit"
            ],
            "code": "def out(self):\n    and_result = [a and b for a, b in zip(self.input1, self.input2)]\n    or_result = [a or b for a, b in zip(self.input1, self.input2)]\n    addsub_result = self.addsub.output()\n    \n    mux1 = Mux8Bit(and_result, or_result, self.control1)\n    mux2 = Mux8Bit(mux1.output(), addsub_result, self.control2)\n    \n    return mux2.output()"
        },
        {
            "key_id": 55,
            "fqn": "src/hardware/alu.py/ALU/zero",
            "imports": [
                "from src.hardware.gates import not_"
            ],
            "code": "def zero(self):\n    return not_(any(self.result))"
        },
        {
            "key_id": 56,
            "fqn": "src/hardware/alu.py/ALU/negative",
            "imports": [],
            "code": "def negative(self):\n    return self.result[7]"
        },
        {
            "key_id": 57,
            "fqn": "src/hardware/alu.py/ALU/overflow",
            "imports": [],
            "code": "def overflow(self):\n    return self.addsub.overflow()"
        },
        {
            "key_id": 58,
            "fqn": "src/hardware/alu.py/ALU/carry_out",
            "imports": [],
            "code": "def carry_out(self):\n    return self.addsub.borrow_out()"
        },
        {
            "key_id": 67,
            "fqn": "src/hardware/cpu.py/CPU/run",
            "imports": [
                "from src.hardware.registers import Registers",
                "from src.hardware.alu import ALU",
                "from src.hardware.basic_components import Control",
                "from src.hardware.cpu import Cycle"
            ],
            "code": "def run(self, write_to_input: callable = None, read_from_output: callable = None):\n    while self.program_counter < len(self.program):\n        instruction = self.program[self.program_counter]\n        self.instruction_register = instruction\n        \n        if self.verbose:\n            print(f\"Executing instruction at PC {self.program_counter}: {instruction}\")\n        \n        cycle = Cycle(self, instruction)\n        cycle.execute()\n        \n        if write_to_input:\n            input_value = write_to_input()\n            self.registers.write_to_register(6, input_value)\n        \n        if read_from_output:\n            output_value = self.registers.read()[6]\n            read_from_output(output_value)\n        \n        self.program_counter += 1\n    \n    if self.verbose:\n        print(\"Program execution completed.\")\n        print(f\"Final register state: {self.registers.read()}\")\n        print(f\"Flags - Zero: {self.zero_flag}, Negative: {self.negative_flag}, Overflow: {self.overflow_flag}, Carry: {self.carry_flag}\")"
        },
        {
            "key_id": 69,
            "fqn": "src/hardware/cpu.py/Cycle/execute",
            "imports": [
                "from src.hardware.registers import Registers",
                "from src.hardware.alu import ALU",
                "from src.hardware.basic_components import Control, Decoder, Comparison"
            ],
            "code": "def execute(self):\n    # Update ALU inputs based on current register values\n    self.alu = ALU(self.cpu.registers.read()[1], self.cpu.registers.read()[2], self.control_signals[2], self.control_signals[3])\n    \n    # Execute based on control signals\n    if self.control_signals[0]:  # Load immediate value\n        self.cpu.registers.write_to_register(self.register_select.index(True), self.immediate_value)\n    \n    elif self.control_signals[1]:  # Copy operation\n        source_reg = self.instruction[2:5].index(True)\n        dest_reg = self.instruction[5:].index(True)\n        self.cpu.registers.write_to_register(dest_reg, self.cpu.registers.read()[source_reg])\n    \n    else:  # ALU operation\n        result = self.alu.out()\n        self.cpu.registers.write_to_register(3, result)\n        \n        # Update flags\n        self.cpu.zero_flag = self.alu.zero()\n        self.cpu.negative_flag = self.alu.negative()\n        self.cpu.overflow_flag = self.alu.overflow()\n        self.cpu.carry_flag = self.alu.carry_out()\n    \n    # Handle jumps based on comparison\n    if any(self.control_signals[4:8]):\n        comparison_result = self.comparison.out()\n        if comparison_result:\n            jump_address = self.cpu.registers.read()[0]\n            self.cpu.program_counter = int(''.join(map(str, map(int, jump_address))), 2) - 1  # -1 because PC will be incremented after this\n    \n    if self.cpu.verbose:\n        print(f\"Executed instruction: {self.instruction}\")\n        print(f\"Updated register state: {self.cpu.registers.read()}\")\n        print(f\"Flags - Zero: {self.cpu.zero_flag}, Negative: {self.cpu.negative_flag}, Overflow: {self.cpu.overflow_flag}, Carry: {self.cpu.carry_flag}\")"
        },
        {
            "key_id": 2,
            "fqn": "src/assembler.py/get_labels",
            "imports": [],
            "code": "def get_labels(file) -> dict:\n    labels = {}\n    line_number = 0\n    \n    with open(file, 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line.startswith('label'):\n                label_name = line.split()[1]\n                labels[label_name] = line_number\n            elif line and not line.startswith('#'):\n                line_number += 1\n    \n    return labels"
        },
        {
            "key_id": 3,
            "fqn": "src/assembler.py/immediate_values",
            "imports": [],
            "code": "def immediate_values(line, labels):\n    parts = line.split()\n    if len(parts) != 2:\n        raise ValueError(f\"Invalid immediate value instruction: {line}\")\n    \n    value = parts[1]\n    if value in labels:\n        value = labels[value]\n    else:\n        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(f\"Invalid immediate value: {value}\")\n    \n    if value < 0 or value > 63:\n        raise ValueError(f\"Immediate value out of range (0-63): {value}\")\n    \n    binary = format(value, '06b')\n    return f\"11{binary}\""
        },
        {
            "key_id": 4,
            "fqn": "src/assembler.py/copy_instructions",
            "imports": [],
            "code": "def copy_instructions(line):\n    parts = line.split()\n    if len(parts) != 3:\n        raise ValueError(f\"Invalid copy instruction: {line}\")\n    \n    source = int(parts[1])\n    destination = int(parts[2])\n    \n    if source < 0 or source > 7 or destination < 0 or destination > 7:\n        raise ValueError(f\"Invalid register number in copy instruction: {line}\")\n    \n    source_binary = format(source, '03b')\n    destination_binary = format(destination, '03b')\n    \n    return f\"10{source_binary}{destination_binary}\""
        },
        {
            "key_id": 5,
            "fqn": "src/assembler.py/operate_instructions",
            "imports": [],
            "code": "def operate_instructions(line):\n    operations = {\n        'add': '1000',\n        'or': '1001',\n        'and': '1010',\n        'sub': '1011'\n    }\n    if line.strip() in operations:\n        return operations[line.strip()] + '00000'\n    else:\n        raise ValueError(f\"Invalid operation instruction: {line}\")"
        },
        {
            "key_id": 6,
            "fqn": "src/assembler.py/jump_instructions",
            "imports": [],
            "code": "def jump_instructions(line):\n    jump_conditions = {\n        'eval always': '110000',\n        'eval never': '110001',\n        'eval =': '110010',\n        'eval !=': '110011',\n        'eval <': '110100',\n        'eval <=': '110101',\n        'eval >': '110110',\n        'eval >=': '110111'\n    }\n    for condition, opcode in jump_conditions.items():\n        if line.strip().startswith(condition):\n            return opcode + '00'\n    raise ValueError(f\"Invalid jump instruction: {line}\")"
        },
        {
            "key_id": 7,
            "fqn": "src/assembler.py/assemble_binary",
            "imports": [],
            "code": "def assemble_binary(filename: str):\n    with open(filename, 'r') as file:\n        lines = file.readlines()\n    \n    labels = get_labels(lines)\n    binary_instructions = []\n    \n    for line in lines:\n        line = line.strip()\n        if not line or line.startswith('#') or line.startswith('label'):\n            continue\n        \n        try:\n            if line.isdigit():\n                binary_instructions.append(immediate_values(line, labels))\n            elif line.startswith('copy'):\n                binary_instructions.append(copy_instructions(line))\n            elif line in ['add', 'or', 'and', 'sub']:\n                binary_instructions.append(operate_instructions(line))\n            elif line.startswith('eval'):\n                binary_instructions.append(jump_instructions(line))\n            else:\n                raise ValueError(f\"Unknown instruction: {line}\")\n        except ValueError as e:\n            print(f\"Error on line: {line}\")\n            raise e\n    \n    return binary_instructions"
        },
        {
            "key_id": 14,
            "fqn": "src/games/maze.py/Robot/get_front_cell",
            "imports": [],
            "code": "def get_front_cell(self):\n    front_pos = self.pos.copy()\n    if self.dir == 'up':\n        front_pos[1] -= 1\n    elif self.dir == 'right':\n        front_pos[0] += 1\n    elif self.dir == 'down':\n        front_pos[1] += 1\n    elif self.dir == 'left':\n        front_pos[0] -= 1\n    \n    if 0 <= front_pos[0] < len(maze[0]) and 0 <= front_pos[1] < len(maze):\n        return maze[front_pos[1]][front_pos[0]]\n    else:\n        return 1  # Treat out of bounds as a wall"
        },
        {
            "key_id": 15,
            "fqn": "src/games/maze.py/Robot/get_front_cell_bit",
            "imports": [],
            "code": "def get_front_cell_bit(self):\n    front_cell = self.get_front_cell()\n    return [0, 0, 0, 0, 0, 0, 0, 1] if front_cell == 0 else [0, 0, 0, 0, 0, 0, 0, 0]"
        },
        {
            "key_id": 10,
            "fqn": "src/games/maze.py/Robot/move_forward",
            "imports": [
                "import time"
            ],
            "code": "def move_forward(self):\n    new_pos = self.pos.copy()\n    if self.dir == 'up':\n        new_pos[1] -= 1\n    elif self.dir == 'down':\n        new_pos[1] += 1\n    elif self.dir == 'left':\n        new_pos[0] -= 1\n    elif self.dir == 'right':\n        new_pos[0] += 1\n\n    if maze[new_pos[1]][new_pos[0]] != 1:  # If not a wall\n        self.pos = new_pos\n        self.move_count += 1\n        time.sleep(self.delay)\n    else:\n        print(\"Can't move forward. There's a wall.\")\n\n    if maze[self.pos[1]][self.pos[0]] == 2:  # If reached the exit\n        print(f\"Maze solved in {self.move_count} moves!\")\n        return True\n    return False"
        },
        {
            "key_id": 11,
            "fqn": "src/games/maze.py/Robot/turn_left",
            "imports": [
                "import time"
            ],
            "code": "def turn_left(self):\n    directions = ['up', 'left', 'down', 'right']\n    current_index = directions.index(self.dir)\n    self.dir = directions[(current_index + 1) % 4]\n    self.move_count += 1\n    time.sleep(self.delay)\n    print(f\"Turned left. Now facing {self.dir}.\")"
        },
        {
            "key_id": 12,
            "fqn": "src/games/maze.py/Robot/turn_right",
            "imports": [
                "import time"
            ],
            "code": "def turn_right(self):\n    directions = ['up', 'right', 'down', 'left']\n    current_index = directions.index(self.dir)\n    self.dir = directions[(current_index + 1) % 4]\n    self.move_count += 1\n    time.sleep(self.delay)\n    print(f\"Turned right. Now facing {self.dir}.\")"
        },
        {
            "key_id": 13,
            "fqn": "src/games/maze.py/Robot/move",
            "imports": [],
            "code": "def move(self, instruction):\n    if instruction == 'forward':\n        return self.move_forward()\n    elif instruction == 'left':\n        self.turn_left()\n    elif instruction == 'right':\n        self.turn_right()\n    else:\n        print(f\"Invalid instruction: {instruction}\")\n    return False"
        },
        {
            "key_id": 9,
            "fqn": "src/games/maze.py/Robot/event_check",
            "imports": [
                "import pygame"
            ],
            "code": "def event_check(self):\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            return True\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_ESCAPE:\n                pygame.quit()\n                return True\n            elif event.key == pygame.K_UP:\n                self.move('forward')\n            elif event.key == pygame.K_LEFT:\n                self.turn_left()\n            elif event.key == pygame.K_RIGHT:\n                self.turn_right()\n    return False"
        },
        {
            "key_id": 16,
            "fqn": "src/games/maze.py/draw",
            "imports": [
                "import pygame",
                "from src.games.maze import CELL_SIZE, WHITE, RED, GREEN, BLACK, BLUE, maze"
            ],
            "code": "def draw(robot):\n    screen = pygame.display.set_mode((len(maze[0]) * CELL_SIZE, len(maze) * CELL_SIZE))\n    screen.fill(WHITE)\n    for y, row in enumerate(maze):\n        for x, cell in enumerate(row):\n            rect = pygame.Rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE)\n            if cell == 1:\n                pygame.draw.rect(screen, BLACK, rect)\n            elif cell == 2:\n                pygame.draw.rect(screen, GREEN, rect)\n    robot_rect = pygame.Rect(robot.pos[0] * CELL_SIZE, robot.pos[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE)\n    pygame.draw.rect(screen, RED, robot_rect)\n    if robot.direction == 'up':\n        pygame.draw.polygon(screen, BLUE, [\n            (robot.pos[0] * CELL_SIZE + CELL_SIZE // 2, robot.pos[1] * CELL_SIZE),\n            (robot.pos[0] * CELL_SIZE, robot.pos[1] * CELL_SIZE + CELL_SIZE),\n            (robot.pos[0] * CELL_SIZE + CELL_SIZE, robot.pos[1] * CELL_SIZE + CELL_SIZE)\n        ])\n    elif robot.direction == 'right':\n        pygame.draw.polygon(screen, BLUE, [\n            (robot.pos[0] * CELL_SIZE + CELL_SIZE, robot.pos[1] * CELL_SIZE + CELL_SIZE // 2),\n            (robot.pos[0] * CELL_SIZE, robot.pos[1] * CELL_SIZE),\n            (robot.pos[0] * CELL_SIZE, robot.pos[1] * CELL_SIZE + CELL_SIZE)\n        ])\n    elif robot.direction == 'down':\n        pygame.draw.polygon(screen, BLUE, [\n            (robot.pos[0] * CELL_SIZE + CELL_SIZE // 2, robot.pos[1] * CELL_SIZE + CELL_SIZE),\n            (robot.pos[0] * CELL_SIZE, robot.pos[1] * CELL_SIZE),\n            (robot.pos[0] * CELL_SIZE + CELL_SIZE, robot.pos[1] * CELL_SIZE)\n        ])\n    elif robot.direction == 'left':\n        pygame.draw.polygon(screen, BLUE, [\n            (robot.pos[0] * CELL_SIZE, robot.pos[1] * CELL_SIZE + CELL_SIZE // 2),\n            (robot.pos[0] * CELL_SIZE + CELL_SIZE, robot.pos[1] * CELL_SIZE),\n            (robot.pos[0] * CELL_SIZE + CELL_SIZE, robot.pos[1] * CELL_SIZE + CELL_SIZE)\n        ])\n    pygame.display.flip()"
        },
        {
            "key_id": 0,
            "fqn": "src/run.py/write_to_input",
            "imports": [
                "import random"
            ],
            "code": "def write_to_input():\n    return [random.randint(0, 1) for _ in range(8)]"
        },
        {
            "key_id": 1,
            "fqn": "src/run.py/read_from_output",
            "imports": [],
            "code": "def read_from_output(value):\n    if value != [0,0,0,0,0,0,0,0]:\n        print(f\"Output: {value}\")\n        binary_str = ''.join(map(str, value))\n        decimal_value = int(binary_str, 2)\n        print(f\"Decimal equivalent: {decimal_value}\")"
        },
        {
            "key_id": 18,
            "fqn": "src/hardware/basic_components.py/HalfAdder/sum",
            "imports": [
                "from src.hardware.gates import xor"
            ],
            "code": "def sum(self) -> bool:\n    return xor(self.input1, self.input2)"
        },
        {
            "key_id": 19,
            "fqn": "src/hardware/basic_components.py/HalfAdder/carry",
            "imports": [
                "from src.hardware.gates import and_"
            ],
            "code": "def carry(self) -> bool:\n    return and_(self.input1, self.input2)"
        },
        {
            "key_id": 21,
            "fqn": "src/hardware/basic_components.py/FullAdder/sum",
            "imports": [],
            "code": "def sum(self):\n    return self.ha2.sum()"
        },
        {
            "key_id": 22,
            "fqn": "src/hardware/basic_components.py/FullAdder/carry",
            "imports": [],
            "code": "def carry(self):\n    return self.ha1.carry() or self.ha2.carry()"
        },
        {
            "key_id": 24,
            "fqn": "src/hardware/basic_components.py/Adder/sum",
            "imports": [],
            "code": "def sum(self) -> list[bool]:\n    return self._sum"
        },
        {
            "key_id": 25,
            "fqn": "src/hardware/basic_components.py/Adder/carry_out",
            "imports": [],
            "code": "def carry_out(self) -> bool:\n    return self._carry_out"
        },
        {
            "key_id": 27,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/diff",
            "imports": [
                "from src.hardware.gates import xor"
            ],
            "code": "def diff(self) -> bool:\n    return xor(self.input1, self.input2)"
        },
        {
            "key_id": 28,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/borrow",
            "imports": [
                "from src.hardware.gates import and_, not_"
            ],
            "code": "def borrow(self) -> bool:\n    return and_(not_(self.input1), self.input2)"
        },
        {
            "key_id": 30,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/diff",
            "imports": [],
            "code": "def diff(self):\n    return self.hs2.diff()"
        },
        {
            "key_id": 31,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/borrow",
            "imports": [
                "from src.hardware.gates import or_"
            ],
            "code": "def borrow(self):\n    return or_(self.hs1.borrow(), self.hs2.borrow())"
        },
        {
            "key_id": 33,
            "fqn": "src/hardware/basic_components.py/Subtractor/diff",
            "imports": [],
            "code": "def diff(self) -> list[bool]:\n    return [fs.diff() for fs in self.full_subtractors]"
        },
        {
            "key_id": 34,
            "fqn": "src/hardware/basic_components.py/Subtractor/borrow_out",
            "imports": [],
            "code": "def borrow_out(self) -> bool:\n    return self.full_subtractors[-1].borrow()"
        },
        {
            "key_id": 36,
            "fqn": "src/hardware/basic_components.py/Mux/output",
            "imports": [],
            "code": "def output(self) -> bool:\n    return self.input1 if not self.sel else self.input2"
        },
        {
            "key_id": 38,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n    return [mux.output() for mux in self.muxes]"
        },
        {
            "key_id": 40,
            "fqn": "src/hardware/basic_components.py/AddSub/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n    return self.mux.output()"
        },
        {
            "key_id": 41,
            "fqn": "src/hardware/basic_components.py/AddSub/overflow",
            "imports": [],
            "code": "def overflow(self) -> bool:\n    if self.operation:  # Addition\n        return self.adder.carry_out() != self.adder.sum()[-1]\n    else:  # Subtraction\n        return self.subtractor.borrow_out() != self.subtractor.diff()[-1]"
        },
        {
            "key_id": 42,
            "fqn": "src/hardware/basic_components.py/AddSub/borrow_out",
            "imports": [],
            "code": "def borrow_out(self) -> bool:\n    return self.subtractor.borrow_out() if not self.operation else False"
        },
        {
            "key_id": 44,
            "fqn": "src/hardware/basic_components.py/Decoder/output",
            "imports": [
                "from hardware.gates import and_, not_"
            ],
            "code": "def output(self) -> list[bool]:\n    return self.output_lines"
        },
        {
            "key_id": 46,
            "fqn": "src/hardware/basic_components.py/Control/output",
            "imports": [],
            "code": "def output(self) -> list[bool]:\n    control_output = [False] * 2\n    for i, decoded in enumerate(self.decoded_output):\n        if decoded:\n            control_output = self.control_signals[list(self.control_signals.keys())[i]]\n            break\n    return control_output"
        },
        {
            "key_id": 48,
            "fqn": "src/hardware/basic_components.py/Comparison/out",
            "imports": [],
            "code": "def out(self) -> bool:\n    control_output = self.control.output()\n    if control_output == [False, False]:  # Always\n        return True\n    elif control_output == [False, True]:  # Never\n        return False\n    elif control_output == [True, False]:  # Equal\n        return self.is_zero\n    elif control_output == [True, True]:  # Not Equal\n        return not self.is_zero\n    elif control_output == [False, False, True]:  # Less Than\n        return self.is_negative and not self.overflow\n    elif control_output == [False, True, True]:  # Less Than or Equal\n        return self.is_negative or self.is_zero\n    elif control_output == [True, False, True]:  # Greater Than\n        return not self.is_negative and not self.is_zero and not self.overflow\n    elif control_output == [True, True, True]:  # Greater Than or Equal\n        return not self.is_negative or self.is_zero\n    else:\n        return False"
        }
    ]
}