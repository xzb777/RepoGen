{
    "implementation": [
        {
            "key_id": 17,
            "fqn": "src/hardware/basic_components.py/HalfAdder/__init__",
            "imports": [],
            "code": "class HalfAdder:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sum = self.input1 ^ self.input2\n        self.carry = self.input1 and self.input2"
        },
        {
            "key_id": 20,
            "fqn": "src/hardware/basic_components.py/FullAdder/__init__",
            "imports": [
                "from .basic_components import HalfAdder"
            ],
            "code": "class FullAdder:\n    def __init__(self, input1: bool, input2: bool, carry_in: bool):\n        self.half_adder1 = HalfAdder(input1, input2)\n        self.half_adder2 = HalfAdder(self.half_adder1.sum, carry_in)\n        self.sum = self.half_adder2.sum\n        self.carry = self.half_adder1.carry or self.half_adder2.carry"
        },
        {
            "key_id": 23,
            "fqn": "src/hardware/basic_components.py/Adder/__init__",
            "imports": [
                "from .basic_components import FullAdder"
            ],
            "code": "class Adder:\n    def __init__(self, input1: list[bool], input2: list[bool], carry_in: bool = False):\n        self.result = []\n        carry = carry_in\n        for bit1, bit2 in zip(input1, input2):\n            full_adder = FullAdder(bit1, bit2, carry)\n            self.result.append(full_adder.sum)\n            carry = full_adder.carry\n        self.carry_out = carry"
        },
        {
            "key_id": 26,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/__init__",
            "imports": [],
            "code": "class HalfSubtractor:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.diff = self.input1 ^ self.input2\n        self.borrow = not self.input1 and self.input2"
        },
        {
            "key_id": 29,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/__init__",
            "imports": [
                "from .basic_components import HalfSubtractor"
            ],
            "code": "class FullSubtractor:\n    def __init__(self, input1: bool, input2: bool, borrow_in: bool):\n        self.half_subtractor1 = HalfSubtractor(input1, input2)\n        self.half_subtractor2 = HalfSubtractor(self.half_subtractor1.diff, borrow_in)\n        self.diff = self.half_subtractor2.diff\n        self.borrow = self.half_subtractor1.borrow or self.half_subtractor2.borrow"
        },
        {
            "key_id": 32,
            "fqn": "src/hardware/basic_components.py/Subtractor/__init__",
            "imports": [
                "from src.hardware.gates import not_",
                "from src.hardware.basic_components import Adder"
            ],
            "code": "class Subtractor:\n    def __init__(self, input1: list[bool], input2: list[bool], borrow_in: bool = False):\n        self.input1 = input1\n        self.input2 = [not_(bit) for bit in input2] # Inverting input2 for subtraction\n        self.borrow_in = borrow_in\n        self.adder = Adder(self.input1, self.input2, carry_in=not borrow_in) # Using Adder with inverted input2 and borrow_in\n\n        self.diff = self.adder.sum()\n        self.borrow_out = not self.adder.carry_out()"
        },
        {
            "key_id": 35,
            "fqn": "src/hardware/basic_components.py/Mux/__init__",
            "imports": [],
            "code": "class Mux:\n    def __init__(self, input1: bool, input2: bool, sel: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sel = sel\n\n    def output(self) -> bool:\n        return self.input2 if self.sel else self.input1"
        },
        {
            "key_id": 37,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/__init__",
            "imports": [],
            "code": "class Mux8Bit:\n    def __init__(self, input1: list[bool], input2: list[bool], sel: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sel = sel\n\n    def output(self) -> list[bool]:\n        return self.input2 if self.sel else self.input1"
        },
        {
            "key_id": 39,
            "fqn": "src/hardware/basic_components.py/AddSub/__init__",
            "imports": [
                "from src.hardware.gates import xor",
                "from src.hardware.basic_components import Adder"
            ],
            "code": "class AddSub:\n    def __init__(self, input1: list[bool], input2: list[bool], operation: bool):\n        self.input1 = input1\n        self.input2 = [xor(bit, operation) for bit in input2] # XOR with operation for addition/subtraction\n        self.operation = operation\n        self.adder = Adder(self.input1, self.input2, carry_in=operation) # Carry_in as operation for subtraction\n\n        self.result = self.adder.sum()\n        self.overflow = self.adder.carry_out\n        self.borrow_out = not self.adder.carry_out() if operation else False"
        },
        {
            "key_id": 43,
            "fqn": "src/hardware/basic_components.py/Decoder/__init__",
            "imports": [
                "from src.hardware.gates import and_, not_"
            ],
            "code": "class Decoder:\n    def __init__(self, input: list[bool]):\n        self.input = input\n\n    def output(self) -> list[bool]:\n        outputs = []\n        for i in range(len(self.input)**2):\n            outputs.append(and_(*[(self.input[j] if (i >> j) & 1 else not_(self.input[j])) for j in range(len(self.input))]))\n        return outputs"
        },
        {
            "key_id": 45,
            "fqn": "src/hardware/basic_components.py/Control/__init__",
            "imports": [
                "from src.hardware.gates import and_",
                "from src.hardware.gates import not_"
            ],
            "code": "class Control:\n    def __init__(self, input: list[bool]):\n        self.input = input\n        self.output = self.compute_output()\n\n    def compute_output(self) -> list[bool]:\n        # Assuming a specific logic for Control unit based on input\n        # This is a placeholder logic\n        output = []\n        for bit in self.input:\n            output.append(not_(and_(bit, True)))  # Example logic\n        return output"
        },
        {
            "key_id": 53,
            "fqn": "src/hardware/alu.py/ALU/__init__",
            "imports": [
                "from src.hardware.gates import and_",
                "from src.hardware.gates import or_",
                "from src.hardware.basic_components import AddSub",
                "from src.hardware.basic_components import Mux8Bit"
            ],
            "code": "class ALU:\n    def __init__(self, input1: list[bool], input2: list[bool], control1: bool, control2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.control1 = control1\n        self.control2 = control2\n        self.result = self.compute_result()\n\n    def compute_result(self):\n        # Placeholder logic for ALU operations\n        if self.control1 and not self.control2:\n            return AddSub(self.input1, self.input2, False).output()\n        elif not self.control1 and self.control2:\n            return Mux8Bit(self.input1, self.input2, True).output()\n        else:\n            return [False] * 8  # Default case"
        },
        {
            "key_id": 47,
            "fqn": "src/hardware/basic_components.py/Comparison/__init__",
            "imports": [
                "from src.hardware.gates import and_",
                "from src.hardware.gates import or_",
                "from src.hardware.gates import not_",
                "from src.hardware.gates import nand",
                "from src.hardware.gates import xor"
            ],
            "code": "class Comparison:\n    def __init__(self, control: list[bool], byte: list[bool]):\n        self.control = control\n        self.byte = byte\n        self.result = self.compute_result()\n\n    def compute_result(self) -> bool:\n        # Placeholder logic for comparison\n        # Assuming a simple comparison logic\n        if xor(self.control[0], self.byte[0]):\n            return True\n        else:\n            return False"
        },
        {
            "key_id": 49,
            "fqn": "src/hardware/registers.py/Registers/__init__",
            "imports": [],
            "code": "class Registers:\n    def __init__(self):\n        self.registers = [0] * 8  # Initialize 8 registers with 0\n\n    def read(self, register):\n        return self.registers[register]\n\n    def write(self, register, data):\n        self.registers[register] = data"
        },
        {
            "key_id": 66,
            "fqn": "src/hardware/cpu.py/CPU/__init__",
            "imports": [
                "from src.hardware.registers import Registers",
                "from src.hardware.alu import ALU"
            ],
            "code": "class CPU:\n    def __init__(self, program, verbose = True):\n        self.program = program\n        self.verbose = verbose\n        self.registers = Registers()\n        self.alu = ALU([False]*8, [False]*8, False, False)\n\n    def run(self, write_to_input: callable = None, read_from_output: callable = None):\n        # Placeholder for CPU run logic\n        if write_to_input:\n            input_data = write_to_input()\n            # Process input data\n        if read_from_output:\n            output_data = [False] * 8  # Example output data\n            read_from_output(output_data)"
        },
        {
            "key_id": 68,
            "fqn": "src/hardware/cpu.py/Cycle/__init__",
            "imports": [],
            "code": "class Cycle:\n    def __init__(self, cpu, program_instruction_byte):\n        self.cpu = cpu\n        self.program_instruction_byte = program_instruction_byte\n        self.current_operation = None\n\n    def fetch_instruction(self):\n        # Assuming the program_instruction_byte is an index to the CPU's memory\n        instruction = self.cpu.memory[self.program_instruction_byte]\n        self.current_operation = instruction\n\n    def decode_instruction(self):\n        # Decoding logic based on the instruction set\n        # Placeholder for decoding logic\n        pass\n\n    def execute(self):\n        # Placeholder for execution logic, should be implemented in dependency\n        pass"
        },
        {
            "key_id": 8,
            "fqn": "src/games/maze.py/Robot/__init__",
            "imports": [
                "import pygame"
            ],
            "code": "class Robot:\n    def __init__(self, initial_pos=[1,1], initial_dir='up', delay=0):\n        self.position = initial_pos\n        self.direction = initial_dir\n        self.delay = delay\n        self.visited = set()\n        self.visited.add(tuple(self.position))\n\n    def move_forward(self):\n        if self.direction == 'up':\n            self.position[1] -= 1\n        elif self.direction == 'down':\n            self.position[1] += 1\n        elif self.direction == 'left':\n            self.position[0] -= 1\n        elif self.direction == 'right':\n            self.position[0] += 1\n        self.visited.add(tuple(self.position))\n\n    def turn_left(self):\n        directions = ['up', 'right', 'down', 'left']\n        self.direction = directions[(directions.index(self.direction) - 1) % 4]\n\n    def turn_right(self):\n        directions = ['up', 'right', 'down', 'left']\n        self.direction = directions[(directions.index(self.direction) + 1) % 4]"
        },
        {
            "key_id": 59,
            "fqn": "src/hardware/gates.py/and_",
            "imports": [],
            "code": "def and_(*args) -> int:\n    result = 1\n    for arg in args:\n        result &= arg\n    return result"
        },
        {
            "key_id": 60,
            "fqn": "src/hardware/gates.py/or_",
            "imports": [],
            "code": "def or_(*args) -> int:\n    result = 0\n    for arg in args:\n        result |= arg\n    return result"
        },
        {
            "key_id": 61,
            "fqn": "src/hardware/gates.py/not_",
            "imports": [],
            "code": "def not_(*args) -> int:\n    if len(args) != 1:\n        raise ValueError('not_ function takes exactly one argument')\n    return int(not args[0])"
        },
        {
            "key_id": 62,
            "fqn": "src/hardware/gates.py/nor",
            "imports": [],
            "code": "def nor(*args) -> int:\n    result = 0\n    for arg in args:\n        result |= arg\n    return int(not result)"
        },
        {
            "key_id": 63,
            "fqn": "src/hardware/gates.py/nand",
            "imports": [],
            "code": "def nand(*args) -> int:\n    result = 1\n    for arg in args:\n        result &= arg\n    return int(not result)"
        },
        {
            "key_id": 64,
            "fqn": "src/hardware/gates.py/xor",
            "imports": [],
            "code": "def xor(a: bool, b: bool) -> int:\n    return int(a != b)"
        },
        {
            "key_id": 65,
            "fqn": "src/hardware/gates.py/xnor",
            "imports": [],
            "code": "def xnor(a: bool, b: bool) -> int:\n    return int(a == b)"
        },
        {
            "key_id": 18,
            "fqn": "src/hardware/basic_components.py/HalfAdder/sum",
            "imports": [
                "from src.hardware.gates import xor"
            ],
            "code": "class HalfAdder:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sum = xor(self.input1, self.input2)\n        self.carry = self.input1 and self.input2\n\n    def sum(self) -> bool:\n        return self.sum"
        },
        {
            "key_id": 19,
            "fqn": "src/hardware/basic_components.py/HalfAdder/carry",
            "imports": [],
            "code": "class HalfAdder:\n    def __init__(self, input1: bool, input2: bool):\n        self.input1 = input1\n        self.input2 = input2\n        self.sum = self.input1 ^ self.input2\n        self.carry = self.input1 and self.input2\n\n    def carry(self) -> bool:\n        return self.carry"
        },
        {
            "key_id": 21,
            "fqn": "src/hardware/basic_components.py/FullAdder/sum",
            "imports": [
                "from src.hardware.basic_components import HalfAdder"
            ],
            "code": "class FullAdder:\n    def __init__(self, input1: bool, input2: bool, carry_in: bool):\n        self.half_adder1 = HalfAdder(input1, input2)\n        self.half_adder2 = HalfAdder(self.half_adder1.sum, carry_in)\n        self.sum = self.half_adder2.sum\n        self.carry = self.half_adder1.carry or self.half_adder2.carry\n\n    def sum(self):\n        return self.sum"
        },
        {
            "key_id": 22,
            "fqn": "src/hardware/basic_components.py/FullAdder/carry",
            "imports": [
                "from src.hardware.gates import or_"
            ],
            "code": "def carry(self) -> bool:\n    return or_(self.half_adder1.carry, self.half_adder2.carry)"
        },
        {
            "key_id": 24,
            "fqn": "src/hardware/basic_components.py/Adder/sum",
            "imports": [],
            "code": "def sum(self) -> list[bool]:\n    return self.result"
        },
        {
            "key_id": 25,
            "fqn": "src/hardware/basic_components.py/Adder/carry_out",
            "imports": [],
            "code": "def carry_out(self) -> bool:\n    return self.carry_out"
        },
        {
            "key_id": 27,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/diff",
            "imports": [
                "from src.hardware.gates import xor"
            ],
            "code": "def diff(self) -> bool:\n    return xor(self.input1, self.input2)"
        },
        {
            "key_id": 28,
            "fqn": "src/hardware/basic_components.py/HalfSubtractor/borrow",
            "imports": [
                "from src.hardware.gates import and_, not_"
            ],
            "code": "def borrow(self) -> bool:\n    return and_(not_(self.input1), self.input2)"
        },
        {
            "key_id": 30,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/diff",
            "imports": [],
            "code": "def diff(self):\n    # Calculate the difference using the half subtractors\n    self.diff = self.half_subtractor2.diff"
        },
        {
            "key_id": 31,
            "fqn": "src/hardware/basic_components.py/FullSubtractor/borrow",
            "imports": [
                "from src.hardware.gates import or_"
            ],
            "code": "def borrow(self):\n    # Calculate the borrow\n    self.borrow = or_(self.half_subtractor1.borrow, self.half_subtractor2.borrow)"
        },
        {
            "key_id": 33,
            "fqn": "src/hardware/basic_components.py/Subtractor/diff",
            "imports": [],
            "code": "def diff(self) -> list[bool]:\n    # Perform subtraction by adding the inverted second input and the borrow_in\n    self.diff = self.adder.sum()\n    return self.diff"
        },
        {
            "key_id": 34,
            "fqn": "src/hardware/basic_components.py/Subtractor/borrow_out",
            "imports": [],
            "code": "def borrow_out(self) -> bool:\n    # Determine if there was a borrow out\n    self.borrow_out = not self.adder.carry_out()\n    return self.borrow_out"
        },
        {
            "key_id": 36,
            "fqn": "src/hardware/basic_components.py/Mux/output",
            "imports": [
                "from src.hardware.gates import nand"
            ],
            "code": "def output(self) -> bool:\n    # Select the output based on the sel signal\n    if self.sel:\n        return self.input2\n    else:\n        return self.input1"
        },
        {
            "key_id": 38,
            "fqn": "src/hardware/basic_components.py/Mux8Bit/output",
            "imports": [
                "from src.hardware.gates import nand"
            ],
            "code": "def output(self) -> list[bool]:\n    result = []\n    for i in range(8):\n        result.append(nand(nand(self.input1[i], not self.sel), nand(not self.input2[i], self.sel)))\n    return result"
        },
        {
            "key_id": 40,
            "fqn": "src/hardware/basic_components.py/AddSub/output",
            "imports": [
                "from src.hardware.basic_components import Adder",
                "from src.hardware.gates import xor"
            ],
            "code": "def output(self) -> list[bool]:\n    self.input2 = [xor(bit, self.operation) for bit in self.input2]\n    self.adder = Adder(self.input1, self.input2, carry_in=self.operation)\n    self.result = self.adder.sum()\n    return self.result"
        },
        {
            "key_id": 41,
            "fqn": "src/hardware/basic_components.py/AddSub/overflow",
            "imports": [],
            "code": "def overflow(self) -> bool:\n    return self.adder.carry_out()"
        },
        {
            "key_id": 42,
            "fqn": "src/hardware/basic_components.py/AddSub/borrow_out",
            "imports": [
                "from src.hardware.gates import not_"
            ],
            "code": "def borrow_out(self) -> bool:\n    if self.operation:\n        return not self.adder.carry_out()\n    return False"
        },
        {
            "key_id": 44,
            "fqn": "src/hardware/basic_components.py/Decoder/output",
            "imports": [
                "from src.hardware.gates import and_, not_"
            ],
            "code": "def output(self) -> list[bool]:\n    outputs = []\n    for i in range(2 ** len(self.input)):\n        outputs.append(all([(self.input[j] if (i >> j) & 1 else not_(self.input[j])) for j in range(len(self.input))]))\n    return outputs"
        },
        {
            "key_id": 46,
            "fqn": "src/hardware/basic_components.py/Control/output",
            "imports": [
                "from src.hardware.gates import not_",
                "from src.hardware.gates import and_"
            ],
            "code": "def output(self) -> list[bool]:\n    # Assuming a specific logic for Control unit based on input\n    # This is a placeholder logic\n    output = []\n    for bit in self.input:\n        output.append(not_(and_(bit, True)))  # Example logic using AND and NOT gates\n    return output"
        },
        {
            "key_id": 54,
            "fqn": "src/hardware/alu.py/ALU/out",
            "imports": [
                "from src.hardware.basic_components import Mux8Bit",
                "from src.hardware.basic_components import AddSub"
            ],
            "code": "def out(self):\n    # Placeholder logic for ALU operations\n    if self.control1 and not self.control2:\n        return AddSub(self.input1, self.input2, False).output()\n    elif not self.control1 and self.control2:\n        return Mux8Bit(self.input1, self.input2, True).output()\n    else:\n        return [False] * 8  # Default case"
        },
        {
            "key_id": 55,
            "fqn": "src/hardware/alu.py/ALU/zero",
            "imports": [
                "from src.hardware.gates import not_",
                "from src.hardware.gates import or_"
            ],
            "code": "def zero(self):\n    # Check if the result is zero by ORing all bits and NOT the result\n    return not_(or_(*self.result))"
        },
        {
            "key_id": 56,
            "fqn": "src/hardware/alu.py/ALU/negative",
            "imports": [],
            "code": "def negative(self):\n    # Assuming the most significant bit indicates sign\n    # True if negative, False otherwise\n    return self.result[-1]"
        },
        {
            "key_id": 57,
            "fqn": "src/hardware/alu.py/ALU/overflow",
            "imports": [],
            "code": "def overflow(self):\n    # Placeholder for overflow detection logic\n    # This will depend on the specific ALU operation performed\n    # For simplicity, let's assume no overflow occurs\n    return False"
        },
        {
            "key_id": 58,
            "fqn": "src/hardware/alu.py/ALU/carry_out",
            "imports": [],
            "code": "def carry_out(self) -> bool:\n    # Assuming the last operation was an addition or subtraction,\n    # this method returns True if there was a carry out (or overflow in subtraction)\n    # This is a simplified logic assuming a binary addition/subtraction.\n    if self.control1 and not self.control2:  # ADD operation\n        return self.result[-1]  # Assuming the result is a list of bools, last bit is carry\n    elif not self.control1 and self.control2:  # SUB operation\n        # For subtraction, carry out is interpreted as borrow, which is not directly\n        # available in the result. This requires additional logic to determine.\n        # Placeholder for subtraction carry out (borrow) logic.\n        return False  # Placeholder return\n    else:\n        return False  # Default case for operations other than add/sub"
        },
        {
            "key_id": 48,
            "fqn": "src/hardware/basic_components.py/Comparison/out",
            "imports": [
                "from src.hardware.gates import xor"
            ],
            "code": "def out(self) -> bool:\n    # This method compares the control bit with the first bit of the byte\n    # using XOR to determine if they are different, implying a comparison operation.\n    # True if different, False if the same.\n    return xor(self.control[0], self.byte[0])"
        },
        {
            "key_id": 50,
            "fqn": "src/hardware/registers.py/Registers/read",
            "imports": [
                "from src.hardware.gates import or_"
            ],
            "code": "def read(self, register) -> int:\n    # This method reads the value from the specified register.\n    # Using 'or_' gate here to simulate reading process might not be directly relevant,\n    # but assuming it's part of a larger logic to ensure the register is accessible.\n    # Placeholder logic to return the register's value.\n    return self.registers[register]"
        },
        {
            "key_id": 51,
            "fqn": "src/hardware/registers.py/Registers/write",
            "imports": [],
            "code": "def write(self, register, data) -> None:\n    # This method writes the given data to the specified register.\n    # Ensuring data is within the 8-bit limit and register index is valid.\n    if 0 <= register < len(self.registers) and 0 <= data < 256:\n        self.registers[register] = data\n    else:\n        raise ValueError('Invalid register index or data out of bounds')"
        },
        {
            "key_id": 52,
            "fqn": "src/hardware/registers.py/Registers/write_to_register",
            "imports": [],
            "code": "def write_to_register(self, register, data) -> None:\n    # This method is similar to 'write' but might include additional logic\n    # specific to certain registers or data processing.\n    # For simplicity, reusing the 'write' method logic here.\n    self.write(register, data)"
        },
        {
            "key_id": 67,
            "fqn": "src/hardware/cpu.py/CPU/run",
            "imports": [
                "from src.hardware.cpu import Cycle"
            ],
            "code": "def run(self, write_to_input: callable = None, read_from_output: callable = None):\n        if write_to_input:\n            input_data = write_to_input()\n            self.registers.write_to_register('input', input_data)\n        program_counter = 0\n        while program_counter < len(self.program):\n            instruction_byte = self.program[program_counter]\n            cycle = Cycle(self, instruction_byte)\n            cycle.execute()\n            program_counter += 1\n            if self.verbose:\n                print(f'Executing instruction at address {program_counter}')\n        if read_from_output:\n            output_data = self.registers.read('output')\n            read_from_output(output_data)"
        },
        {
            "key_id": 69,
            "fqn": "src/hardware/cpu.py/Cycle/execute",
            "imports": [],
            "code": "def execute(self):\n        self.fetch_instruction()\n        self.decode_instruction()\n        # Assuming a simple operation execution based on the current_operation\n        # This is a placeholder for the actual execution logic\n        if self.current_operation == 'add':\n            self.cpu.alu.add(self.cpu.registers.read('reg1'), self.cpu.registers.read('reg2'))\n        elif self.current_operation == 'sub':\n            self.cpu.alu.sub(self.cpu.registers.read('reg1'), self.cpu.registers.read('reg2'))\n        # More operations can be added here\n        # Update the program counter, handle flags, etc."
        },
        {
            "key_id": 2,
            "fqn": "src/assembler.py/get_labels",
            "imports": [],
            "code": "def get_labels(file) -> dict:\n        labels = {}\n        with open(file, 'r') as f:\n            for line_number, line in enumerate(f):\n                if line.startswith('label'):\n                    label_name = line.split()[1]\n                    labels[label_name] = line_number\n        return labels"
        },
        {
            "key_id": 3,
            "fqn": "src/assembler.py/immediate_values",
            "imports": [],
            "code": "def immediate_values(line, labels):\n        parts = line.split()\n        if parts[0] in labels:\n            return labels[parts[0]]\n        else:\n            return int(parts[1]) if len(parts) > 1 else None"
        },
        {
            "key_id": 4,
            "fqn": "src/assembler.py/copy_instructions",
            "imports": [],
            "code": "def copy_instructions(line):\n        parts = line.split()\n        if parts[0] == 'copy':\n            src = int(parts[1])\n            dest = int(parts[2])\n            return {'op': 'copy', 'src': src, 'dest': dest}\n        else:\n            return None"
        },
        {
            "key_id": 5,
            "fqn": "src/assembler.py/operate_instructions",
            "imports": [],
            "code": "def operate_instructions(line):\n    operations = {'add': '0001', 'sub': '0010', 'and': '0011', 'or': '0100'}\n    op_code = operations.get(line.strip())\n    if op_code is None:\n        raise ValueError(f'Unsupported operation: {line}')\n    return op_code"
        },
        {
            "key_id": 6,
            "fqn": "src/assembler.py/jump_instructions",
            "imports": [],
            "code": "def jump_instructions(line):\n    conditions = {'always': '0001', 'never': '0010', '=', '0011', '!=': '0100', '<': '0101', '<=': '0110', '>': '0111', '>=': '1000'}\n    parts = line.split()\n    condition_code = conditions.get(parts[0])\n    if condition_code is None:\n        raise ValueError(f'Unsupported condition: {parts[0]}')\n    return condition_code + ' ' + ' '.join(parts[1:])"
        },
        {
            "key_id": 7,
            "fqn": "src/assembler.py/assemble_binary",
            "imports": [
                "from .get_labels import get_labels",
                "from .immediate_values import immediate_values",
                "from .copy_instructions import copy_instructions",
                "from .operate_instructions import operate_instructions",
                "from .jump_instructions import jump_instructions"
            ],
            "code": "def assemble_binary(filename: str):\n    with open(filename, 'r') as file:\n        lines = file.readlines()\n    labels = get_labels(lines)\n    binary_code = []\n    for line in lines:\n        if line.startswith('copy'):\n            binary_code.append(copy_instructions(line))\n        elif any(op in line for op in ['add', 'sub', 'and', 'or']):\n            binary_code.append(operate_instructions(line))\n        elif any(cond in line for cond in ['always', 'never', '=', '!=', '<', '<=', '>', '>=']):\n            binary_code.append(jump_instructions(line, labels))\n        else:\n            binary_code.append(immediate_values(line, labels))\n    return '\\n'.join(binary_code)"
        },
        {
            "key_id": 9,
            "fqn": "src/games/maze.py/Robot/event_check",
            "imports": [
                "import pygame"
            ],
            "code": "def event_check(self):\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            exit()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_LEFT:\n                self.turn_left()\n            elif event.key == pygame.K_RIGHT:\n                self.turn_right()\n            elif event.key == pygame.K_UP:\n                self.move_forward()"
        },
        {
            "key_id": 10,
            "fqn": "src/games/maze.py/Robot/move_forward",
            "imports": [],
            "code": "def move_forward(self):\n    next_cell = self.get_front_cell()\n    if next_cell != 1:  # Not a wall\n        super().move_forward()\n    else:\n        print('Wall ahead! Cannot move forward.')"
        },
        {
            "key_id": 11,
            "fqn": "src/games/maze.py/Robot/turn_left",
            "imports": [],
            "code": "def turn_left(self):\n    directions = ['up', 'right', 'down', 'left']\n    self.direction = directions[(directions.index(self.direction) - 1) % 4]"
        },
        {
            "key_id": 12,
            "fqn": "src/games/maze.py/Robot/turn_right",
            "imports": [],
            "code": "def turn_right(self):\n    directions = ['up', 'right', 'down', 'left']\n    self.direction = directions[(directions.index(self.direction) + 1) % 4]"
        },
        {
            "key_id": 13,
            "fqn": "src/games/maze.py/Robot/move",
            "imports": [],
            "code": "def move(self, instruction):\n    if instruction == 'forward':\n        self.move_forward()\n    elif instruction == 'left':\n        self.turn_left()\n    elif instruction == 'right':\n        self.turn_right()\n    time.sleep(self.delay)\n    draw(self)"
        },
        {
            "key_id": 14,
            "fqn": "src/games/maze.py/Robot/get_front_cell",
            "imports": [],
            "code": "def get_front_cell(self):\n    x, y = self.position\n    if self.direction == 'up':\n        return [x, y-1]\n    elif self.direction == 'down':\n        return [x, y+1]\n    elif self.direction == 'left':\n        return [x-1, y]\n    elif self.direction == 'right':\n        return [x+1, y]"
        },
        {
            "key_id": 15,
            "fqn": "src/games/maze.py/Robot/get_front_cell_bit",
            "imports": [],
            "code": "def get_front_cell_bit(self):\n    front_cell = self.get_front_cell()\n    x, y = front_cell\n    if maze[y][x] == 1:\n        return 1\n    else:\n        return 0"
        },
        {
            "key_id": 16,
            "fqn": "src/games/maze.py/draw",
            "imports": [
                "import pygame",
                "from src.games.maze import CELL_SIZE, WHITE, RED, GREEN, BLACK, BLUE, directions, maze"
            ],
            "code": "def draw(robot):\n    pygame.init()\n    win_size = [len(maze[0]) * CELL_SIZE, len(maze) * CELL_SIZE]\n    win = pygame.display.set_mode(win_size)\n    pygame.display.set_caption('Maze Runner')\n    clock = pygame.time.Clock()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n\n        win.fill(WHITE)\n        for y, row in enumerate(maze):\n            for x, cell in enumerate(row):\n                rect = pygame.Rect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE)\n                if cell == 1:\n                    pygame.draw.rect(win, BLACK, rect)\n                elif cell == 2:\n                    pygame.draw.rect(win, GREEN, rect)\n\n        robot_pos = robot.get_front_cell()\n        robot_rect = pygame.Rect(robot_pos[0]*CELL_SIZE, robot_pos[1]*CELL_SIZE, CELL_SIZE, CELL_SIZE)\n        pygame.draw.rect(win, RED, robot_rect)\n\n        pygame.display.update()\n        clock.tick(5)"
        },
        {
            "key_id": 0,
            "fqn": "src/run.py/write_to_input",
            "imports": [
                "from src.hardware.cpu import CPU",
                "from src.assembler import assemble_binary"
            ],
            "code": "def write_to_input():\n    # Assuming the input function is designed to provide\n    # input to the CPU in a predefined manner.\n    # This is a placeholder implementation.\n    # Actual implementation may vary based on CPU input mechanism.\n    return [0, 0, 0, 0, 0, 0, 0, 1]"
        },
        {
            "key_id": 1,
            "fqn": "src/run.py/read_from_output",
            "imports": [
                "from src.hardware.cpu import CPU",
                "from src.assembler import assemble_binary"
            ],
            "code": "def read_from_output(value):\n    # Assuming the output function is designed to handle\n    # output from the CPU in a predefined manner.\n    # This is a placeholder implementation.\n    # Actual implementation may vary based on CPU output mechanism.\n    if value != [0, 0, 0, 0, 0, 0, 0, 0]: # CPU always returns 0 by default\n        print('result:', value)"
        }
    ]
}