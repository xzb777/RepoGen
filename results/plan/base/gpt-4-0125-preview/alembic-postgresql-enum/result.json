{
    "implementation": [
        {
            "key_id": 48,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/__init__",
            "imports": [
                "from typing import Iterable"
            ],
            "code": "class EnumLifecycleOp:\n    def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n        self.schema = schema\n        self.name = name\n        self.enum_values = list(enum_values)\n        super().__init__()"
        },
        {
            "key_id": 41,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/__init__",
            "imports": [
                "from typing import List",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "import logging"
            ],
            "code": "class SyncEnumValuesOp:\n    operation_name = \"change_enum_variants\"\n\n    def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n        self.schema = schema\n        self.name = name\n        self.old_values = old_values\n        self.new_values = new_values\n        self.affected_columns = affected_columns\n        log = logging.getLogger(f\"alembic.{__name__}\")\n        log.info(f\"Preparing to sync enum values for {name} in schema {schema}\")\n        super().__init__()"
        },
        {
            "key_id": 0,
            "fqn": "alembic_postgresql_enum/connection.py/get_connection",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from contextlib import contextmanager",
                "from typing import Iterator"
            ],
            "code": "@contextmanager\ndef get_connection(operations) -> Iterator[Connection]:\n    bind = operations.get_bind()\n    if not isinstance(bind, Connection):\n        raise TypeError(f'Expected a Connection, got {type(bind)}')\n    yield bind"
        },
        {
            "key_id": 1,
            "fqn": "alembic_postgresql_enum/compare_dispatch.py/compare_enums",
            "imports": [
                "import logging",
                "from sqlalchemy.engine import Connection",
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic.operations import Ops",
                "from typing import Iterable, Union",
                "from .sql_commands.enum_type import create_type, drop_type, cast_old_enum_type_to_new, cast_old_array_enum_type_to_new"
            ],
            "code": "log = logging.getLogger(f\"alembic.{__name__}\")\n\ndef compare_enums(autogen_context: AutogenContext, upgrade_ops: Ops, schema_names: Iterable[Union[str, None]]):\n    # Assuming implementation details here\n    log.info(\"Comparing enums across schemas\")\n    for schema in schema_names:\n        log.debug(f\"Processing schema: {schema}\")\n        # Example: Create or drop enums based on comparison results\n        # This is a placeholder for actual logic\n        if schema == 'public':\n            create_type(connection=autogen_context.connection, schema=schema, type_name='new_enum', enum_values=['value1', 'value2'])\n        else:\n            drop_type(connection=autogen_context.connection, schema=schema, type_name='old_enum')"
        },
        {
            "key_id": 49,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/operation_name",
            "imports": [],
            "code": "class EnumLifecycleOp:\n    def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n        self.schema = schema\n        self.name = name\n        self.enum_values = list(enum_values)\n        super().__init__()\n\n    def operation_name(self) -> str:\n        raise NotImplementedError('Subclasses must implement operation_name method')"
        },
        {
            "key_id": 50,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/to_diff_tuple",
            "imports": [
                "from typing import Tuple, Any"
            ],
            "code": "class EnumLifecycleOp:\n    def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n        self.schema = schema\n        self.name = name\n        self.enum_values = list(enum_values)\n        super().__init__()\n\n    def to_diff_tuple(self) -> Tuple[Any, ...]:\n        return ('EnumLifecycleOp', self.schema, self.name, self.enum_values)"
        },
        {
            "key_id": 51,
            "fqn": "alembic_postgresql_enum/operations/create_enum.py/CreateEnumOp/reverse",
            "imports": [
                "from typing import List",
                "from .enum_lifecycle_base import EnumLifecycleOp"
            ],
            "code": "class CreateEnumOp(EnumLifecycleOp):\n    operation_name = \"create_enum\"\n\n    def reverse(self):\n        from .drop_enum import DropEnumOp\n        return DropEnumOp(schema=self.schema, name=self.name, enum_values=self.enum_values)"
        },
        {
            "key_id": 52,
            "fqn": "alembic_postgresql_enum/operations/create_enum.py/render_create_enum_op",
            "imports": [
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic.operations import ops",
                "from .create_enum import CreateEnumOp"
            ],
            "code": "def render_create_enum_op(autogen_context: AutogenContext, op: CreateEnumOp):\n    args = ', '.join([f'\"{arg}\"' for arg in op.enum_values])\n    return f\"op.create_enum(name='{op.name}', enum_values=[{args}], schema='{op.schema}')\""
        },
        {
            "key_id": 53,
            "fqn": "alembic_postgresql_enum/operations/drop_enum.py/DropEnumOp/reverse",
            "imports": [
                "from alembic.operations import ops"
            ],
            "code": "class DropEnumOp(ops.MigrateOperation):\n    operation_name = \"drop_enum\"\n\n    def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n        self.schema = schema\n        self.name = name\n        self.enum_values = list(enum_values)\n\n    def reverse(self):\n        return CreateEnumOp(schema=self.schema, name=self.name, enum_values=self.enum_values)"
        },
        {
            "key_id": 54,
            "fqn": "alembic_postgresql_enum/operations/drop_enum.py/render_drop_enum_op",
            "imports": [
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic.operations import ops",
                "from .drop_enum import DropEnumOp"
            ],
            "code": "def render_drop_enum_op(autogen_context: AutogenContext, op: DropEnumOp):\n    return f\"op.drop_enum(name='{op.name}', schema='{op.schema}')\""
        },
        {
            "key_id": 42,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/reverse",
            "imports": [
                "from typing import List, Tuple",
                "from .sync_enum_values import SyncEnumValuesOp",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "import logging"
            ],
            "code": "class SyncEnumValuesOp:\n    operation_name = \"change_enum_variants\"\n\n    def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n        self.schema = schema\n        self.name = name\n        self.old_values = old_values\n        self.new_values = new_values\n        self.affected_columns = affected_columns\n        log = logging.getLogger(f\"alembic.{__name__}\")\n        log.info(f\"Preparing to sync enum values for {name} in schema {schema}\")\n        super().__init__()\n\n    def reverse(self):\n        return SyncEnumValuesOp(schema=self.schema, name=self.name, old_values=self.new_values, new_values=self.old_values, affected_columns=self.affected_columns)"
        },
        {
            "key_id": 43,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/_set_enum_values",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "import logging"
            ],
            "code": "def _set_enum_values(cls, connection: Connection, enum_schema: str, enum_name: str, new_values: List[str], affected_columns: List[TableReference], enum_values_to_rename: List[Tuple[str, str]]):\n    log = logging.getLogger('alembic.runtime.migration')\n    log.info(f'Setting new values for enum {enum_name} in schema {enum_schema}')\n    # Implementation to set enum values in the database, including handling renamed values"
        },
        {
            "key_id": 44,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/sync_enum_values",
            "imports": [
                "from typing import List, Tuple, Iterable",
                "from alembic.operations import Operations",
                "from alembic_postgresql_enum.sql_commands.enum_type import cast_old_enum_type_to_new, cast_old_array_enum_type_to_new",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "import logging"
            ],
            "code": "class SyncEnumValuesOp:\n    operation_name = \"change_enum_variants\"\n\n    def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n        self.schema = schema\n        self.name = name\n        self.old_values = old_values\n        self.new_values = new_values\n        self.affected_columns = affected_columns\n        log = logging.getLogger(f\"alembic.{__name__}\")\n        log.info(f\"Preparing to sync enum values for {name} in schema {schema}\")\n        super().__init__()\n\n    @classmethod\n    def sync_enum_values(cls, operations: Operations, enum_schema: str, enum_name: str, new_values: List[str], affected_columns: List[Tuple[str, str]], enum_values_to_rename: Iterable[Tuple[str, str]] = tuple()):\n        connection = operations.get_bind()\n        for table_name, column_name in affected_columns:\n            table_reference = TableReference(schema=enum_schema, table_name=table_name, column_name=column_name)\n            if any(enum_values_to_rename):\n                cast_old_enum_type_to_new(connection, table_reference, enum_name, list(enum_values_to_rename))\n            else:\n                cast_old_array_enum_type_to_new(connection, table_reference, enum_name, new_values)"
        },
        {
            "key_id": 45,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/to_diff_tuple",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "class SyncEnumValuesOp:\n    operation_name = \"change_enum_variants\"\n\n    def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n        self.schema = schema\n        self.name = name\n        self.old_values = old_values\n        self.new_values = new_values\n        self.affected_columns = affected_columns\n        log = logging.getLogger(f\"alembic.{__name__}\")\n        log.info(f\"Preparing to sync enum values for {name} in schema {schema}\")\n        super().__init__()\n\n    def to_diff_tuple(self) -> Tuple[Any, ...]:\n        return ('enum_values_changed', self.schema, self.name, self.old_values, self.new_values)"
        },
        {
            "key_id": 46,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/is_column_type_import_needed",
            "imports": [
                "from alembic_postgresql_enum.get_enum_data.types import TableReference"
            ],
            "code": "class SyncEnumValuesOp:\n    operation_name = \"change_enum_variants\"\n\n    def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n        self.schema = schema\n        self.name = name\n        self.old_values = old_values\n        self.new_values = new_values\n        self.affected_columns = affected_columns\n        log = logging.getLogger(f\"alembic.{__name__}\")\n        log.info(f\"Preparing to sync enum values for {name} in schema {schema}\")\n        super().__init__()\n\n    def is_column_type_import_needed(self) -> bool:\n        return any(isinstance(col, TableReference) for col in self.affected_columns)"
        },
        {
            "key_id": 47,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/render_sync_enum_value_op",
            "imports": [
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp"
            ],
            "code": "def render_sync_enum_value_op(autogen_context: AutogenContext, op: SyncEnumValuesOp):\n    args = [\n        repr(op.schema),\n        repr(op.name),\n        repr(op.old_values),\n        repr(op.new_values),\n        repr([(col.table_name, col.column_name) for col in op.affected_columns])\n    ]\n    if op.enum_values_to_rename:\n        args.append(repr(op.enum_values_to_rename))\n    return f\"op.sync_enum_values({', '.join(args)})\""
        },
        {
            "key_id": 38,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_creation.py/create_new_enums",
            "imports": [
                "from typing import Dict",
                "from alembic.operations import Operations",
                "from alembic_postgresql_enum.sql_commands.enum_type import create_type",
                "from alembic_postgresql_enum.get_enum_data.defined_enums import EnumNamesToValues",
                "from alembic_postgresql_enum.get_enum_data.declared_enums import get_declared_enums",
                "import logging"
            ],
            "code": "def create_new_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, schema: str, upgrade_ops: Operations):\n    log = logging.getLogger('alembic.runtime.migration')\n    for enum_name, enum_values in declared_enums.items():\n        if enum_name not in defined_enums:\n            log.info(f\"Creating new enum {enum_name} in schema {schema}\")\n            create_type(upgrade_ops.get_bind(), schema, enum_name, enum_values)"
        },
        {
            "key_id": 14,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/create_type",
            "imports": [
                "from sqlalchemy import text",
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def create_type(connection: Connection, schema: str, type_name: str, enum_values: List[str]):\n    enum_values_str = ','.join([f\"'{value}'\" for value in enum_values])\n    schema_prefix = f'{schema}.' if schema else ''\n    connection.execute(text(f\"CREATE TYPE {schema_prefix}{type_name} AS ENUM ({enum_values_str})\"))"
        },
        {
            "key_id": 12,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/drop_type",
            "imports": [
                "from sqlalchemy import text",
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def drop_type(connection: Connection, schema: str, type_name: str):\n    schema_prefix = f'{schema}.' if schema else ''\n    connection.execute(text(f\"DROP TYPE IF EXISTS {schema_prefix}{type_name}\"))"
        },
        {
            "key_id": 11,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_enum_type_to_new",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference"
            ],
            "code": "def cast_old_enum_type_to_new(connection: Connection, table_reference: TableReference, enum_type_name: str, enum_values_to_rename: List[Tuple[str, str]]):\n    for old_value, new_value in enum_values_to_rename:\n        connection.execute(text(f\"ALTER TABLE {table_reference.table_name_with_schema} ALTER COLUMN {table_reference.column_name} TYPE VARCHAR\"))\n        connection.execute(text(f\"UPDATE {table_reference.table_name_with_schema} SET {table_reference.column_name} = '{new_value}' WHERE {table_reference.column_name} = '{old_value}'\"))\n        connection.execute(text(f\"ALTER TABLE {table_reference.table_name_with_schema} ALTER COLUMN {table_reference.column_name} TYPE {enum_type_name} USING {table_reference.column_name}::text::{enum_type_name}\"))"
        },
        {
            "key_id": 39,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_alteration.py/sync_changed_enums",
            "imports": [
                "from alembic_postgresql_enum.sql_commands.enum_type import create_type",
                "from alembic_postgresql_enum.get_enum_data.declared_enums import get_enum_values, column_type_is_enum",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp"
            ],
            "code": "def sync_changed_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, table_references: EnumNamesToTableReferences, schema: str, upgrade_ops: UpgradeOps):\n    for enum_name, declared_values in declared_enums.items():\n        if enum_name in defined_enums and declared_values != defined_enums[enum_name]:\n            new_values = list(set(declared_values) - set(defined_enums[enum_name]))\n            if new_values:\n                upgrade_ops.ops.append(SyncEnumValuesOp(schema=schema, name=enum_name, old_values=defined_enums[enum_name], new_values=declared_values, affected_columns=table_references[enum_name]))"
        },
        {
            "key_id": 40,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_deletion.py/drop_unused_enums",
            "imports": [
                "from alembic_postgresql_enum.sql_commands.enum_type import drop_type",
                "from alembic_postgresql_enum.get_enum_data.defined_enums import get_defined_enums",
                "from alembic_postgresql_enum.get_enum_data.declared_enums import get_enum_values"
            ],
            "code": "def drop_unused_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, schema: str, upgrade_ops: UpgradeOps):\n    unused_enums = set(defined_enums.keys()) - set(declared_enums.keys())\n    for unused_enum in unused_enums:\n        drop_type(connection=upgrade_ops.connection, schema=schema, type_name=unused_enum)"
        },
        {
            "key_id": 10,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_array_enum_type_to_new",
            "imports": [
                "from sqlalchemy import text",
                "from typing import List, Tuple"
            ],
            "code": "def cast_old_array_enum_type_to_new(connection, table_reference, enum_type_name, enum_values_to_rename: List[Tuple[str, str]]):\n    for old_value, new_value in enum_values_to_rename:\n        connection.execute(text(f\"UPDATE {table_reference.table_name_with_schema()} SET {table_reference.column_name} = array_replace({table_reference.column_name}, '{old_value}', '{new_value}') WHERE {table_reference.column_name} @> ARRAY['{old_value}']::text[];\"))"
        },
        {
            "key_id": 13,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/rename_type",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def rename_type(connection, schema, type_name, new_type_name):\n    connection.execute(text(f\"ALTER TYPE {schema}.{type_name} RENAME TO {new_type_name};\"))"
        },
        {
            "key_id": 15,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/get_all_enums",
            "imports": [
                "from sqlalchemy import text",
                "from collections import defaultdict"
            ],
            "code": "def get_all_enums(connection, schema):\n    result = connection.execute(text(f\"SELECT typname FROM pg_type WHERE typtype = 'e' AND typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = '{schema}');\"))\n    enums = defaultdict(list)\n    for row in result:\n        enums[schema].append(row[0])\n    return enums"
        },
        {
            "key_id": 16,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/get_column_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def get_column_default(connection, table_schema, table_name, column_name):\n    result = connection.execute(text(f\"SELECT column_default FROM information_schema.columns WHERE table_schema = '{table_schema}' AND table_name = '{table_name}' AND column_name = '{column_name}';\"))\n    for row in result:\n        return row[0]\n    return None"
        },
        {
            "key_id": 17,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/drop_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def drop_default(connection, table_name_with_schema, column_name):\n    connection.execute(text(f\"ALTER TABLE {table_name_with_schema} ALTER COLUMN {column_name} DROP DEFAULT;\"))"
        },
        {
            "key_id": 18,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/set_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def set_default(connection, table_name_with_schema, column_name, default_value):\n    sql = text(f\"ALTER TABLE {table_name_with_schema} ALTER COLUMN {column_name} SET DEFAULT :default_value\")\n    connection.execute(sql, default_value=default_value)"
        },
        {
            "key_id": 19,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/rename_default_if_required",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def rename_default_if_required(schema, default_value, enum_name, enum_values_to_rename: List[Tuple[str, str]]) -> str:\n    for old_value, new_value in enum_values_to_rename:\n        if old_value in default_value:\n            default_value = default_value.replace(old_value, new_value)\n    return default_value"
        },
        {
            "key_id": 20,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/_replace_strings_in_quotes",
            "imports": [
                "import re"
            ],
            "code": "def _replace_strings_in_quotes(old_default: str, enum_values_to_rename: List[Tuple[str, str]]) -> str:\n    def replace_match(match):\n        value = match.group(0)\n        for old_value, new_value in enum_values_to_rename:\n            if old_value in value:\n                return value.replace(old_value, new_value)\n        return value\n    return re.sub(r\"'[^']*'\", replace_match, old_default)"
        },
        {
            "key_id": 21,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_create_comparison_operator",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def _create_comparison_operator(connection, schema, enum_name, old_enum_name, enum_values_to_rename, operator, comparison_function_name):\n    sql = text(f\"CREATE OR REPLACE FUNCTION {schema}.{comparison_function_name}(a {enum_name}, b {enum_name}) RETURNS BOOLEAN AS $$ BEGIN RETURN a {operator} b; END; $$ LANGUAGE plpgsql IMMUTABLE;\")\n    connection.execute(sql)"
        },
        {
            "key_id": 22,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/create_comparison_operators",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def create_comparison_operators(connection, schema, enum_name, old_enum_name, enum_values_to_rename):\n    for operator, function_name in OPERATORS_TO_CREATE:\n        _create_comparison_operator(connection, schema, enum_name, old_enum_name, enum_values_to_rename, operator, function_name)"
        },
        {
            "key_id": 23,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_drop_comparison_operator",
            "imports": [
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def _drop_comparison_operator(connection: Connection, schema: str, enum_name: str, old_enum_name: str, comparison_function_name: str):\n    query = f\"\"\"DO $$\n    BEGIN\n        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = '{comparison_function_name}') THEN\n            EXECUTE 'DROP FUNCTION IF EXISTS {schema}.{comparison_function_name}(ANYELEMENT, ANYELEMENT) CASCADE;';\n        END IF;\n    END\n    $$;\"\"\"\n    connection.execute(query)"
        },
        {
            "key_id": 24,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/drop_comparison_operators",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from alembic_postgresql_enum.sql_commands.comparison_operators import _drop_comparison_operator"
            ],
            "code": "def drop_comparison_operators(connection: Connection, schema: str, enum_name: str, old_enum_name: str):\n    for operator, function_name in OPERATORS_TO_CREATE:\n        _drop_comparison_operator(connection, schema, enum_name, old_enum_name, function_name)"
        },
        {
            "key_id": 25,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/ColumnType/__repr__",
            "imports": [],
            "code": "class ColumnType:\n    COMMON = Enum('COMMON', 'ARRAY')\n    ARRAY = ARRAY\n\n    def __repr__(self):\n        return f'<ColumnType {self.name}>'"
        },
        {
            "key_id": 26,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/__repr__",
            "imports": [],
            "code": "class TableReference:\n    def __init__(self, table_name: str, schema: str = None):\n        self.table_name = table_name\n        self.schema = schema\n\n    def __repr__(self):\n        return f'<TableReference {self.schema}.{self.table_name}>'"
        },
        {
            "key_id": 27,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/is_column_type_import_needed",
            "imports": [
                "from alembic_postgresql_enum.get_enum_data.types import ColumnType"
            ],
            "code": "class TableReference:\n    def is_column_type_import_needed(self):\n        return any(isinstance(column_type, ColumnType.ARRAY) for column_type in self.column_types)"
        },
        {
            "key_id": 30,
            "fqn": "alembic_postgresql_enum/get_enum_data/defined_enums.py/get_defined_enums",
            "imports": [
                "from typing import Dict, Tuple",
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def get_defined_enums(connection: Connection, schema: str) -> Dict[str, Tuple[str, ...]]:\n    query = '''\n    SELECT t.typname AS enumtype, e.enumlabel AS enumlabel\n    FROM pg_type t\n    JOIN pg_enum e ON t.oid = e.enumtypid\n    JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n    WHERE n.nspname = %s\n    ORDER BY t.typname ASC, e.enumsortorder ASC;\n    '''\n    result = connection.execute(query, (schema,)).fetchall()\n    enums = {}\n    for row in result:\n        if row['enumtype'] in enums:\n            enums[row['enumtype']] += (row['enumlabel'],)\n        else:\n            enums[row['enumtype']] = (row['enumlabel'],)\n    return enums"
        },
        {
            "key_id": 29,
            "fqn": "alembic_postgresql_enum/get_enum_data/defined_enums.py/_remove_schema_prefix",
            "imports": [],
            "code": "def _remove_schema_prefix(enum_name: str, schema: str) -> str:\n    if enum_name.startswith(f'{schema}.'):\n        return enum_name[len(schema)+1:]\n    return enum_name"
        },
        {
            "key_id": 31,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_enum_values",
            "imports": [
                "from sqlalchemy import Enum",
                "from typing import Tuple"
            ],
            "code": "def get_enum_values(enum_type: Enum) -> Tuple[str, ...]:\n    return enum_type.enums"
        },
        {
            "key_id": 32,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/column_type_is_enum",
            "imports": [
                "from sqlalchemy import Enum",
                "from typing import Any"
            ],
            "code": "def column_type_is_enum(column_type: Any) -> bool:\n    return isinstance(column_type, Enum)"
        },
        {
            "key_id": 28,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/table_name_with_schema",
            "imports": [],
            "code": "def table_name_with_schema(self) -> str:\n    return f'{self.schema}.{self.table_name}' if self.schema else self.table_name"
        },
        {
            "key_id": 33,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_declared_enums",
            "imports": [
                "from sqlalchemy import MetaData",
                "from typing import Union, List, Optional",
                "from sqlalchemy.engine import Connection",
                "from alembic.operations import Ops",
                "from alembic_postgresql_enum.get_enum_data.types import DeclaredEnumValues"
            ],
            "code": "def get_declared_enums(metadata: Union[MetaData, List[MetaData]], schema: str, default_schema: str, connection: \"Connection\", upgrade_ops: Optional[Ops] = None) -> DeclaredEnumValues:\n    declared_enums = {}\n    for meta in metadata if isinstance(metadata, list) else [metadata]:\n        for table in meta.tables.values():\n            if table.schema == schema or (schema is None and table.schema == default_schema):\n                for column in table.columns:\n                    if column.type_is_enum(column.type):\n                        enum_values = get_enum_values(column.type)\n                        declared_enums[(table.schema, table.name, column.name)] = enum_values\n    return declared_enums"
        },
        {
            "key_id": 34,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_add_column_op",
            "imports": [
                "from alembic.operations import AddColumnOp",
                "from typing import Tuple, Optional",
                "from alembic_postgresql_enum.get_enum_data.types import ColumnLocation"
            ],
            "code": "def _get_default_from_add_column_op(op: AddColumnOp, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:\n    column = op.column\n    schema = op.schema if op.schema is not None else default_schema\n    return (schema, op.table_name, column.name), column.server_default"
        },
        {
            "key_id": 35,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_alter_column_op",
            "imports": [
                "from alembic.operations import AlterColumnOp",
                "from typing import Tuple, Optional",
                "from alembic_postgresql_enum.get_enum_data.types import ColumnLocation"
            ],
            "code": "def _get_default_from_alter_column_op(op: AlterColumnOp, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:\n    schema = op.schema if op.schema is not None else default_schema\n    return (schema, op.table_name, op.column_name), op.server_default"
        },
        {
            "key_id": 36,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_column",
            "imports": [
                "from sqlalchemy import Column",
                "from typing import Tuple, Optional",
                "from alembic_postgresql_enum.get_enum_data.types import ColumnLocation, SchemaName, TableName, ColumnName"
            ],
            "code": "def _get_default_from_column(column: Column, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:\n    schema = column.table.schema if column.table.schema is not None else default_schema\n    return (schema, column.table.name, column.name), column.server_default"
        },
        {
            "key_id": 37,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/get_just_added_defaults",
            "imports": [
                "from typing import Dict, Optional",
                "from alembic.operations import Ops",
                "from alembic_postgresql_enum.get_enum_data.types import ColumnLocation",
                "from alembic_postgresql_enum.get_enum_data.get_default_from_alembic_ops import _get_default_from_add_column_op, _get_default_from_alter_column_op, _get_default_from_column"
            ],
            "code": "def get_just_added_defaults(upgrade_ops: Optional[Ops], default_schema: str) -> Dict[ColumnLocation, Optional[str]]:\n    just_added_defaults = {}\n    if upgrade_ops:\n        for op in upgrade_ops.ops:\n            if isinstance(op, AddColumnOp):\n                location, default = _get_default_from_add_column_op(op, default_schema)\n                if default is not None:\n                    just_added_defaults[location] = default\n            elif isinstance(op, AlterColumnOp) and op.server_default is not None:\n                location, default = _get_default_from_alter_column_op(op, default_schema)\n                just_added_defaults[location] = default\n    return just_added_defaults"
        },
        {
            "key_id": 2,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/ReprWorkaround/__repr__",
            "imports": [
                "from sqlalchemy.dialects.postgresql import ENUM"
            ],
            "code": "class ReprWorkaround:\n    __module__ = 'sqlalchemy.dialects.postgresql'\n\n    def __repr__(self):\n        return f'<ReprWorkaround for {self.__class__.__name__}>'"
        },
        {
            "key_id": 3,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/get_replacement_type",
            "imports": [
                "from sqlalchemy.dialects.postgresql import ENUM",
                "from sqlalchemy import Column"
            ],
            "code": "def get_replacement_type(column_type):\n    if isinstance(column_type, ENUM):\n        return ReprWorkaround()\n    return column_type"
        },
        {
            "key_id": 4,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/inject_repr_into_enums",
            "imports": [
                "from sqlalchemy import Column"
            ],
            "code": "def inject_repr_into_enums(column: Column):\n    column.type = get_replacement_type(column.type)"
        },
        {
            "key_id": 5,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/add_create_type_false",
            "imports": [
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.add_create_type_false import inject_repr_into_enums"
            ],
            "code": "def add_create_type_false(upgrade_ops: ops.UpgradeOps):\n    for op in upgrade_ops.ops:\n        if isinstance(op, ops.CreateTableOp):\n            for column in op.columns:\n                inject_repr_into_enums(column)\n        elif isinstance(op, ops.AddColumnOp):\n            inject_repr_into_enums(op.column)"
        },
        {
            "key_id": 6,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/PostgresUsingAlterColumnOp/reverse",
            "imports": [
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.add_postgres_using_to_text import _postgres_using_alter_column",
                "from alembic_postgresql_enum.add_postgres_using_to_text import add_postgres_using_to_alter_operation",
                "from alembic_postgresql_enum.add_postgres_using_to_text import add_postgres_using_to_text"
            ],
            "code": "class PostgresUsingAlterColumnOp:\n    def reverse(self):\n        return self\n\n    @staticmethod\n    def _postgres_using_alter_column(autogen_context, op):\n        return _postgres_using_alter_column(autogen_context, op)\n\n    @staticmethod\n    def add_postgres_using_to_alter_operation(op):\n        return add_postgres_using_to_alter_operation(op)\n\n    @staticmethod\n    def add_postgres_using_to_text(upgrade_ops):\n        return add_postgres_using_to_text(upgrade_ops)"
        },
        {
            "key_id": 7,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/_postgres_using_alter_column",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.autogenerate import AutogenContext"
            ],
            "code": "def _postgres_using_alter_column(autogen_context: AutogenContext, op: ops.AlterColumnOp) -> str:\n    if op.modify_type is not None:\n        return f'USING {op.column_name}::text::{op.modify_type}'\n    return ''"
        },
        {
            "key_id": 8,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_alter_operation",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.autogenerate import AutogenContext"
            ],
            "code": "def add_postgres_using_to_alter_operation(op: ops.AlterColumnOp):\n    if isinstance(op, ops.AlterColumnOp) and op.modify_type is not None:\n        using_clause = _postgres_using_alter_column(AutogenContext(), op)\n        op.modify_type = None\n        return using_clause\n    return None"
        },
        {
            "key_id": 9,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_text",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.operations import UpgradeOps",
                "from alembic.autogenerate import AutogenContext"
            ],
            "code": "def add_postgres_using_to_text(upgrade_ops: UpgradeOps):\n    for op in upgrade_ops.ops:\n        if isinstance(op, ops.AlterColumnOp) and op.modify_type is not None:\n            using_clause = add_postgres_using_to_alter_operation(op)\n            if using_clause:\n                op.info['using'] = using_clause"
        }
    ]
}