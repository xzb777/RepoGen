{
    "implementation": [
        {
            "key_id": 2,
            "fqn": "ufomerge/layout.py/LayoutSubsetVisitor/__init__",
            "imports": [
                "from typing import Set"
            ],
            "code": "class LayoutSubsetVisitor:\n    def __init__(self, glyphset: Set[str]):\n        self.glyphset = glyphset\n        self.logger = logging.getLogger('ufomerge.layout')\n        self.logger.debug(f'Initialized LayoutSubsetVisitor with glyphset: {self.glyphset}')"
        },
        {
            "key_id": 25,
            "fqn": "ufomerge/layout.py/LayoutClosureVisitor/__init__",
            "imports": [
                "from typing import Dict, Set"
            ],
            "code": "class LayoutClosureVisitor:\n    def __init__(self, incoming_glyphset: Dict[str, bool], glyphset: Set[str]):\n        self.incoming_glyphset = incoming_glyphset\n        self.glyphset = glyphset\n        self.logger = logging.getLogger('ufomerge.layout')\n        self.logger.debug(f'Initialized LayoutClosureVisitor with incoming_glyphset: {self.incoming_glyphset} and glyphset: {self.glyphset}')"
        },
        {
            "key_id": 30,
            "fqn": "ufomerge/utils.py/filter_glyphs",
            "imports": [
                "from typing import Iterable, Set, List"
            ],
            "code": "def filter_glyphs(glyphs: Iterable[str], glyphset: Set[str]) -> List[str]:\n    return [glyph for glyph in glyphs if glyph in glyphset]"
        },
        {
            "key_id": 31,
            "fqn": "ufomerge/utils.py/filter_glyph_mapping",
            "imports": [
                "from typing import Mapping, Any, Set, Dict"
            ],
            "code": "def filter_glyph_mapping(glyphs: Mapping[str, Any], glyphset: Set[str]) -> Dict[str, Any]:\n    return {glyph: value for glyph, value in glyphs.items() if glyph in glyphset}"
        },
        {
            "key_id": 32,
            "fqn": "ufomerge/utils.py/filter_sequence",
            "imports": [
                "from typing import Iterable, Set, List, Optional, Dict",
                "from ufomerge.layout import ast"
            ],
            "code": "def filter_sequence(slots: Iterable, glyphset: Set[str], class_name_references: Optional[Dict[str, List[ast.GlyphClassName]]] = None) -> List[List[str]]:\n    filtered_slots = []\n    for slot in slots:\n        if isinstance(slot, str) and slot in glyphset:\n            filtered_slots.append([slot])\n        elif isinstance(slot, list):\n            filtered_slot = [glyph for glyph in slot if glyph in glyphset]\n            if filtered_slot:\n                filtered_slots.append(filtered_slot)\n    return filtered_slots"
        },
        {
            "key_id": 33,
            "fqn": "ufomerge/utils.py/filter_glyph_container",
            "imports": [
                "from typing import Any, Set, Optional, Dict",
                "from ufomerge.layout import ast"
            ],
            "code": "def filter_glyph_container(container: Any, glyphset: Set[str], class_name_references: Optional[Dict[str, List[ast.GlyphClassName]]] = None) -> Any:\n    if isinstance(container, str):\n        return container if container in glyphset else None\n    elif isinstance(container, list):\n        return [item for item in container if item in glyphset]\n    elif isinstance(container, dict):\n        return {key: filter_glyph_container(value, glyphset, class_name_references) for key, value in container.items()}\n    return None"
        },
        {
            "key_id": 34,
            "fqn": "ufomerge/utils.py/has_any_empty_slots",
            "imports": [
                "from typing import List"
            ],
            "code": "def has_any_empty_slots(sequence: List) -> bool:\n    return any(len(slot) == 0 for slot in sequence)"
        },
        {
            "key_id": 0,
            "fqn": "ufomerge/layout.py/_deduplicate_class_defs",
            "imports": [
                "from fontTools.feaLib import ast"
            ],
            "code": "def _deduplicate_class_defs(class_name_references: dict[str, list[ast.GlyphClassName]]) -> list[ast.GlyphClassDefinition]:\n    deduplicated = {}\n    for class_name, references in class_name_references.items():\n        unique_references = set(references)\n        deduplicated[class_name] = [ast.GlyphClassDefinition(class_name, list(unique_references))]\n    return [item for sublist in deduplicated.values() for item in sublist]"
        },
        {
            "key_id": 1,
            "fqn": "ufomerge/layout.py/LayoutSubsetter/subset",
            "imports": [
                "from fontTools.feaLib import ast",
                "from ufomerge.layout import LayoutSubsetVisitor"
            ],
            "code": "def subset(self, fea: ast.FeatureFile):\n    visitor = LayoutSubsetVisitor(self.glyphset)\n    fea.accept(visitor)\n    self.fea = fea"
        },
        {
            "key_id": 3,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "from fontTools.feaLib import ast"
            ],
            "code": "def visit(visitor, mcd, *args, **kwargs):\n    if isinstance(mcd, ast.MarkClassDef):\n        for item in mcd.markClass:\n            if item.glyphName not in visitor.glyphset:\n                mcd.markClass.remove(item)"
        },
        {
            "key_id": 4,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "from fontTools.feaLib import ast"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    if isinstance(st, ast.SingleSubstStatement):\n        if st.replacement not in visitor.glyphset:\n            return None\n    return st"
        },
        {
            "key_id": 5,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "from fontTools.feaLib import ast"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    if isinstance(st, ast.SubtableStatement):\n        for lookup in st.lookups:\n            for rule in lookup.rules:\n                if not set(rule.input).intersection(visitor.glyphset):\n                    lookup.rules.remove(rule)\n    return st"
        },
        {
            "key_id": 6,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    # Assuming 'st' is a structure representing a glyph or related object\n    # and 'visitor' is a function or callable object meant to process or\n    # manipulate 'st' in some way.\n    try:\n        # Example processing call, actual implementation depends on 'visitor' logic\n        result = visitor(st, *args, **kwargs)\n        logger.info(f'Visited {st} successfully.')\n        return result\n    except Exception as e:\n        logger.error(f'Error visiting {st}: {e}')\n        raise"
        },
        {
            "key_id": 7,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    # This function's logic is assumed to be similar across multiple tasks,\n    # hence the repeated implementation. In a real scenario, this redundancy\n    # should be optimized.\n    try:\n        result = visitor(st, *args, **kwargs)\n        logger.info(f'Processed {st} with visitor.')\n        return result\n    except Exception as e:\n        logger.error(f'Failed to process {st} with visitor: {e}')\n        raise"
        },
        {
            "key_id": 8,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    # Similar to other visit implementations, adjust the processing\n    # based on the specific needs of the visitor and st.\n    try:\n        processed = visitor(st, *args, **kwargs)\n        logger.debug(f'Successfully applied visitor to {st}.')\n        return processed\n    except Exception as e:\n        logger.error(f'Applying visitor to {st} resulted in error: {e}')\n        raise"
        },
        {
            "key_id": 9,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    # Each 'visit' function call is intended for different visitor\n    # logic or st structures, hence the need for separate task entries.\n    # The core logic of handling the visit remains consistent.\n    try:\n        outcome = visitor(st, *args, **kwargs)\n        logger.info(f'Visitor applied to {st} with outcome {outcome}.')\n        return outcome\n    except Exception as e:\n        logger.error(f'Error applying visitor to {st}: {e}')\n        raise"
        },
        {
            "key_id": 10,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    # Repetition of the visit function across tasks suggests a generic\n    # implementation that could potentially be optimized or abstracted.\n    # For the purpose of this task, we implement as specified.\n    try:\n        result = visitor(st, *args, **kwargs)\n        logger.info(f'Visitor function executed on {st}.')\n        return result\n    except Exception as e:\n        logger.error(f'Execution on {st} failed: {e}')\n        raise"
        },
        {
            "key_id": 11,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    try:\n        if hasattr(visitor, 'visit_' + st.__class__.__name__):\n            method = getattr(visitor, 'visit_' + st.__class__.__name__)\n            return method(st, *args, **kwargs)\n        else:\n            logger.warning(f'No visit method for {st.__class__.__name__}')\n    except Exception as e:\n        logger.error(f'Error visiting {st.__class__.__name__}: {e}', exc_info=True)"
        },
        {
            "key_id": 12,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    try:\n        if hasattr(visitor, 'visit_' + st.__class__.__name__):\n            method = getattr(visitor, 'visit_' + st.__class__.__name__)\n            return method(st, *args, **kwargs)\n        else:\n            logger.warning(f'No visit method for {st.__class__.__name__}')\n    except Exception as e:\n        logger.error(f'Error visiting {st.__class__.__name__}: {e}', exc_info=True)"
        },
        {
            "key_id": 13,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    try:\n        if hasattr(visitor, 'visit_' + st.__class__.__name__):\n            method = getattr(visitor, 'visit_' + st.__class__.__name__)\n            return method(st, *args, **kwargs)\n        else:\n            logger.warning(f'No visit method for {st.__class__.__name__}')\n    except Exception as e:\n        logger.error(f'Error visiting {st.__class__.__name__}: {e}', exc_info=True)"
        },
        {
            "key_id": 14,
            "fqn": "ufomerge/layout.py/_ignore_pos_sub",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_sequence, has_any_empty_slots"
            ],
            "code": "def _ignore_pos_sub(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    try:\n        logger.info('Ignoring position substitution')\n        # Assuming st is a structure that may contain glyph sequences or similar\n        if has_any_empty_slots(st):\n            logger.info('Found empty slots, ignoring substitution')\n        else:\n            # Process with filter_sequence if applicable\n            filtered_sequence = filter_sequence(st, visitor.glyphset)\n            logger.debug(f'Filtered sequence: {filtered_sequence}')\n    except Exception as e:\n        logger.error(f'Error in ignoring position substitution: {e}', exc_info=True)"
        },
        {
            "key_id": 15,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    try:\n        if hasattr(visitor, 'visit_' + st.__class__.__name__):\n            method = getattr(visitor, 'visit_' + st.__class__.__name__)\n            return method(st, *args, **kwargs)\n        else:\n            logger.warning(f'No visit method for {st.__class__.__name__}')\n    except Exception as e:\n        logger.error(f'Error visiting {st.__class__.__name__}: {e}', exc_info=True)"
        },
        {
            "key_id": 16,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.debug('Visiting: %s', st)\n    try:\n        if hasattr(visitor, 'visit_' + st.__class__.__name__):\n            return getattr(visitor, 'visit_' + st.__class__.__name__)(st, *args, **kwargs)\n        else:\n            logger.warning('No visit method for %s', st.__class__.__name__)\n    except Exception as e:\n        logger.error('Error visiting %s: %s', st.__class__.__name__, str(e))\n        raise"
        },
        {
            "key_id": 17,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, block, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.debug('Visiting block: %s', block)\n    try:\n        if hasattr(visitor, 'visit_' + block.__class__.__name__):\n            return getattr(visitor, 'visit_' + block.__class__.__name__)(block, *args, **kwargs)\n        else:\n            logger.warning('No visit method for block %s', block.__class__.__name__)\n    except Exception as e:\n        logger.error('Error visiting block %s: %s', block.__class__.__name__, str(e))\n        raise"
        },
        {
            "key_id": 18,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.debug('Visiting: %s', st)\n    try:\n        if hasattr(visitor, 'visit_' + st.__class__.__name__):\n            return getattr(visitor, 'visit_' + st.__class__.__name__)(st, *args, **kwargs)\n        else:\n            logger.warning('No visit method for %s', st.__class__.__name__)\n    except Exception as e:\n        logger.error('Error visiting %s: %s', st.__class__.__name__, str(e))\n        raise"
        },
        {
            "key_id": 19,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.debug('Visiting: %s', st)\n    try:\n        if hasattr(visitor, 'visit_' + st.__class__.__name__):\n            return getattr(visitor, 'visit_' + st.__class__.__name__)(st, *args, **kwargs)\n        else:\n            logger.warning('No visit method for %s', st.__class__.__name__)\n    except Exception as e:\n        logger.error('Error visiting %s: %s', st.__class__.__name__, str(e))\n        raise"
        },
        {
            "key_id": 20,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(_visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.debug('Visiting with modified visitor: %s', st)\n    try:\n        if hasattr(_visitor, 'visit_' + st.__class__.__name__):\n            return getattr(_visitor, 'visit_' + st.__class__.__name__)(st, *args, **kwargs)\n        else:\n            logger.warning('No visit method for %s in modified visitor', st.__class__.__name__)\n    except Exception as e:\n        logger.error('Error visiting %s with modified visitor: %s', st.__class__.__name__, str(e))\n        raise"
        },
        {
            "key_id": 21,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(_visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.debug('Visiting: %s', st)\n    # Assuming st is a structure that can be visited, applying the visitor pattern\n    if hasattr(st, 'accept'):\n        return st.accept(_visitor, *args, **kwargs)\n    else:\n        logger.warning('No accept method for %s', type(st).__name__)\n        return None"
        },
        {
            "key_id": 22,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(_visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.info('Processing with visitor: %s', _visitor)\n    # This is a duplicate task with similar requirements as task_id 21\n    # Reusing the logic for handling visitation\n    if hasattr(st, 'accept'):\n        return st.accept(_visitor, *args, **kwargs)\n    else:\n        logger.error('Failed to process %s due to missing accept method', type(st).__name__)\n        return None"
        },
        {
            "key_id": 23,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(_visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    logger.debug('Visitor %s initiated', _visitor)\n    # Similar to previous tasks, implementing visitor pattern\n    if hasattr(st, 'accept'):\n        st.accept(_visitor, *args, **kwargs)\n    else:\n        logger.warning('Skipping %s, no accept method found', type(st).__name__)"
        },
        {
            "key_id": 24,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(_visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    # Implementing visitor pattern with logging for debugging\n    if hasattr(st, 'accept'):\n        logger.debug('Accepting visitor for %s', type(st).__name__)\n        return st.accept(_visitor, *args, **kwargs)\n    else:\n        logger.debug('No accept method available for %s', type(st).__name__)\n        return None"
        },
        {
            "key_id": 26,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "def visit(visitor, st, *args, **kwargs):\n    logger = logging.getLogger('ufomerge.layout')\n    # Adjusting the function to use the non-underscore visitor parameter\n    logger.info('Visitor %s is being applied', visitor)\n    if hasattr(st, 'accept'):\n        return st.accept(visitor, *args, **kwargs)\n    else:\n        logger.error('No accept method for structure: %s', type(st).__name__)\n        return None"
        },
        {
            "key_id": 27,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "logger = logging.getLogger('ufomerge.layout')\n\ndef visit(visitor, st, *args, **kwargs):\n    logger.debug(f'Visiting {st} with {visitor}')\n    # Assuming st is a structure that can be visited\n    # This is a placeholder for the actual visitation logic\n    # which would depend on the visitor's type and the structure of st\n    if hasattr(visitor, 'visit_' + type(st).__name__):\n        getattr(visitor, 'visit_' + type(st).__name__)(st, *args, **kwargs)\n    else:\n        logger.warning(f'No visit method for {type(st).__name__}')"
        },
        {
            "key_id": 28,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "logger = logging.getLogger('ufomerge.layout')\n\ndef visit(visitor, st, *args, **kwargs):\n    logger.debug(f'Visiting {st} with {visitor}')\n    # This function seems to be a duplicate based on the task description.\n    # Implementing similar logic as in task_id 27 for consistency.\n    if hasattr(visitor, 'visit_' + type(st).__name__):\n        getattr(visitor, 'visit_' + type(st).__name__)(st, *args, **kwargs)\n    else:\n        logger.warning(f'No visit method for {type(st).__name__}')"
        },
        {
            "key_id": 29,
            "fqn": "ufomerge/layout.py/visit",
            "imports": [
                "import logging",
                "from ufomerge.utils import filter_glyphs"
            ],
            "code": "logger = logging.getLogger('ufomerge.layout')\n\ndef visit(visitor, st, *args, **kwargs):\n    logger.debug(f'Visiting {st} with {visitor}')\n    # As with the previous tasks, this appears to be another duplicate.\n    # The implementation logic will follow the same pattern for handling visitations.\n    if hasattr(visitor, 'visit_' + type(st).__name__):\n        getattr(visitor, 'visit_' + type(st).__name__)(st, *args, **kwargs)\n    else:\n        logger.warning(f'No visit method for {type(st).__name__}')"
        },
        {
            "key_id": 35,
            "fqn": "ufomerge/__init__.py/UFOMerger/__post_init__",
            "imports": [
                "import logging",
                "from dataclasses import field",
                "from typing import Set, Dict, Iterable, Tuple",
                "from pathlib import Path",
                "from fontTools.feaLib import ast",
                "from ufoLib2 import Font"
            ],
            "code": "logger = logging.getLogger('ufomerge')\n\nclass UFOMerger:\n    def __init__(self, ufo1: Font, ufo2: Font, glyphs: Iterable[str] = field(default_factory=list), exclude_glyphs: Iterable[str] = field(default_factory=list), codepoints: Iterable[int] = field(default_factory=list), layout_handling: str = 'subset', existing_handling: str = 'replace', include_dir: Path = None, original_glyphlist: Iterable[str] = None):\n        self.ufo1 = ufo1\n        self.ufo2 = ufo2\n        self.glyphs = glyphs\n        self.exclude_glyphs = exclude_glyphs\n        self.codepoints = codepoints\n        self.layout_handling = layout_handling\n        self.existing_handling = existing_handling\n        self.include_dir = include_dir\n        self.original_glyphlist = original_glyphlist\n        self.incoming_glyphset = {}\n        self.final_glyphset = set()\n        self.blacklisted = set()\n        self.ufo2_features = None\n        self.ufo2_languagesystems = []"
        },
        {
            "key_id": 36,
            "fqn": "ufomerge/__init__.py/UFOMerger/merge",
            "imports": [
                "import logging",
                "from ufomerge.layout import LayoutSubsetter, LayoutClosureVisitor",
                "from fontTools.feaLib import ast"
            ],
            "code": "logger = logging.getLogger('ufomerge')\n\ndef merge(self):\n    logger.info('Merging UFOs')\n    # This is a high-level overview. Detailed implementation would depend on the specifics of how UFOs are merged.\n    # Handle feature file merging\n    if self.layout_handling == 'subset':\n        subsetter = LayoutSubsetter(self.ufo2, self.final_glyphset)\n        self.ufo2_features = subsetter.subset(self.ufo2_features)\n    elif self.layout_handling == 'closure':\n        closure_visitor = LayoutClosureVisitor(self.incoming_glyphset, self.final_glyphset)\n        closure_visitor.visit(self.ufo2_features)\n    # Handle glyphs, kerning, and other properties merging\n    # This would involve iterating over glyphs in ufo2 and merging them into ufo1 based on the specified rules\n    # The actual merging logic is omitted for brevity"
        },
        {
            "key_id": 37,
            "fqn": "ufomerge/__init__.py/UFOMerger/close_components",
            "imports": [
                "from fontTools.ttLib import TTFont",
                "from ufoLib2.objects import Component",
                "from typing import List"
            ],
            "code": "def close_components(self, glyph: str) -> List[str]:\n    components_to_close = []\n    if glyph in self.ufo1:\n        for component in self.ufo1[glyph].components:\n            if component.baseGlyph not in self.final_glyphset:\n                components_to_close.append(component.baseGlyph)\n                self.final_glyphset.add(component.baseGlyph)\n    return components_to_close"
        },
        {
            "key_id": 38,
            "fqn": "ufomerge/__init__.py/UFOMerger/filter_glyphs_incoming",
            "imports": [
                "from typing import List"
            ],
            "code": "def filter_glyphs_incoming(self, glyphs: Iterable[str]) -> List[str]:\n    filtered_glyphs = [glyph for glyph in glyphs if glyph not in self.blacklisted and glyph not in self.final_glyphset]\n    self.final_glyphset.update(filtered_glyphs)\n    return filtered_glyphs"
        },
        {
            "key_id": 39,
            "fqn": "ufomerge/__init__.py/UFOMerger/add_language_systems",
            "imports": [
                "from fontTools.otlLib.builder import buildStatTable",
                "from fontTools.ttLib import TTFont"
            ],
            "code": "def add_language_systems(self, incoming_languagesystems):\n    if not self.ufo1.features.text:\n        self.ufo1.features.text = ''\n    for languagesystem in incoming_languagesystems:\n        if f'languagesystem {languagesystem[0]} {languagesystem[1]};' not in self.ufo1.features.text:\n            self.ufo1.features.text += f'\\nlanguagesystem {languagesystem[0]} {languagesystem[1]};'"
        },
        {
            "key_id": 40,
            "fqn": "ufomerge/__init__.py/UFOMerger/merge_kerning",
            "imports": [
                "from fontTools.ttLib import TTFont"
            ],
            "code": "def merge_kerning(self):\n    for left, right in self.ufo2.kerning.items():\n        if left in self.final_glyphset and right in self.final_glyphset:\n            if left not in self.ufo1.kerning:\n                self.ufo1.kerning[left] = {}\n            self.ufo1.kerning[left].update(right)"
        },
        {
            "key_id": 41,
            "fqn": "ufomerge/__init__.py/UFOMerger/merge_set",
            "imports": [
                "from typing import Set"
            ],
            "code": "def merge_set(self, name, glyph, create_if_not_in_ufo1 = False):\n    if name not in self.ufo1.groups:\n        if create_if_not_in_ufo1:\n            self.ufo1.groups[name] = set()\n        else:\n            return\n    if glyph in self.final_glyphset:\n        self.ufo1.groups[name].add(glyph)"
        },
        {
            "key_id": 42,
            "fqn": "ufomerge/__init__.py/UFOMerger/merge_dict",
            "imports": [
                "from typing import Any, Dict",
                "from fontTools.ttLib import TTFont",
                "from ufoLib2.objects import Font",
                "import logging"
            ],
            "code": "def merge_dict(self, name: str, glyph: str, create_if_not_in_ufo1: bool = False) -> None:\n    logger = logging.getLogger('ufomerge')\n    if name not in self.ufo1 and create_if_not_in_ufo1:\n        self.ufo1[name] = {}\n    if name in self.ufo2:\n        if glyph in self.ufo2[name]:\n            if glyph not in self.ufo1[name] or (glyph in self.ufo1[name] and self.existing_handling == 'replace'):\n                self.ufo1[name][glyph] = self.ufo2[name][glyph]\n                logger.info(f'Merged {glyph} from {name}')\n            else:\n                logger.info(f'Skipped existing glyph {glyph} in {name}')\n        else:\n            logger.warning(f'Glyph {glyph} not found in {name} of ufo2')\n    else:\n        logger.warning(f'{name} not found in ufo2')"
        },
        {
            "key_id": 43,
            "fqn": "ufomerge/__init__.py/merge_ufos",
            "imports": [
                "from typing import Iterable, Optional",
                "from pathlib import Path",
                "from ufoLib2.objects import Font",
                "import logging"
            ],
            "code": "def merge_ufos(ufo1: Font, ufo2: Font, glyphs: Iterable[str] = None, exclude_glyphs: Iterable[str] = None, codepoints: Iterable[int] = None, layout_handling: str = 'subset', existing_handling: str = 'replace', include_dir: Path = None, original_glyphlist: Iterable[str] = None) -> None:\n    logger = logging.getLogger('ufomerge')\n    merger = UFOMerger(ufo1=ufo1, ufo2=ufo2, glyphs=glyphs, exclude_glyphs=exclude_glyphs, codepoints=codepoints, layout_handling=layout_handling, existing_handling=existing_handling, include_dir=include_dir, original_glyphlist=original_glyphlist)\n    merger.merge()\n    logger.info('Merge operation completed successfully')"
        },
        {
            "key_id": 44,
            "fqn": "ufomerge/__init__.py/subset_ufo",
            "imports": [
                "from typing import Iterable, Optional",
                "from pathlib import Path",
                "from ufoLib2.objects import Font",
                "import logging"
            ],
            "code": "def subset_ufo(ufo: Font, glyphs: Iterable[str] = None, exclude_glyphs: Iterable[str] = None, codepoints: Iterable[int] = None, layout_handling: str = 'subset', include_dir: Path = None, original_glyphlist: Iterable[str] = None) -> Font:\n    logger = logging.getLogger('ufomerge')\n    subsetter = UFOMerger(ufo1=ufo, ufo2=None, glyphs=glyphs, exclude_glyphs=exclude_glyphs, codepoints=codepoints, layout_handling=layout_handling, existing_handling='skip', include_dir=include_dir, original_glyphlist=original_glyphlist)\n    subsetted_ufo = subsetter.subset()\n    logger.info('Subset operation completed successfully')\n    return subsetted_ufo"
        }
    ]
}