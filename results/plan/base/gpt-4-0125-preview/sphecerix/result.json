{
    "implementation": [
        {
            "key_id": 19,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/__init__",
            "imports": [],
            "code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.mol = mol\n        self.operations = []"
        },
        {
            "key_id": 22,
            "fqn": "sphecerix/symmetry_operations.py/Operation/__init__",
            "imports": [],
            "code": "class Operation:\n    def __init__(self, name):\n        self.name = name\n        self.matrix = None\n        self.wigner_matrix = None"
        },
        {
            "key_id": 24,
            "fqn": "sphecerix/symmetry_operations.py/Identity/__init__",
            "imports": [],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n        self.wigner_matrix = lambda l: np.eye(2*l + 1)"
        },
        {
            "key_id": 27,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = -np.eye(3)\n        self.wigner_matrix = lambda l: np.diag((-1)**np.arange(-l, l+1))"
        },
        {
            "key_id": 30,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/__init__",
            "imports": [
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ],
            "code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        rot_obj = R.from_rotvec(axis * angle)\n        self.matrix = rot_obj.as_matrix()\n        self.wigner_matrix = lambda l: tesseral_wigner_D(l, rot_obj)"
        },
        {
            "key_id": 33,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/__init__",
            "imports": [],
            "code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = normal\n        self.type = 'Mirror'\n        self.matrix = None\n\n    def get_matrix(self):\n        if self.matrix is None:\n            n = self.normal\n            self.matrix = np.array([[1 - 2*n[0]**2, -2*n[0]*n[1], -2*n[0]*n[2]],\n                                    [-2*n[0]*n[1], 1 - 2*n[1]**2, -2*n[1]*n[2]],\n                                    [-2*n[0]*n[2], -2*n[1]*n[2], 1 - 2*n[2]**2]])\n        return self.matrix"
        },
        {
            "key_id": 36,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class ImproperRotation:\n    def __init__(self, label, axis, angle):\n        self.label = label\n        self.axis = axis\n        self.angle = angle\n        self.type = 'ImproperRotation'\n        self.matrix = None\n\n    def get_matrix(self):\n        if self.matrix is None:\n            axis_normalized = self.axis / np.linalg.norm(self.axis)\n            c, s = np.cos(self.angle), np.sin(self.angle)\n            x, y, z = axis_normalized\n            self.matrix = np.array([[c + (1-c)*x*x, (1-c)*x*y - s*z, (1-c)*x*z + s*y],\n                                    [(1-c)*y*x + s*z, c + (1-c)*y*y, (1-c)*y*z - s*x],\n                                    [(1-c)*z*x - s*y, (1-c)*z*y + s*x, c + (1-c)*z*z]])\n        return self.matrix"
        },
        {
            "key_id": 3,
            "fqn": "sphecerix/molecule.py/Molecule/__init__",
            "imports": [],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        self.atoms.append({'atom': atom, 'x': x, 'y': y, 'z': z, 'unit': unit})\n\n    def build_basis(self, molset):\n        # Implementation for building basis functions based on molecule set\n        pass"
        },
        {
            "key_id": 40,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.name = self.__get_name()\n\n    def __get_name(self):\n        # Assuming a function to generate the name based on n, l, m\n        return f'Function_{self.n}_{self.l}_{self.m}'"
        },
        {
            "key_id": 7,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield",
            "imports": [
                "import numpy as np",
                "from sphecerix.atomic_wave_functions import wfcart"
            ],
            "code": "def wffield(n, l, m, d, npts):\n    x, y, z = np.mgrid[-d:d:npts*1j, -d:d:npts*1j, -d:d:npts*1j]\n    return wfcart(n, l, m, x, y, z)"
        },
        {
            "key_id": 8,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield_l",
            "imports": [
                "import numpy as np",
                "from sphecerix.atomic_wave_functions import wffield"
            ],
            "code": "def wffield_l(n, l, d, npts):\n    fields = []\n    for m in range(-l, l+1):\n        field = wffield(n, l, m, d, npts)\n        fields.append(field)\n    return np.array(fields)"
        },
        {
            "key_id": 9,
            "fqn": "sphecerix/atomic_wave_functions.py/wfcart",
            "imports": [
                "import numpy as np",
                "from sphecerix.atomic_wave_functions import wf"
            ],
            "code": "def wfcart(n, l, m, x, y, z):\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(np.sqrt(x**2 + y**2), z)\n    phi = np.arctan2(y, x)\n    return wf(n, l, m, r, theta, phi)"
        },
        {
            "key_id": 10,
            "fqn": "sphecerix/atomic_wave_functions.py/wf",
            "imports": [
                "import numpy as np",
                "from sphecerix.atomic_wave_functions import angular, radial"
            ],
            "code": "def wf(n, l, m, r, theta, phi):\n    R = radial(n, l, r)\n    Y = angular(l, m, theta, phi)\n    return R * Y"
        },
        {
            "key_id": 11,
            "fqn": "sphecerix/atomic_wave_functions.py/angular",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def angular(l, m, theta, phi):\n    return sph_harm(m, l, phi, theta)"
        },
        {
            "key_id": 12,
            "fqn": "sphecerix/atomic_wave_functions.py/radial",
            "imports": [
                "import numpy as np"
            ],
            "code": "def radial(n, l, r):\n    # Placeholder for the actual implementation of the radial function\n    # This should compute the radial part of the wave function for given quantum numbers and radius.\n    # For simplicity, we are returning a numpy array filled with ones multiplied by the radius.\n    return np.ones_like(r) * r"
        },
        {
            "key_id": 18,
            "fqn": "sphecerix/wignerd.py/wigner_d_element_euler_angles",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wigner_d_element_euler_angles(l, m1, m2, beta):\n    # Placeholder for the actual implementation of the Wigner d-matrix element using Euler angles\n    # This function computes a single element of the Wigner d-matrix.\n    # For simplicity, we are returning a fixed value.\n    return np.exp(-1j * m1 * beta)"
        },
        {
            "key_id": 17,
            "fqn": "sphecerix/wignerd.py/wigner_d",
            "imports": [
                "import numpy as np"
            ],
            "code": "def wigner_d(l, beta):\n    # Placeholder for the actual implementation of the Wigner d function\n    # This function should compute the Wigner d-matrix for a given angle beta and angular momentum l.\n    # For simplicity, we are returning an identity matrix of size (2l+1, 2l+1).\n    return np.eye(2 * l + 1)"
        },
        {
            "key_id": 16,
            "fqn": "sphecerix/wignerd.py/wigner_D",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "def wigner_D(l, Robj):\n    # Placeholder for the actual implementation of the Wigner D function\n    # This function should compute the Wigner D-matrix for a given rotation object and angular momentum l.\n    # Here, we are simply returning an identity matrix of size (2l+1, 2l+1) for demonstration purposes.\n    return np.eye(2 * l + 1)"
        },
        {
            "key_id": 13,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import wigner_D",
                "from sphecerix.tesseral import tesseral_transformation"
            ],
            "code": "def tesseral_wigner_D(l, Robj):\n    # This function computes the tesseral Wigner D-matrix for a given rotation object and angular momentum l.\n    # It uses the wigner_D function to compute the Wigner D-matrix and then transforms it into the tesseral form.\n    D = wigner_D(l, Robj)\n    T = tesseral_transformation(l)\n    # The tesseral Wigner D-matrix is obtained by transforming the Wigner D-matrix using the tesseral transformation.\n    return T @ D @ np.linalg.inv(T)"
        },
        {
            "key_id": 38,
            "fqn": "sphecerix/tesseral.py/tesseral_transformation",
            "imports": [
                "import numpy as np"
            ],
            "code": "def tesseral_transformation(l):\n    # Placeholder for the transformation matrix\n    transformation_matrix = np.identity(2 * l + 1)\n    # This is a simplified representation. The actual implementation\n    # would involve complex mathematical operations to compute the\n    # transformation matrix for tesseral harmonics.\n    return transformation_matrix"
        },
        {
            "key_id": 39,
            "fqn": "sphecerix/tesseral.py/permutation_sh_car",
            "imports": [
                "import numpy as np"
            ],
            "code": "def permutation_sh_car():\n    # This function would generate the permutation matrix for\n    # spherical harmonics to Cartesian coordinates conversion.\n    # Placeholder for the permutation matrix\n    permutation_matrix = np.eye(3)  # Simplified example\n    return permutation_matrix"
        },
        {
            "key_id": 14,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_mirror",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import wigner_D",
                "from sphecerix.tesseral import tesseral_transformation"
            ],
            "code": "def tesseral_wigner_D_mirror(l, normal):\n    # Assuming 'normal' is a normalized numpy array representing the mirror plane\n    # Placeholder for the mirror transformation\n    mirror_matrix = np.diag([-1 if i % 2 else 1 for i in range(2 * l + 1)])\n    D = wigner_D(l, normal)  # This would require the actual rotation object\n    T = tesseral_transformation(l)\n    # The actual implementation would correctly compute the Wigner D matrix for a mirror operation\n    return T @ D @ mirror_matrix @ np.linalg.inv(T)"
        },
        {
            "key_id": 15,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_improper",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import wigner_D, tesseral_wigner_D_mirror",
                "from sphecerix.tesseral import tesseral_transformation"
            ],
            "code": "def tesseral_wigner_D_improper(l, Robj):\n    # Assuming Robj is a scipy Rotation object representing the improper rotation\n    # Compute the mirror component of the improper rotation\n    mirror_matrix = tesseral_wigner_D_mirror(l, Robj.as_rotvec())\n    # Compute the proper rotation component\n    proper_rotation_matrix = wigner_D(l, Robj)\n    T = tesseral_transformation(l)\n    # Combine the effects of the mirror and the proper rotation\n    return T @ proper_rotation_matrix @ mirror_matrix @ np.linalg.inv(T)"
        },
        {
            "key_id": 20,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/add",
            "imports": [
                "from sphecerix.symmetry_operations import Identity, Inversion, Rotation, Mirror, ImproperRotation"
            ],
            "code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.mol = mol\n        self.operations = []\n\n    def add(self, name, label=None, vec=None, angle=None):\n        if name == 'identity':\n            self.operations.append(Identity())\n        elif name == 'inversion':\n            self.operations.append(Inversion())\n        elif name == 'rotation':\n            self.operations.append(Rotation(label, vec, angle))\n        elif name == 'mirror':\n            self.operations.append(Mirror(label, vec))\n        elif name == 'improper_rotation':\n            self.operations.append(ImproperRotation(label, vec, angle))\n        else:\n            raise ValueError(f'Unknown symmetry operation: {name}')"
        },
        {
            "key_id": 21,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/run",
            "imports": [
                "import numpy as np"
            ],
            "code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.mol = mol\n        self.operations = []\n\n    def run(self):\n        for operation in self.operations:\n            operation_matrix = operation.get_matrix()\n            for atom in self.mol.atoms:\n                atom.position = np.dot(operation_matrix, atom.position)"
        },
        {
            "key_id": 23,
            "fqn": "sphecerix/symmetry_operations.py/Operation/set_atomic_id",
            "imports": [],
            "code": "class Operation:\n    def __init__(self, name):\n        self.name = name\n        self.matrix = None\n        self.wigner_matrix = None\n\n    def set_atomic_id(self, idx):\n        self.atomic_id = idx\n        # Additional logic to handle atomic ID can be implemented here"
        },
        {
            "key_id": 25,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 26,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_wigner_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n\n    def get_wigner_matrix(self, l):\n        return np.eye(2*l + 1)"
        },
        {
            "key_id": 28,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = -np.eye(3)\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 29,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_wigner_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = -np.eye(3)\n\n    def get_wigner_matrix(self, l):\n        return np.diag((-1)**np.arange(-l, l+1))"
        },
        {
            "key_id": 31,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_matrix",
            "imports": [
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        rot_obj = R.from_rotvec(axis * angle)\n        self.matrix = rot_obj.as_matrix()\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 32,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_wigner_matrix",
            "imports": [
                "from sphecerix.wignerd import tesseral_wigner_D"
            ],
            "code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        rot_obj = R.from_rotvec(axis * angle)\n        self.matrix = rot_obj.as_matrix()\n\n    def get_wigner_matrix(self, l):\n        return tesseral_wigner_D(l, rot_obj)"
        },
        {
            "key_id": 34,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = normal\n        self.type = 'Mirror'\n        self.matrix = None\n\n    def get_matrix(self):\n        if self.matrix is None:\n            n = self.normal\n            self.matrix = np.array([[1 - 2*n[0]**2, -2*n[0]*n[1], -2*n[0]*n[2]],\n                                    [-2*n[0]*n[1], 1 - 2*n[1]**2, -2*n[1]*n[2]],\n                                    [-2*n[0]*n[2], -2*n[1]*n[2], 1 - 2*n[2]**2]])\n        return self.matrix"
        },
        {
            "key_id": 35,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_wigner_matrix",
            "imports": [
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = normal\n        self.type = 'Mirror'\n        self.matrix = None\n\n    def get_wigner_matrix(self, l):\n        if self.matrix is None:\n            self.get_matrix()\n        return tesseral_wigner_D_mirror(l, self.normal)"
        },
        {
            "key_id": 37,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class ImproperRotation:\n    def __init__(self, label, axis, angle):\n        self.label = label\n        self.axis = axis\n        self.angle = angle\n        self.type = 'ImproperRotation'\n        self.matrix = None\n\n    def get_matrix(self):\n        if self.matrix is None:\n            axis_normalized = self.axis / np.linalg.norm(self.axis)\n            c, s = np.cos(self.angle), np.sin(self.angle)\n            x, y, z = axis_normalized\n            self.matrix = np.array([[c + (1-c)*x*x, (1-c)*x*y - s*z, (1-c)*x*z + s*y],\n                                    [(1-c)*y*x + s*z, c + (1-c)*y*y, (1-c)*y*z - s*x],\n                                    [(1-c)*z*x - s*y, (1-c)*z*y + s*x, c + (1-c)*z*z]])\n        return self.matrix"
        },
        {
            "key_id": 4,
            "fqn": "sphecerix/molecule.py/Molecule/__str__",
            "imports": [],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def __str__(self):\n        atoms_str = ', '.join([f'{atom['atom']} at ({atom['x']}, {atom['y']}, {atom['z']})' for atom in self.atoms])\n        return f'Molecule: {self.name}, Atoms: {atoms_str}'"
        },
        {
            "key_id": 5,
            "fqn": "sphecerix/molecule.py/Molecule/add_atom",
            "imports": [],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        self.atoms.append({'atom': atom, 'x': x, 'y': y, 'z': z, 'unit': unit})\n        print(f'Added atom {atom} at ({x}, {y}, {z}) in {unit} units')"
        },
        {
            "key_id": 6,
            "fqn": "sphecerix/molecule.py/Molecule/build_basis",
            "imports": [],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def build_basis(self, molset):\n        # Assuming molset provides a list of basis functions\n        self.basis_functions = [f for f in molset]\n        print(f'Basis functions set for molecule {self.name}')"
        },
        {
            "key_id": 41,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_name",
            "imports": [],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.name = self.__get_name()\n\n    def __get_name(self):\n        return f'Function_{self.n}_{self.l}_{self.m}'"
        },
        {
            "key_id": 42,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_type",
            "imports": [],
            "code": "def __get_type(self):\n    # Assuming a simple categorization based on the angular momentum quantum number, l\n    if self.l == 0:\n        return 's'\n    elif self.l == 1:\n        return 'p'\n    elif self.l == 2:\n        return 'd'\n    elif self.l == 3:\n        return 'f'\n    else:\n        return 'higher'"
        },
        {
            "key_id": 0,
            "fqn": "sphecerix/matrixplot.py/visualize_matrices",
            "imports": [
                "import matplotlib.pyplot as plt",
                "from .plot_highlight_groups import plot_highlight_groups",
                "from .plot_matrix import plot_matrix"
            ],
            "code": "def visualize_matrices(symops, numcols = 3, highlight_groups = None, filename = None, figsize = (7,5), xlabelrot = 0):\n    fig, axs = plt.subplots(len(symops) // numcols + bool(len(symops) % numcols), numcols, figsize=figsize)\n    for i, symop in enumerate(symops):\n        ax = axs.flatten()[i]\n        plot_matrix(ax, symop.matrix, symop.bfs, title=symop.name, xlabelrot=xlabelrot)\n        if highlight_groups and symop.name in highlight_groups:\n            plot_highlight_groups(ax, highlight_groups[symop.name], symop.matrix)\n    plt.tight_layout()\n    if filename:\n        plt.savefig(filename)\n    else:\n        plt.show()"
        },
        {
            "key_id": 1,
            "fqn": "sphecerix/matrixplot.py/plot_highlight_groups",
            "imports": [
                "import matplotlib.pyplot as plt"
            ],
            "code": "def plot_highlight_groups(axh, groups, mat):\n    for group in groups:\n        axh.plot(group, [mat[g] for g in group], marker='o', linestyle='-', color='red')"
        },
        {
            "key_id": 2,
            "fqn": "sphecerix/matrixplot.py/plot_matrix",
            "imports": [
                "import matplotlib.pyplot as plt",
                "import numpy as np"
            ],
            "code": "def plot_matrix(ax, mat, bfs, title = None, xlabelrot = 0):\n    cax = ax.matshow(mat, cmap='viridis')\n    if title:\n        ax.set_title(title)\n    ax.set_xticks(np.arange(len(bfs)))\n    ax.set_xticklabels(bfs, rotation=xlabelrot)\n    ax.set_yticks(np.arange(len(bfs)))\n    ax.set_yticklabels(bfs)\n    plt.colorbar(cax, ax=ax)"
        },
        {
            "key_id": 44,
            "fqn": "examples/fz3_rotation.py/main",
            "imports": [
                "from sphecerix import tesseral_wigner_D",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.atomic_wave_functions import wffield, wffield_l",
                "import numpy as np"
            ],
            "code": "def main():\n    # build rotation axis and set angle\n    axis = np.ones(3) / np.sqrt(3)\n    angle = np.pi\n    Robj = R.from_rotvec(axis * angle)\n    \n    # construct tesseral Wigner D matrix for l=3 (f orbital)\n    D = tesseral_wigner_D(3, Robj)\n    Y = np.zeros(7)  # for l=3, m ranges from -3 to 3\n    Y[3] = 1  # setting the 4fz3 orbital\n    \n    # calculate linear combination of the spherical harmonics after rotation\n    Yp = D @ Y\n    print(Yp)"
        },
        {
            "key_id": 45,
            "fqn": "examples/ethylene.py/main",
            "imports": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations",
                "from sphecerix.basis_functions import BasisFunction"
            ],
            "code": "def main():\n    ethylene = Molecule('Ethylene')\n    ethylene.add_atom('C', 0.0, 0.0, 0.67)\n    ethylene.add_atom('C', 0.0, 0.0, -0.67)\n    ethylene.add_atom('H', 0.92, 0.92, 1.23)\n    ethylene.add_atom('H', -0.92, -0.92, 1.23)\n    ethylene.add_atom('H', 0.92, 0.92, -1.23)\n    ethylene.add_atom('H', -0.92, -0.92, -1.23)\n    ethylene.build_basis('sto-3g')\n    sym_ops = SymmetryOperations(ethylene)\n    sym_ops.add('C2', axis=[0,0,1], angle=180)\n    sym_ops.add('sigma_v', plane='xy')\n    sym_ops.run()\n    print(ethylene)"
        },
        {
            "key_id": 46,
            "fqn": "examples/dz2_rotation.py/main",
            "imports": [
                "from sphecerix.atomic_wave_functions import wffield",
                "import numpy as np"
            ],
            "code": "def main():\n    n, l, m = 3, 2, 0\n    d = np.array([1, 1, 1]) / np.sqrt(3)\n    npts = 100\n    field = wffield(n, l, m, d, npts)\n    print('Field generated for dz2 rotation:', field)"
        },
        {
            "key_id": 47,
            "fqn": "examples/nh3.py/main",
            "imports": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations",
                "from sphecerix.basis_functions import BasisFunction"
            ],
            "code": "def main():\n    ammonia = Molecule('Ammonia')\n    ammonia.add_atom('N', 0.0, 0.0, 0.0)\n    ammonia.add_atom('H', 0.94, 0.0, 0.36)\n    ammonia.add_atom('H', -0.47, 0.82, 0.36)\n    ammonia.add_atom('H', -0.47, -0.82, 0.36)\n    ammonia.build_basis('sto-3g')\n    sym_ops = SymmetryOperations(ammonia)\n    sym_ops.add('C3', axis=[0,0,1], angle=120)\n    sym_ops.add('sigma_v', plane='xy')\n    sym_ops.run()\n    print(ammonia)"
        },
        {
            "key_id": 43,
            "fqn": "docs/conf.py/setup",
            "imports": [
                "import os",
                "import sys"
            ],
            "code": "def setup(app):\n    app.add_css_file('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css')\n    app.add_css_file('custom.css')\n    sys.path.insert(0, os.path.abspath('..'))"
        }
    ]
}