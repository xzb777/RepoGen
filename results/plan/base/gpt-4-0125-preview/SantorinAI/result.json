{
    "implementation": [
        {
            "key_id": 25,
            "fqn": "santorinai/pawn.py/Pawn/__init__",
            "imports": [],
            "code": "class Pawn:\n    def __init__(self, number: int, order: int, player_number: int):\n        self.number = number\n        self.order = order\n        self.player_number = player_number\n        self.pos = (None, None)"
        },
        {
            "key_id": 0,
            "fqn": "santorinai/board.py/Board/__init__",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "class Board:\n    def __init__(self, number_of_players: int):\n        self.number_of_players = number_of_players\n        self.pawns = [Pawn(i+1, i//2+1, (i%number_of_players)+1) for i in range(number_of_players*2)]\n        self.board = [[0 for _ in range(5)] for _ in range(5)]\n        self.player_turn = 1\n        self.turn_number = 0"
        },
        {
            "key_id": 21,
            "fqn": "santorinai/player.py/Player/__init__",
            "imports": [],
            "code": "class Player:\n    def __init__(self, player_number: int, log_level=0):\n        self.player_number = player_number\n        self.log_level = log_level\n        self.pawns = []\n\n    def name(self):\n        return 'Unnamed Player'\n\n    def place_pawn(self, board, pawn):\n        raise NotImplementedError\n\n    def play_move(self, board):\n        raise NotImplementedError"
        },
        {
            "key_id": 33,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/__init__",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class FirstChoicePlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level=log_level)\n        self.name = 'First Choice Player'"
        },
        {
            "key_id": 37,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/__init__",
            "imports": [
                "from santorinai.player import Player",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level=log_level)\n        self.name = 'Random Player'\n\n    def place_pawn(self, board, pawn):\n        possible_positions = [(x, y) for x in range(5) for y in range(5) if board.is_position_valid((x, y))]\n        return choice(possible_positions) if possible_positions else None\n\n    def play_move(self, board):\n        pawns = [pawn for pawn in self.pawns if pawn.pos]\n        pawn = choice(pawns) if pawns else None\n        if pawn:\n            possible_moves = board.get_possible_movement_and_building_positions(pawn)\n            return choice(possible_moves) if possible_moves else (None, None, None)\n        return None, None, None"
        },
        {
            "key_id": 41,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/__init__",
            "imports": [],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number)\n        self.log_level = log_level\n        # Initialize any additional properties if needed"
        },
        {
            "key_id": 26,
            "fqn": "santorinai/pawn.py/Pawn/move",
            "imports": [],
            "code": "def move(self, new_pos: Tuple[int, int]):\n    if new_pos[0] < 0 or new_pos[0] > 4 or new_pos[1] < 0 or new_pos[1] > 4:\n        raise ValueError('Position out of bounds')\n    self.pos = new_pos"
        },
        {
            "key_id": 27,
            "fqn": "santorinai/pawn.py/Pawn/copy",
            "imports": [],
            "code": "def copy(self) -> 'Pawn':\n    return Pawn(self.number, self.order, self.player_number)"
        },
        {
            "key_id": 28,
            "fqn": "santorinai/pawn.py/Pawn/__repr__",
            "imports": [],
            "code": "def __repr__(self):\n    return f'Pawn(number={self.number}, order={self.order}, player_number={self.player_number}, pos={self.pos})'"
        },
        {
            "key_id": 2,
            "fqn": "santorinai/board.py/Board/is_position_within_board",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_position_within_board(self, position: Tuple[int, int]):\n    return 0 <= position[0] < 5 and 0 <= position[1] < 5"
        },
        {
            "key_id": 3,
            "fqn": "santorinai/board.py/Board/is_position_adjacent",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_position_adjacent(self, position1: Tuple[int, int], position2: Tuple[int, int]):\n    return max(abs(position1[0] - position2[0]), abs(position1[1] - position2[1])) == 1"
        },
        {
            "key_id": 4,
            "fqn": "santorinai/board.py/Board/is_pawn_on_position",
            "imports": [],
            "code": "def is_pawn_on_position(self, position: Tuple[int, int]) -> bool:\n    for pawn in self.pawns:\n        if pawn.pos == position:\n            return True\n    return False"
        },
        {
            "key_id": 15,
            "fqn": "santorinai/board.py/Board/is_position_valid",
            "imports": [],
            "code": "def is_position_valid(self, pos: Tuple[int, int]) -> bool:\n    if not self.is_position_within_board(pos):\n        return False\n    if self.is_pawn_on_position(pos):\n        return False\n    return True"
        },
        {
            "key_id": 1,
            "fqn": "santorinai/board.py/Board/is_move_possible",
            "imports": [],
            "code": "def is_move_possible(self, start_pos: Tuple[int, int], end_pos: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_valid(end_pos):\n        return False, 'Invalid position'\n    if not self.is_position_adjacent(start_pos, end_pos):\n        return False, 'Positions not adjacent'\n    if self.board[end_pos[0]][end_pos[1]] == 4:  # Check for terminated tower\n        return False, 'Cannot move to a terminated tower'\n    return True, ''"
        },
        {
            "key_id": 5,
            "fqn": "santorinai/board.py/Board/is_build_possible",
            "imports": [],
            "code": "def is_build_possible(self, builder_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_valid(build_position):\n        return False, 'Invalid build position'\n    if not self.is_position_adjacent(builder_position, build_position):\n        return False, 'Build position not adjacent'\n    if self.board[build_position[0]][build_position[1]] == 4:  # Check for terminated tower\n        return False, 'Cannot build on a terminated tower'\n    return True, ''"
        },
        {
            "key_id": 16,
            "fqn": "santorinai/board.py/Board/is_game_over",
            "imports": [],
            "code": "def is_game_over(self) -> bool:\n    if self.is_everyone_stuck():\n        return True\n    for pawn in self.pawns:\n        if self.board[pawn.pos[0]][pawn.pos[1]] == 3:  # Check if any pawn is on the 3rd level\n            return True\n    return False"
        },
        {
            "key_id": 17,
            "fqn": "santorinai/board.py/Board/is_everyone_stuck",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def is_everyone_stuck(self) -> bool:\n    for pawn in self.pawns:\n        if self.get_possible_movement_positions(pawn):\n            return False\n    return True"
        },
        {
            "key_id": 18,
            "fqn": "santorinai/board.py/Board/next_turn",
            "imports": [],
            "code": "def next_turn(self):\n    self.player_turn = (self.player_turn % self.number_of_players) + 1\n    self.turn_number += 1"
        },
        {
            "key_id": 19,
            "fqn": "santorinai/board.py/Board/copy",
            "imports": [
                "copy"
            ],
            "code": "def copy(self) -> 'Board':\n    new_board = Board(self.number_of_players)\n    new_board.pawns = copy.deepcopy(self.pawns)\n    new_board.board = copy.deepcopy(self.board)\n    new_board.player_turn = self.player_turn\n    new_board.turn_number = self.turn_number\n    return new_board"
        },
        {
            "key_id": 20,
            "fqn": "santorinai/board.py/Board/__repr__",
            "imports": [],
            "code": "def __repr__(self) -> str:\n    board_str = ''\n    for row in self.board:\n        board_str += ' '.join(str(cell) for cell in row) + '\\n'\n    return f'Board:\\n{board_str}Player Turn: {self.player_turn}, Turn Number: {self.turn_number}'"
        },
        {
            "key_id": 6,
            "fqn": "santorinai/board.py/Board/get_player_pawns",
            "imports": [],
            "code": "def get_player_pawns(self, player_number: int) -> list:\n    return [pawn for pawn in self.pawns if pawn.player_number == player_number]"
        },
        {
            "key_id": 7,
            "fqn": "santorinai/board.py/Board/get_player_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_player_pawn(self, player_number: int, pawn_number: int) -> Pawn:\n        for pawn in self.pawns:\n            if pawn.player_number == player_number and pawn.number == pawn_number:\n                return pawn\n        raise ValueError('Pawn not found')"
        },
        {
            "key_id": 8,
            "fqn": "santorinai/board.py/Board/get_playing_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_playing_pawn(self, pawn_number: int) -> Pawn:\n        for pawn in self.pawns:\n            if pawn.order == pawn_number and pawn.player_number == self.player_turn:\n                return pawn\n        raise ValueError('Playing pawn not found')"
        },
        {
            "key_id": 9,
            "fqn": "santorinai/board.py/Board/get_first_unplaced_player_pawn",
            "imports": [
                "from santorinai.pawn import Pawn"
            ],
            "code": "def get_first_unplaced_player_pawn(self, player_number: int) -> Pawn:\n        for pawn in self.pawns:\n            if pawn.player_number == player_number and pawn.pos == (None, None):\n                return pawn\n        raise ValueError('No unplaced pawns for this player')"
        },
        {
            "key_id": 10,
            "fqn": "santorinai/board.py/Board/get_possible_movement_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_movement_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:\n        possible_positions = []\n        for x in range(max(0, pawn.pos[0] - 1), min(5, pawn.pos[0] + 2)):\n            for y in range(max(0, pawn.pos[1] - 1), min(5, pawn.pos[1] + 2)):\n                if self.is_move_possible(pawn.pos, (x, y))[0] and not self.is_pawn_on_position((x, y)):\n                    possible_positions.append((x, y))\n        return possible_positions"
        },
        {
            "key_id": 11,
            "fqn": "santorinai/board.py/Board/get_possible_building_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_building_positions(self, pawn: Pawn) -> List[Tuple[int, int]]:\n        possible_positions = []\n        for x in range(max(0, pawn.pos[0] - 1), min(5, pawn.pos[0] + 2)):\n            for y in range(max(0, pawn.pos[1] - 1), min(5, pawn.pos[1] + 2)):\n                if self.is_build_possible(pawn.pos, (x, y)):\n                    possible_positions.append((x, y))\n        return possible_positions"
        },
        {
            "key_id": 12,
            "fqn": "santorinai/board.py/Board/get_possible_movement_and_building_positions",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def get_possible_movement_and_building_positions(self, pawn):\n    possible_moves = self.get_possible_movement_positions(pawn)\n    possible_builds = self.get_possible_building_positions(pawn)\n    possible_combinations = []\n    for move in possible_moves:\n        pawn_copy = pawn.copy()\n        pawn_copy.move(move)\n        for build in possible_builds:\n            if self.is_build_possible(move, build):\n                possible_combinations.append((move, build))\n    return possible_combinations"
        },
        {
            "key_id": 13,
            "fqn": "santorinai/board.py/Board/place_pawn",
            "imports": [],
            "code": "def place_pawn(self, position: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_valid(position) or self.is_pawn_on_position(position):\n        return False, 'Invalid position or position already occupied'\n    pawn = self.get_first_unplaced_player_pawn(self.player_turn)\n    if pawn is None:\n        return False, 'All pawns already placed'\n    pawn.move(position)\n    if self.is_game_over():\n        return False, 'Game is over'\n    self.next_turn()\n    return True, 'Pawn placed successfully'"
        },
        {
            "key_id": 14,
            "fqn": "santorinai/board.py/Board/play_move",
            "imports": [],
            "code": "def play_move(self, pawn_number: int, move_position: Tuple[int, int], build_position: Tuple[int, int]) -> Tuple[bool, str]:\n    if not self.is_position_valid(move_position) or not self.is_position_valid(build_position):\n        return False, 'Invalid move or build position'\n    if not self.is_move_possible(self.get_playing_pawn(pawn_number).pos, move_position):\n        return False, 'Move not possible'\n    if not self.is_build_possible(move_position, build_position):\n        return False, 'Build not possible'\n    pawn = self.get_playing_pawn(pawn_number)\n    pawn.move(move_position)\n    if self.is_game_over() or self.is_everyone_stuck():\n        return False, 'Game is over or all players are stuck'\n    self.next_turn()\n    return True, 'Move and build successful'"
        },
        {
            "key_id": 29,
            "fqn": "santorinai/board_displayer/board_displayer.py/init_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def init_window(player_names):\n    sg.theme('LightBlue')\n    layout = [[sg.Text('Santorini AI Game')], [sg.Canvas(key='canvas')], [sg.Button('Close')]]\n    window = sg.Window('Santorini AI', layout, finalize=True)\n    return window"
        },
        {
            "key_id": 30,
            "fqn": "santorinai/board_displayer/board_displayer.py/draw_isometric_cube",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def draw_isometric_cube(window: sg.Window, x, y, size, cube_height, color, line_color, line_width):\n    canvas = window['canvas']\n    points = [(x, y), (x + size, y), (x + size * 1.5, y + size // 2), (x + size * 0.5, y + size // 2), (x, y)]\n    for point in points:\n        canvas.draw_polygon(points, fill_color=color, line_color=line_color, line_width=line_width)\n    top_points = [(points[0][0], points[0][1] - cube_height), (points[1][0], points[1][1] - cube_height), (points[2][0], points[2][1] - cube_height), (points[3][0], points[3][1] - cube_height), (points[0][0], points[0][1] - cube_height)]\n    canvas.draw_polygon(top_points, fill_color=color, line_color=line_color, line_width=line_width)"
        },
        {
            "key_id": 31,
            "fqn": "santorinai/board_displayer/board_displayer.py/update_board",
            "imports": [
                "import PySimpleGUI as sg",
                "from santorinai.board import Board"
            ],
            "code": "def update_board(window: sg.Window, board: Board):\n    for y in range(5):\n        for x in range(5):\n            cube_height = board.board[y][x] * 20  # Assuming each level increases height by 20\n            color = 'grey' if cube_height == 0 else 'blue'\n            draw_isometric_cube(window, x * 100, y * 100, 100, cube_height, color, 'black', 2)\n    window.refresh()"
        },
        {
            "key_id": 32,
            "fqn": "santorinai/board_displayer/board_displayer.py/close_window",
            "imports": [
                "import PySimpleGUI as sg"
            ],
            "code": "def close_window(window: sg.Window):\n    window.close()"
        },
        {
            "key_id": 22,
            "fqn": "santorinai/player.py/Player/name",
            "imports": [],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level=log_level)\n        self._name = 'Random Player'\n\n    def name(self):\n        return self._name"
        },
        {
            "key_id": 23,
            "fqn": "santorinai/player.py/Player/place_pawn",
            "imports": [
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level=log_level)\n\n    def place_pawn(self, board: Board, pawn: Pawn) -> tuple[int, int]:\n        possible_positions = [(x, y) for x in range(5) for y in range(5) if board.is_position_valid((x, y))]\n        chosen_position = choice(possible_positions) if possible_positions else None\n        if chosen_position:\n            pawn.move(chosen_position)\n        return chosen_position"
        },
        {
            "key_id": 24,
            "fqn": "santorinai/player.py/Player/play_move",
            "imports": [
                "from santorinai.board import Board",
                "from random import choice"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level=log_level)\n\n    def play_move(self, board: Board) -> tuple[int, tuple[int, int], tuple[int, int]]:\n        pawns = [pawn for pawn in self.pawns if pawn.pos]\n        pawn = choice(pawns) if pawns else None\n        if pawn:\n            possible_moves = board.get_possible_movement_and_building_positions(pawn)\n            if possible_moves:\n                move_choice = choice(possible_moves)\n                return pawn.order, move_choice[0], move_choice[1]\n        return None, None, None"
        },
        {
            "key_id": 34,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/name",
            "imports": [],
            "code": "def name(self):\n    return 'First Choice Player'"
        },
        {
            "key_id": 35,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/place_pawn",
            "imports": [
                "from random import choice"
            ],
            "code": "def place_pawn(self, board, pawn):\n    possible_positions = board.get_possible_movement_positions(pawn)\n    chosen_position = choice(possible_positions) if possible_positions else None\n    return chosen_position"
        },
        {
            "key_id": 36,
            "fqn": "santorinai/player_examples/first_choice_player.py/FirstChoicePlayer/play_move",
            "imports": [
                "from random import choice"
            ],
            "code": "def play_move(self, board):\n    pawns = board.get_player_pawns(self.player_number)\n    pawn = choice(pawns) if pawns else None\n    if pawn:\n        possible_moves = board.get_possible_movement_and_building_positions(pawn)\n        chosen_move = choice(possible_moves) if possible_moves else (None, None, None)\n        return pawn.order, chosen_move[0], chosen_move[1]\n    return None, None, None"
        },
        {
            "key_id": 38,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/name",
            "imports": [],
            "code": "def name(self):\n    return 'Random Player'"
        },
        {
            "key_id": 39,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/place_pawn",
            "imports": [
                "from random import choice"
            ],
            "code": "def place_pawn(self, board, pawn):\n    possible_positions = [(x, y) for x in range(5) for y in range(5) if board.is_position_valid((x, y))]\n    chosen_position = choice(possible_positions) if possible_positions else None\n    return chosen_position"
        },
        {
            "key_id": 40,
            "fqn": "santorinai/player_examples/random_player.py/RandomPlayer/play_move",
            "imports": [
                "from random import choice",
                "from santorinai.player import Player",
                "from santorinai.board import Board"
            ],
            "code": "class RandomPlayer(Player):\n    def __init__(self, player_number, log_level=0):\n        super().__init__(player_number, log_level=log_level)\n        self.name = 'Random Player'\n\n    def place_pawn(self, board, pawn):\n        possible_positions = [(x, y) for x in range(5) for y in range(5) if board.is_position_valid((x, y))]\n        return choice(possible_positions) if possible_positions else None\n\n    def play_move(self, board):\n        pawns = [pawn for pawn in self.pawns if pawn.pos]\n        pawn = choice(pawns) if pawns else None\n        if pawn:\n            possible_moves = board.get_possible_movement_and_building_positions(pawn)\n            move_and_build = choice(possible_moves) if possible_moves else (None, None, None)\n            if move_and_build != (None, None, None):\n                return pawn.order, move_and_build[0], move_and_build[1]\n        return None, None, None"
        },
        {
            "key_id": 42,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/name",
            "imports": [
                "from santorinai.player import Player"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number)\n        self.log_level = log_level\n\n    def name(self):\n        return 'Basic Player'"
        },
        {
            "key_id": 43,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_ally_pawn",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number)\n        self.log_level = log_level\n\n    def get_ally_pawn(self, board: Board, our_pawn: Pawn) -> tuple[Pawn, None]:\n        pawns = board.get_player_pawns(self.player_number)\n        for pawn in pawns:\n            if pawn != our_pawn:\n                return pawn, None\n        return None, None"
        },
        {
            "key_id": 44,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_enemy_pawns",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number)\n        self.log_level = log_level\n\n    def get_enemy_pawns(self, board, our_pawn):\n        enemy_pawns = [pawn for pawn in board.pawns if pawn.player_number != self.player_number]\n        return enemy_pawns"
        },
        {
            "key_id": 45,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/get_winning_moves",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number)\n        self.log_level = log_level\n\n    def get_winning_moves(self, board: Board, pawn: Pawn):\n        possible_moves = board.get_possible_movement_positions(pawn)\n        winning_moves = [move for move in possible_moves if board.board[move[0]][move[1]] == 3] # Assuming level 3 is the winning condition\n        return winning_moves"
        },
        {
            "key_id": 46,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/place_pawn",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from santorinai.pawn import Pawn",
                "from random import choice"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number)\n        self.log_level = log_level\n\n    def place_pawn(self, board: Board, pawn: Pawn) -> tuple[int, int]:\n        # Assuming get_ally_pawn is a method to get positions where ally pawns are not present\n        ally_pawn_positions = [pawn.pos for pawn in board.get_player_pawns(self.player_number) if pawn.pos]\n        possible_positions = board.get_possible_movement_positions(pawn)\n        # Filter out positions where ally pawns are present\n        possible_positions = [pos for pos in possible_positions if pos not in ally_pawn_positions]\n        if possible_positions:\n            return choice(possible_positions)\n        else:\n            # Fallback to any possible position if no 'ideal' position is found\n            return choice(board.get_possible_movement_positions(pawn))"
        },
        {
            "key_id": 47,
            "fqn": "santorinai/player_examples/basic_player.py/BasicPlayer/play_move",
            "imports": [
                "from santorinai.player import Player",
                "from santorinai.board import Board",
                "from random import choice"
            ],
            "code": "class BasicPlayer(Player):\n    def __init__(self, player_number, log_level=0) -> None:\n        super().__init__(player_number)\n        self.log_level = log_level\n\n    def play_move(self, board: Board):\n        # Assuming get_winning_moves and get_enemy_pawns are methods to calculate strategic moves\n        winning_moves = self.get_winning_moves(board, self)\n        if winning_moves:\n            return choice(winning_moves)\n        enemy_pawns = self.get_enemy_pawns(board, self)\n        if enemy_pawns:\n            # Logic to block or counter enemy moves\n            # This is a placeholder for the actual logic to handle enemy pawns\n            pass\n        # Fallback to random move if no strategic move is found\n        all_pawns = board.get_player_pawns(self.player_number)\n        for pawn in all_pawns:\n            possible_moves = board.get_possible_movement_and_building_positions(pawn)\n            if possible_moves:\n                return pawn.order, choice(possible_moves)[0], choice(possible_moves)[1]\n        # If no move is possible\n        return None, None, None"
        }
    ]
}