{
    "implementation": [
        {
            "key_id": 14,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/__init__",
            "imports": [
                "from parsimonious.grammar import Grammar",
                "import logging"
            ],
            "code": "class RawSourceVisitor:\n    def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n        self.logger = logging.getLogger(__name__)\n        self.grammar = Grammar(\n            r\"\"\"\n            maccarone = human_source maccarone_chunk*\n            maccarone_chunk = snippet human_source?\n\n            snippet = snippet_open (ai_source snippet_close)?\n            snippet_open = snippet_open_single / snippet_open_multi\n            snippet_open_single = guidance_open guidance_inner \">>\" nl\n            snippet_open_multi = guidance_open nl guidance_lines guidance_close\n            snippet_close = ws \"#<</>>\" nl\n\n            guidance_open = ws \"#<<\"\n            guidance_close = ws \"#>>\" nl\n            guidance_line = ws \"#\" guidance_inner nl\n            guidance_lines = guidance_line+\n            guidance_inner = ~\"((?!>>).)*\"\n\n            human_source = source_line*\n            ai_source = source_line*\n            source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n            ws = ~\"[ \\t]*\"\n            nl = ws ~\"[\\r\\n]\"\n            \"\"\"\n        )"
        },
        {
            "key_id": 3,
            "fqn": "examples/todo.py/Todo/__init__",
            "imports": [
                "from dataclasses import dataclass"
            ],
            "code": "@dataclass\nclass Todo:\n    description: str\n    status: str = 'not done'\n    id: Optional[int] = None"
        },
        {
            "key_id": 13,
            "fqn": "src/maccarone/preprocessor.py/find_line_number",
            "imports": [
                "import re"
            ],
            "code": "def find_line_number(text: str, pos: int) -> int:\n    lines = text[:pos].split('\\n')\n    return len(lines)"
        },
        {
            "key_id": 15,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/generic_visit",
            "imports": [
                "from parsimonious.nodes import Node",
                "from typing import List"
            ],
            "code": "class RawSourceVisitor:\n    def __init__(self, raw_source: str, block_at_line: Optional[int] = None):\n        self.logger = logging.getLogger(__name__)\n        self.grammar = Grammar(\n            r\"\"\"\n            maccarone = human_source maccarone_chunk*\n            maccarone_chunk = snippet human_source?\n\n            snippet = snippet_open (ai_source snippet_close)?\n            snippet_open = snippet_open_single / snippet_open_multi\n            snippet_open_single = guidance_open guidance_inner \">>\" nl\n            snippet_open_multi = guidance_open nl guidance_lines guidance_close\n            snippet_close = ws \"#<</>>\" nl\n\n            guidance_open = ws \"#<<\"\n            guidance_close = ws \"#>>\" nl\n            guidance_line = ws \"#\" guidance_inner nl\n            guidance_lines = guidance_line+\n            guidance_inner = ~\"((?!>>).)*\"\n\n            human_source = source_line*\n            ai_source = source_line*\n            source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n            ws = ~\"[ \\t]*\"\n            nl = ws ~\"[\\r\\n]\"\n            \"\"\"\n        )\n\n    def generic_visit(self, node: Node, visited_children: List[Node]):\n        self.logger.debug(f'Visiting node: {node}')\n        return node.text"
        },
        {
            "key_id": 16,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_maccarone",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "class RawSourceVisitor:\n    def visit_maccarone(self, node: Node, visited_children: list):\n        self.logger.info('Visiting maccarone node')\n        # Process maccarone node here\n        return visited_children"
        },
        {
            "key_id": 17,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_maccarone_chunk",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "class RawSourceVisitor:\n    def visit_maccarone_chunk(self, node: Node, visited_children: list):\n        self.logger.info('Visiting maccarone chunk')\n        # Process maccarone chunk here\n        return visited_children"
        },
        {
            "key_id": 18,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "class RawSourceVisitor:\n    def visit_snippet(self, node: Node, visited_children: list):\n        self.logger.info('Visiting snippet')\n        # Process snippet here\n        return visited_children"
        },
        {
            "key_id": 19,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open",
            "imports": [
                "from parsimonious.nodes import Node",
                "from typing import List"
            ],
            "code": "def visit_snippet_open(self, node: Node, visited_children: list):\n    # This method is responsible for handling the opening of a snippet.\n    # It should extract necessary information from the node and prepare\n    # for the snippet's content processing.\n    self.logger.debug('Visiting snippet open')\n    # Extracting guidance if any before the snippet content\n    guidance = ''.join(child.text for child in visited_children if isinstance(child, Node))\n    return {'type': 'snippet_open', 'guidance': guidance}"
        },
        {
            "key_id": 20,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open_single",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "def visit_snippet_open_single(self, node: Node, visited_children: list):\n    # Handles single line snippet openings.\n    self.logger.debug('Visiting single line snippet open')\n    guidance = node.text.strip('#<<').strip('>>').strip()\n    return {'type': 'snippet_open_single', 'guidance': guidance}"
        },
        {
            "key_id": 21,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_snippet_open_multi",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "def visit_snippet_open_multi(self, node: Node, visited_children: list):\n    # Handles multi-line snippet openings.\n    self.logger.debug('Visiting multi line snippet open')\n    guidance_lines = [child.text for child in visited_children if isinstance(child, Node)]\n    guidance = '\\n'.join(guidance_lines).strip('#<<').strip('>>').strip()\n    return {'type': 'snippet_open_multi', 'guidance': guidance}"
        },
        {
            "key_id": 22,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_open",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "def visit_guidance_open(self, node: Node, visited_children: list):\n    # This method processes the opening of guidance for a snippet.\n    self.logger.debug('Visiting guidance open')\n    # Since this is just the opening, we might not do much here\n    # But it's important for structure\n    return {'type': 'guidance_open'}"
        },
        {
            "key_id": 23,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_line",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "def visit_guidance_line(self, node: Node, visited_children: list):\n    # Processes individual lines of guidance within a snippet.\n    self.logger.debug('Visiting guidance line')\n    guidance = node.text.strip('#').strip()\n    return {'type': 'guidance_line', 'content': guidance}"
        },
        {
            "key_id": 24,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_lines",
            "imports": [
                "from parsimonious.nodes import Node",
                "from typing import List"
            ],
            "code": "def visit_guidance_lines(self, node: Node, visited_children: list):\n    \"\"\"Process guidance lines in the source code.\n\n    Args:\n        node (Node): The current node being visited.\n        visited_children (list): The result of visiting the children of this node.\n\n    Returns:\n        The concatenated guidance lines as a single string.\n    \"\"\"\n    lines = [child.text for child in node]\n    return ''.join(lines)"
        },
        {
            "key_id": 25,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_guidance_inner",
            "imports": [
                "from parsimonious.nodes import Node"
            ],
            "code": "def visit_guidance_inner(self, node: Node, visited_children: list):\n    \"\"\"Extract the inner text of a guidance directive.\n\n    Args:\n        node (Node): The current node being visited.\n        visited_children (list): The result of visiting the children of this node.\n\n    Returns:\n        The inner text of the guidance directive.\n    \"\"\"\n    return node.text.strip()"
        },
        {
            "key_id": 26,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_human_source",
            "imports": [
                "from parsimonious.nodes import Node",
                "from typing import List"
            ],
            "code": "def visit_human_source(self, node: Node, visited_children: list):\n    \"\"\"Process human-written source code segments.\n\n    Args:\n        node (Node): The current node being visited.\n        visited_children (list): The result of visiting the children of this node.\n\n    Returns:\n        A list containing the human-written source code segments.\n    \"\"\"\n    return [child.text for child in node if child.expr_name == 'source_line']"
        },
        {
            "key_id": 27,
            "fqn": "src/maccarone/preprocessor.py/RawSourceVisitor/visit_ai_source",
            "imports": [
                "from parsimonious.nodes import Node",
                "from typing import List"
            ],
            "code": "def visit_ai_source(self, node: Node, visited_children: list):\n    \"\"\"Process AI-generated source code segments.\n\n    Args:\n        node (Node): The current node being visited.\n        visited_children (list): The result of visiting the children of this node.\n\n    Returns:\n        A list containing the AI-generated source code segments.\n    \"\"\"\n    return [child.text for child in node if child.expr_name == 'source_line']"
        },
        {
            "key_id": 11,
            "fqn": "src/maccarone/preprocessor.py/MissingPiece/get_line_pos",
            "imports": [
                "from typing import Tuple"
            ],
            "code": "def get_line_pos(self, raw_source: str) -> Tuple[int, int]:\n    \"\"\"Find the line position of a missing piece in the source code.\n\n    Args:\n        raw_source (str): The raw source code.\n\n    Returns:\n        Tuple[int, int]: A tuple containing the start and end positions of the missing piece.\n    \"\"\"\n    start_pos = raw_source.find('#<<')\n    end_pos = raw_source.find('>>', start_pos)\n    return start_pos, end_pos if start_pos != -1 and end_pos != -1 else (None, None)"
        },
        {
            "key_id": 12,
            "fqn": "src/maccarone/preprocessor.py/MissingPiece/complete",
            "imports": [
                "from typing import Optional"
            ],
            "code": "def complete(self, replacement: Optional[str]) -> str:\n    if replacement is None:\n        return ''\n    return replacement"
        },
        {
            "key_id": 28,
            "fqn": "src/maccarone/preprocessor.py/raw_source_to_pieces",
            "imports": [
                "from typing import List, Optional",
                "from parsimonious.grammar import Grammar",
                "from parsimonious.nodes import Node, NodeVisitor"
            ],
            "code": "def raw_source_to_pieces(input: str, block_at_line: Optional[int] = None) -> List[Piece]:\n    grammar = Grammar(\n        r\"\"\"\n        maccarone = human_source maccarone_chunk*\n        maccarone_chunk = snippet human_source?\n\n        snippet = snippet_open (ai_source snippet_close)?\n        snippet_open = snippet_open_single / snippet_open_multi\n        snippet_open_single = guidance_open guidance_inner \">>\" nl\n        snippet_open_multi = guidance_open nl guidance_lines guidance_close\n        snippet_close = ws \"#<</>>\" nl\n\n        guidance_open = ws \"#<<\"\n        guidance_close = ws \"#>>\" nl\n        guidance_line = ws \"#\" guidance_inner nl\n        guidance_lines = guidance_line+\n        guidance_inner = ~\"((?!>>).)*\"\n\n        human_source = source_line*\n        ai_source = source_line*\n        source_line = !(guidance_open / guidance_close / snippet_close) ws ~\".*\" nl?\n\n        ws = ~\"[ \\t]*\"\n        nl = ws ~\"[\\r\\n]\"\n        \"\"\"\n    )\n    visitor = RawSourceVisitor(input, block_at_line)\n    parsed = grammar.parse(input)\n    visitor.visit(parsed)\n    return visitor.pieces"
        },
        {
            "key_id": 29,
            "fqn": "src/maccarone/preprocessor.py/raw_pieces_to_tagged_input",
            "imports": [
                "from typing import List"
            ],
            "code": "def raw_pieces_to_tagged_input(raw_pieces: List[Piece]) -> str:\n    tagged_input = ''\n    for piece in raw_pieces:\n        if isinstance(piece, HumanSource):\n            tagged_input += piece.content\n        elif isinstance(piece, MaccaroneChunk):\n            tagged_input += f'#<< {piece.guidance} >>\\n'\n            if piece.ai_source is not None:\n                tagged_input += piece.ai_source.content + '\\n#<</>>\\n'\n    return tagged_input"
        },
        {
            "key_id": 30,
            "fqn": "src/maccarone/preprocessor.py/tagged_input_to_tagged_output",
            "imports": [
                "from src.maccarone.openai import ChatAPI"
            ],
            "code": "def tagged_input_to_tagged_output(tagged_input: str, chat_api: ChatAPI) -> str:\n    response = chat_api.complete_chat(chat_name='maccarone_preprocessing', messages=[{'role': 'system', 'content': 'This is a Maccarone preprocessing session.'}, {'role': 'user', 'content': tagged_input}], model='gpt-4')\n    return response"
        },
        {
            "key_id": 31,
            "fqn": "src/maccarone/preprocessor.py/tagged_output_to_completed_pieces",
            "imports": [
                "from typing import Dict"
            ],
            "code": "def tagged_output_to_completed_pieces(tagged_output: str) -> Dict[int, str]:\n    completed_pieces = {}\n    lines = tagged_output.split('\\n')\n    for i, line in enumerate(lines):\n        if line.startswith('#<<') and line.endswith('>>'):\n            guidance_line = line\n            ai_content = ''\n            for ai_line in lines[i+1:]:\n                if ai_line == '#<</>>':\n                    break\n                ai_content += ai_line + '\\n'\n            completed_pieces[i] = (guidance_line, ai_content.rstrip('\\n'))\n    return completed_pieces"
        },
        {
            "key_id": 32,
            "fqn": "src/maccarone/preprocessor.py/pieces_to_final_source",
            "imports": [
                "from typing import List, Dict"
            ],
            "code": "def pieces_to_final_source(raw_pieces: List[Piece], completed_pieces: Dict[int, str]) -> str:\n    final_source = ''\n    for piece in raw_pieces:\n        if piece.start_line in completed_pieces:\n            final_source += completed_pieces[piece.start_line]\n        else:\n            final_source += piece.content\n    return final_source"
        },
        {
            "key_id": 34,
            "fqn": "src/maccarone/openai.py/complete_chat",
            "imports": [
                "import openai"
            ],
            "code": "def complete_chat(messages: List[Dict[str, str]], model = 'gpt-4', on_token: Callable[[int], None] = lambda p: None) -> str:\n    response = openai.Completion.create(\n        engine=model,\n        prompt=[{'role': 'system', 'content': 'Python code generation'}] + messages,\n        temperature=0.7,\n        max_tokens=150,\n        stop=None\n    )\n    return response.choices[0].text.strip()"
        },
        {
            "key_id": 35,
            "fqn": "src/maccarone/openai.py/ChatAPI/complete_chat",
            "imports": [
                "from typing import List, Dict"
            ],
            "code": "class ChatAPI:\n    def complete_chat(self, chat_name: str, messages: List[Dict[str, str]], model = 'gpt-4') -> str:\n        logger.info(f'Completing chat for: {chat_name}')\n        return complete_chat(messages, model=model)"
        },
        {
            "key_id": 30,
            "fqn": "src/maccarone/preprocessor.py/tagged_input_to_tagged_output",
            "imports": [
                "from typing import List, Dict"
            ],
            "code": "def tagged_input_to_tagged_output(tagged_input: str, chat_api: ChatAPI) -> str:\n    messages = [{'role': 'user', 'content': tagged_input}]\n    chat_response = chat_api.complete_chat('code_generation', messages)\n    return chat_response"
        },
        {
            "key_id": 33,
            "fqn": "src/maccarone/preprocessor.py/preprocess_maccarone",
            "imports": [
                "from typing import Optional"
            ],
            "code": "def preprocess_maccarone(raw_source: str, chat_api: ChatAPI, block_at_line: Optional[int] = None) -> str:\n    raw_pieces = raw_source_to_pieces(raw_source, block_at_line)\n    tagged_input = raw_pieces_to_tagged_input(raw_pieces)\n    tagged_output = tagged_input_to_tagged_output(tagged_input, chat_api)\n    completed_pieces = tagged_output_to_completed_pieces(tagged_output)\n    final_source = pieces_to_final_source(raw_pieces, completed_pieces)\n    return final_source"
        },
        {
            "key_id": 36,
            "fqn": "src/maccarone/scripts/preprocess.py/preprocess",
            "imports": [
                "import logging",
                "from src.maccarone.preprocessor import preprocess_maccarone"
            ],
            "code": "def preprocess(mn_path: str, print_: bool, rewrite: bool, block_at_line: Optional[int]) -> None:\n    logger = logging.getLogger(__name__)\n    try:\n        result = preprocess_maccarone(mn_path, None, block_at_line)\n        if print_:\n            print(result)\n        if rewrite:\n            with open(mn_path, 'w') as f:\n                f.write(result)\n    except Exception as e:\n        logger.error(f'Error during preprocessing: {e}')"
        },
        {
            "key_id": 37,
            "fqn": "src/maccarone/scripts/preprocess.py/main",
            "imports": [
                "import argparse",
                "import logging",
                "from src.maccarone.scripts.preprocess import preprocess"
            ],
            "code": "def main(path: str, print_: bool, rewrite: bool, suffix: str, block_at_line: Optional[int] = None) -> None:\n    logger = logging.getLogger(__name__)\n    try:\n        preprocess(path, print_, rewrite, block_at_line)\n    except Exception as e:\n        logger.error(f'Failed to preprocess {path}: {e}')"
        },
        {
            "key_id": 38,
            "fqn": "src/maccarone/scripts/preprocess.py/parse_args",
            "imports": [
                "import argparse"
            ],
            "code": "def parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description='Process some integers.')\n    parser.add_argument('path', type=str, help='Path to the file or directory')\n    parser.add_argument('--print', dest='print_', action='store_true', help='Print the result to stdout')\n    parser.add_argument('--rewrite', action='store_true', help='Rewrite the source file with processed content')\n    parser.add_argument('--suffix', type=str, default='.py', help='File suffix to process when a directory is given')\n    parser.add_argument('--block-at-line', type=int, help='Process a specific block starting at the given line number')\n    return parser.parse_args()"
        },
        {
            "key_id": 39,
            "fqn": "src/maccarone/scripts/preprocess.py/script_main",
            "imports": [
                "import logging",
                "from src.maccarone.scripts.preprocess import main",
                "from src.maccarone.scripts.preprocess import parse_args"
            ],
            "code": "def script_main():\n    logger = logging.getLogger(__name__)\n    args = parse_args()\n    try:\n        main(args.path, args.print_, args.rewrite, args.suffix, args.block_at_line)\n    except Exception as e:\n        logger.error(f'Script failed: {e}')"
        },
        {
            "key_id": 36,
            "fqn": "src/maccarone/scripts/preprocess.py/preprocess",
            "imports": [
                "import logging",
                "from src.maccarone.preprocessor import preprocess_maccarone"
            ],
            "code": "def preprocess(mn_path: str, print_: bool, rewrite: bool, block_at_line: Optional[int]) -> None:\n    logger = logging.getLogger(__name__)\n    try:\n        processed_source = preprocess_maccarone(mn_path, None, block_at_line)\n        if print_:\n            print(processed_source)\n        if rewrite:\n            with open(mn_path, 'w') as f:\n                f.write(processed_source)\n    except Exception as e:\n        logger.error(f'Error processing {mn_path}: {e}')"
        },
        {
            "key_id": 39,
            "fqn": "src/maccarone/scripts/preprocess.py/script_main",
            "imports": [
                "import logging",
                "from argparse import Namespace",
                "from src.maccarone.scripts.preprocess import main",
                "from src.maccarone.scripts.preprocess import parse_args"
            ],
            "code": "def script_main():\n    logger = logging.getLogger(__name__)\n    try:\n        args = parse_args()\n        main(args.path, args.print_, args.rewrite, args.suffix, args.block_at_line)\n    except Exception as e:\n        logger.error(f'Failed to execute script_main: {e}')"
        },
        {
            "key_id": 4,
            "fqn": "examples/todo.py/load_todos",
            "imports": [
                "import json",
                "from examples.todo import Todo"
            ],
            "code": "def load_todos() -> list[Todo]:\n    try:\n        with open('todos.json', 'r') as f:\n            todos_data = json.load(f)\n            return [Todo(**todo) for todo in todos_data]\n    except FileNotFoundError:\n        return []"
        },
        {
            "key_id": 5,
            "fqn": "examples/todo.py/save_todos",
            "imports": [
                "import json",
                "from dataclasses import asdict"
            ],
            "code": "def save_todos(todos: list[Todo]) -> None:\n    with open('todos.json', 'w') as f:\n        json.dump([asdict(todo) for todo in todos], f)"
        },
        {
            "key_id": 6,
            "fqn": "examples/todo.py/add_todo",
            "imports": [
                "from examples.todo import Todo",
                "from examples.todo import load_todos",
                "from examples.todo import save_todos"
            ],
            "code": "def add_todo(description: str):\n    todos = load_todos()\n    new_todo = Todo(description=description)\n    todos.append(new_todo)\n    save_todos(todos)"
        },
        {
            "key_id": 7,
            "fqn": "examples/todo.py/remove_todo",
            "imports": [
                "from examples.todo import load_todos",
                "from examples.todo import save_todos"
            ],
            "code": "def remove_todo(id):\n    todos = load_todos()\n    todos = [todo for todo in todos if todo.id != id]\n    save_todos(todos)\n    print(f'Todo with id {id} has been removed.')"
        },
        {
            "key_id": 8,
            "fqn": "examples/todo.py/print_todos",
            "imports": [
                "from examples.todo import load_todos"
            ],
            "code": "def print_todos():\n    todos = load_todos()\n    for todo in todos:\n        print(f'ID: {todo.id}, Description: {todo.description}, Status: {todo.status}')"
        },
        {
            "key_id": 9,
            "fqn": "examples/todo.py/main",
            "imports": [
                "import argparse",
                "from examples.todo import add_todo",
                "from examples.todo import remove_todo",
                "from examples.todo import print_todos"
            ],
            "code": "def main():\n    parser = argparse.ArgumentParser(description='Manage your todos.')\n    parser.add_argument('--add', type=str, help='Add a new todo item.')\n    parser.add_argument('--remove', type=int, help='Remove a todo item by its ID.')\n    parser.add_argument('--list', action='store_true', help='List all todo items.')\n    args = parser.parse_args()\n\n    if args.add:\n        add_todo(args.add)\n    if args.remove is not None:\n        remove_todo(args.remove)\n    if args.list:\n        print_todos()"
        },
        {
            "key_id": 0,
            "fqn": "examples/file_sizes_ext.py/main",
            "imports": [
                "import argparse",
                "import os"
            ],
            "code": "def main(path: str, extension: str | None = None):\n    filenames = [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]\n    if extension:\n        filenames = [f for f in filenames if f.endswith(extension)]\n    for fn in filenames:\n        size = os.path.getsize(os.path.join(path, fn))\n        print(f'{fn}: {size} bytes')\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='List files and their sizes in a directory, optionally filtering by extension.')\n    parser.add_argument('path', type=str, help='Path to directory')\n    parser.add_argument('--extension', type=str, help='File extension to filter by', default=None)\n    args = parser.parse_args()\n    main(args.path, args.extension)"
        },
        {
            "key_id": 1,
            "fqn": "examples/add.py/add_two_numbers",
            "imports": [
                "import argparse"
            ],
            "code": "def add_two_numbers(x, y):\n    return x + y\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Add two numbers.')\n    parser.add_argument('x', type=int, help='First number')\n    parser.add_argument('y', type=int, help='Second number')\n    args = parser.parse_args()\n    result = add_two_numbers(args.x, args.y)\n    print(f'The sum of {args.x} and {args.y} is {result}')"
        },
        {
            "key_id": 2,
            "fqn": "examples/fizzbuzz.py/main",
            "imports": [
                "import argparse"
            ],
            "code": "def main(n: int):\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            print('FizzBuzz')\n        elif i % 3 == 0:\n            print('Fizz')\n        elif i % 5 == 0:\n            print('Buzz')\n        else:\n            print(i)\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='FizzBuzz up to a given number.')\n    parser.add_argument('n', type=int, help='The maximum number (inclusive) to FizzBuzz to.')\n    args = parser.parse_args()\n    main(args.n)"
        },
        {
            "key_id": 10,
            "fqn": "examples/file_sizes.py/main",
            "imports": [
                "import argparse",
                "import os"
            ],
            "code": "def main(path: str):\n    filenames = [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]\n    for fn in filenames:\n        size = os.path.getsize(os.path.join(path, fn))\n        print(f'{fn}: {size} bytes')\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='List the size of files under a directory path.')\n    parser.add_argument('path', type=str, help='The directory path to list files from.')\n    args = parser.parse_args()\n    main(args.path)"
        }
    ]
}