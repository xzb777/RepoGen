{
    "implementation": [
        {
            "key_id": 0,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/__init__",
            "imports": [],
            "code": "def __init__(self, fit_intercept: bool = True, alpha: float = 0.0):\n    self.fit_intercept = fit_intercept\n    self.alpha = alpha"
        },
        {
            "key_id": 4,
            "fqn": "constrainedlr/validation.py/validate_constraint_features_all_strings_or_all_int",
            "imports": [],
            "code": "def validate_constraint_features_all_strings_or_all_int(constraints: dict) -> None:\n    for key, value in constraints.items():\n        if not isinstance(key, (str, int)) or not isinstance(value, (str, int)):\n            raise TypeError('All keys and values in constraints must be either strings or integers')"
        },
        {
            "key_id": 3,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/get_feature_names_out",
            "imports": [],
            "code": "def get_feature_names_out(self) -> np.ndarray[str]:\n    return self.feature_names_out"
        },
        {
            "key_id": 4,
            "fqn": "constrainedlr/validation.py/validate_constraint_features_all_strings_or_all_int",
            "imports": [],
            "code": "def validate_constraint_features_all_strings_or_all_int(constraints: dict) -> None:\n    for key, value in constraints.items():\n        if not isinstance(key, (str, int)) or not isinstance(value, (str, int)):\n            raise TypeError('All keys and values in constraints must be either strings or integers')"
        },
        {
            "key_id": 5,
            "fqn": "constrainedlr/validation.py/get_clean_feature_names_from_pipeline",
            "imports": [],
            "code": "def get_clean_feature_names_from_pipeline(feature_names: list[str]) -> list[str]:\n    return [name.strip() for name in feature_names]"
        },
        {
            "key_id": 6,
            "fqn": "constrainedlr/validation.py/validate_feature_names_in_constraints",
            "imports": [],
            "code": "def validate_feature_names_in_constraints(constraints: dict, feature_names: list[str]) -> None:\n    constraint_features = set(constraints.keys())\n    if set(feature_names) != constraint_features:\n        raise ValueError('All feature names must be present in constraints')"
        },
        {
            "key_id": 7,
            "fqn": "constrainedlr/validation.py/convert_feature_names_to_indices",
            "imports": [
                "from typing import Dict",
                "import numpy as np"
            ],
            "code": "def convert_feature_names_to_indices(constraints: Dict, feature_names_in_: np.ndarray[str]) -> Dict:\n    indices = {}\n    for feature, constraint in constraints.items():\n        if feature in feature_names_in_:\n            indices[feature_names_in_.index(feature)] = constraint\n    return indices"
        },
        {
            "key_id": 8,
            "fqn": "constrainedlr/validation.py/validate_coefficients_sign_constraints",
            "imports": [
                "from typing import Optional, Dict, Union",
                "import numpy as np",
                "import pandas as pd"
            ],
            "code": "def validate_coefficients_sign_constraints(coefficients_sign_constraints: Optional[Dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> Dict:\n    if coefficients_sign_constraints is None:\n        return {}\n    validate_constraint_features_all_strings_or_all_int(coefficients_sign_constraints)\n    indices = convert_feature_names_to_indices(coefficients_sign_constraints, feature_names_in_)\n    return indices"
        },
        {
            "key_id": 9,
            "fqn": "constrainedlr/validation.py/validate_intercept_sign_constraint",
            "imports": [
                "from typing import Union"
            ],
            "code": "def validate_intercept_sign_constraint(intercept_sign_constraint: Union[int, str]) -> int:\n    if isinstance(intercept_sign_constraint, int):\n        return intercept_sign_constraint\n    if intercept_sign_constraint == 'positive':\n        return 1\n    elif intercept_sign_constraint == 'negative':\n        return -1\n    else:\n        raise ValueError('Invalid intercept sign constraint')"
        },
        {
            "key_id": 10,
            "fqn": "constrainedlr/validation.py/validate_coefficients_range_constraints",
            "imports": [
                "from typing import Optional, Dict, Union",
                "import numpy as np",
                "import pandas as pd"
            ],
            "code": "def validate_coefficients_range_constraints(coefficients_range_constraints: Optional[Dict], X: Union[np.ndarray, pd.DataFrame], feature_names_in_: Optional[np.ndarray[str]]) -> Dict:\n    if coefficients_range_constraints is None:\n        return {}\n    validate_constraint_features_all_strings_or_all_int(coefficients_range_constraints)\n    indices = convert_feature_names_to_indices(coefficients_range_constraints, feature_names_in_)\n    return indices"
        },
        {
            "key_id": 1,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/fit",
            "imports": [],
            "code": "def fit(self, X: Union[np.ndarray, pd.DataFrame], y: np.ndarray, sample_weight: Optional[np.ndarray] = None, coefficients_sign_constraints: Optional[Dict] = None, coefficients_range_constraints: Optional[Dict] = None, intercept_sign_constraint: Union[int, str] = 0, coefficients_sum_constraint: Optional[float] = None) -> 'ConstrainedLinearRegression':\n    # Implementation logic for fitting the model with constraints\n    pass"
        },
        {
            "key_id": 2,
            "fqn": "constrainedlr/model.py/ConstrainedLinearRegression/predict",
            "imports": [
                "from typing import Union",
                "import numpy as np"
            ],
            "code": "def predict(self, X: Union[np.ndarray, pd.DataFrame]) -> np.ndarray:\n    if isinstance(X, pd.DataFrame):\n        X = X.values\n\n    if self.fit_intercept:\n        X = np.column_stack((np.ones(X.shape[0]), X))\n\n    return np.dot(X, self.coef_) + self.intercept_"
        }
    ]
}