{
    "implementation": [
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/matrixplot.py",
            "relative_path": "sphecerix/matrixplot.py",
            "fqn_list": "sphecerix/matrixplot.py/visualize_matrices",
            "class": null,
            "signature": "def visualize_matrices(symops, numcols = 3, highlight_groups = None, filename = None, figsize = (7,5), xlabelrot = 0):",
            "comment": "Visualize matrix representations of the symmetry operations",
            "comment_free_code": "def visualize_matrices(symops, numcols=3, highlight_groups=None, filename=None, figsize=(7, 5), xlabelrot=0):\n    \n    matrices = symops.operation_matrices\n    operations = symops.operations\n    bfs = symops.mol.basis\n    (fig, ax) = plt.subplots(len(operations) // numcols, numcols, dpi=144, figsize=figsize)\n    for (i, (op, mat)) in enumerate(zip(operations, matrices)):\n        axh = ax[i // numcols, i % numcols]\n        plot_matrix(axh, mat, bfs, title=op.name, xlabelrot=xlabelrot)\n        if highlight_groups:\n            plot_highlight_groups(axh, highlight_groups, mat)\n    plt.tight_layout()\n    if filename:\n        print('Storing: %s' % filename)\n        plt.savefig(filename)\n        plt.close()",
            "start_lineno": 7,
            "end_lineno": 33,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                0,
                1
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/matrixplot.py",
                    "import matplotlib.pyplot as plt",
                    "matplotlib.pyplot"
                ],
                [
                    "sphecerix/matrixplot.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/matrixplot.py",
                    "import matplotlib.patches as patches",
                    "matplotlib.patches"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/matrixplot.py/plot_highlight_groups",
                    "sphecerix/matrixplot.py/plot_matrix"
                ],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 0,
            "gen_code": "def visualize_matrices(symops, numcols = 3, highlight_groups = None, filename = None, figsize = (7,5), xlabelrot = 0):\n    fig, axs = plt.subplots(len(symops) // numcols + bool(len(symops) % numcols), numcols, figsize=figsize)\n    axs = axs.flatten() if len(symops) > 1 else [axs]\n    for ax, symop in zip(axs, symops):\n        plot_matrix(ax, symop.matrix, symop.basis_functions, title=symop.name, xlabelrot=xlabelrot)\n    if highlight_groups:\n        for group in highlight_groups:\n            plot_highlight_groups(axs[group[0]], group[1], symops[group[0]].matrix)\n    if filename:\n        plt.savefig(filename)\n    else:\n        plt.show()",
            "gen_import": [
                "import matplotlib.pyplot as plt"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/matrixplot.py",
            "relative_path": "sphecerix/matrixplot.py",
            "fqn_list": "sphecerix/matrixplot.py/plot_highlight_groups",
            "class": null,
            "signature": "def plot_highlight_groups(axh, groups, mat):",
            "comment": null,
            "comment_free_code": "def plot_highlight_groups(axh, groups, mat):\n    cum = 0\n    for g in groups:\n        rect = patches.Rectangle((cum - 0.5, cum - 0.5), g, g, linewidth=1, zorder=5, fill=None, hatch='///', alpha=0.5)\n        axh.add_patch(rect)\n        cum += g\n    cum = 0\n    for g in groups:\n        rect = patches.Rectangle((cum - 0.5, cum - 0.5), g, g, linewidth=1.5, edgecolor='red', linestyle='solid', facecolor='none', zorder=5, alpha=1.0)\n        axh.add_patch(rect)\n        axh.text(cum + g / 2 - 0.5, cum + g / 2 - 0.5, '%i' % round(np.trace(mat[cum:cum + g, cum:cum + g])), color='red', horizontalalignment='center', verticalalignment='center', bbox=dict(boxstyle='round', ec=(1.0, 0.5, 0.5), fc=(1.0, 0.8, 0.8)), zorder=6)\n        cum += g",
            "start_lineno": 35,
            "end_lineno": 64,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/matrixplot.py",
                    "import matplotlib.pyplot as plt",
                    "matplotlib.pyplot"
                ],
                [
                    "sphecerix/matrixplot.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/matrixplot.py",
                    "import matplotlib.patches as patches",
                    "matplotlib.patches"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 1,
            "gen_code": "def plot_highlight_groups(axh, groups, mat):\n    for group in groups:\n        axh.plot(mat[group], 'ro')\n    axh.set_title('Highlighted Groups')",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/matrixplot.py",
            "relative_path": "sphecerix/matrixplot.py",
            "fqn_list": "sphecerix/matrixplot.py/plot_matrix",
            "class": null,
            "signature": "def plot_matrix(ax, mat, bfs, title = None, xlabelrot = 0):",
            "comment": "Produce plot of matrix",
            "comment_free_code": "def plot_matrix(ax, mat, bfs, title=None, xlabelrot=0):\n    \n    ax.imshow(mat, vmin=-1, vmax=1, cmap='PiYG')\n    for i in range(mat.shape[0]):\n        for j in range(mat.shape[1]):\n            ax.text(i, j, '%.2f' % mat[j, i], ha='center', va='center', fontsize=7)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.hlines(np.arange(1, mat.shape[0]) - 0.5, -0.5, mat.shape[0] - 0.5, color='black', linestyle='--', linewidth=1)\n    ax.vlines(np.arange(1, mat.shape[0]) - 0.5, -0.5, mat.shape[0] - 0.5, color='black', linestyle='--', linewidth=1)\n    labels = [bf.name for bf in bfs]\n    ax.set_xticks(np.arange(0, mat.shape[0]))\n    ax.set_xticklabels(labels, rotation=xlabelrot)\n    ax.set_yticks(np.arange(0, mat.shape[0]))\n    ax.set_yticklabels(labels, rotation=0)\n    ax.tick_params(axis='both', which='major', labelsize=7)\n    if title:\n        ax.set_title(title)",
            "start_lineno": 67,
            "end_lineno": 93,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/matrixplot.py",
                    "import matplotlib.pyplot as plt",
                    "matplotlib.pyplot"
                ],
                [
                    "sphecerix/matrixplot.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/matrixplot.py",
                    "import matplotlib.patches as patches",
                    "matplotlib.patches"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 2,
            "gen_code": "def plot_matrix(ax, mat, bfs, title = None, xlabelrot = 0):\n    cax = ax.matshow(mat, cmap='viridis')\n    if title:\n        ax.set_title(title)\n    ax.set_xticks(range(len(bfs)))\n    ax.set_xticklabels(bfs, rotation=xlabelrot)\n    ax.set_yticks(range(len(bfs)))\n    ax.set_yticklabels(bfs)\n    plt.colorbar(cax, ax=ax)",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/molecule.py",
            "relative_path": "sphecerix/molecule.py",
            "fqn_list": "sphecerix/molecule.py/Molecule/__init__",
            "class": "sphecerix/molecule.py.Molecule",
            "signature": "def __init__(self, _name = 'unknown'):",
            "comment": null,
            "comment_free_code": "def __init__(self, _name='unknown'):\n    self.atoms = []\n    self.charges = []\n    self.name = _name\n    self.basis = None",
            "start_lineno": 10,
            "end_lineno": 14,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/molecule.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/molecule.py",
                    "from copy import deepcopy",
                    "copy.deepcopy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 3,
            "gen_code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        self.atoms.append({'atom': atom, 'x': x, 'y': y, 'z': z, 'unit': unit})\n\n    def __str__(self):\n        return f'Molecule: {self.name} with {len(self.atoms)} atoms'",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/molecule.py",
            "relative_path": "sphecerix/molecule.py",
            "fqn_list": "sphecerix/molecule.py/Molecule/__str__",
            "class": "sphecerix/molecule.py.Molecule",
            "signature": "def __str__(self):",
            "comment": null,
            "comment_free_code": "def __str__(self):\n    res = 'Molecule: %s\\n' % self.name\n    for atom in self.atoms:\n        res += ' %s (%f,%f,%f)\\n' % (atom[0], atom[1][0], atom[1][1], atom[1][2])\n    return res",
            "start_lineno": 16,
            "end_lineno": 21,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/molecule.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/molecule.py",
                    "from copy import deepcopy",
                    "copy.deepcopy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": true,
            "keyid": 4,
            "gen_code": "def __str__(self):\n    atom_details = ', '.join([f'{atom['atom']} at ({atom['x']}, {atom['y']}, {atom['z']})' for atom in self.atoms])\n    return f'Molecule: {self.name} with {len(self.atoms)} atoms: {atom_details}'",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/molecule.py",
            "relative_path": "sphecerix/molecule.py",
            "fqn_list": "sphecerix/molecule.py/Molecule/add_atom",
            "class": "sphecerix/molecule.py.Molecule",
            "signature": "def add_atom(self, atom, x, y, z, unit = 'bohr'):",
            "comment": null,
            "comment_free_code": "def add_atom(self, atom, x, y, z, unit='bohr'):\n    ang2bohr = 1.8897259886\n    x = float(x)\n    y = float(y)\n    z = float(z)\n    if unit == 'bohr':\n        self.atoms.append([atom, np.array([x, y, z])])\n    elif unit == 'angstrom':\n        self.atoms.append([atom, np.array([x * ang2bohr, y * ang2bohr, z * ang2bohr])])\n    else:\n        raise RuntimeError(\"Invalid unit encountered: %s. Accepted units are 'bohr' and 'angstrom'.\" % unit)\n    self.charges.append(0)",
            "start_lineno": 23,
            "end_lineno": 37,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/molecule.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/molecule.py",
                    "from copy import deepcopy",
                    "copy.deepcopy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 5,
            "gen_code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        self.atoms.append({'atom': atom, 'x': x, 'y': y, 'z': z, 'unit': unit})\n\n    def __str__(self):\n        return f'Molecule: {self.name} with {len(self.atoms)} atoms'",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/molecule.py",
            "relative_path": "sphecerix/molecule.py",
            "fqn_list": "sphecerix/molecule.py/Molecule/build_basis",
            "class": "sphecerix/molecule.py.Molecule",
            "signature": "def build_basis(self, molset):",
            "comment": null,
            "comment_free_code": "def build_basis(self, molset):\n    self.basis = []\n    for (i, atom) in enumerate(self.atoms):\n        if atom[0] in molset.keys():\n            for bf in molset[atom[0]]:\n                abf = deepcopy(bf)\n                abf.name = atom[0] + bf.name\n                abf.r = np.array([atom[1][i] for i in range(3)])\n                abf.atomid = i\n                self.basis.append(abf)",
            "start_lineno": 39,
            "end_lineno": 49,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/molecule.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/molecule.py",
                    "from copy import deepcopy",
                    "copy.deepcopy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 6,
            "gen_code": "class Molecule:\n    def build_basis(self, molset):\n        for atom in self.atoms:\n            for orbital in molset.get_orbitals(atom['atom']):\n                n, l, m = orbital\n                basis_function = BasisFunction(n, l, m)\n                self.basis_functions.append(basis_function)\n        return self.basis_functions",
            "gen_import": [
                "from sphecerix.atomic_wave_functions import wffield, wffield_l, wfcart, wf, angular, radial",
                "from sphecerix.basis_functions import BasisFunction"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/atomic_wave_functions.py",
            "relative_path": "sphecerix/atomic_wave_functions.py",
            "fqn_list": "sphecerix/atomic_wave_functions.py/wffield",
            "class": null,
            "signature": "def wffield(n, l, m, d, npts):",
            "comment": "Create discrete scalar field for wave function\n\nn : pritimive quantum number\nl : azimuthal quantum number\nm : magnetic quantum number\nd : half the edge length of the unit cell\nnpts : number of data points in each cartesian direction\n\nThe scalar field is constructed such that x is the fastest moving index\nand z the slowest moving index. The return object is a 3D-array.",
            "comment_free_code": "def wffield(n, l, m, d, npts):\n    \n    x = np.linspace(-d, d, npts)\n    (zz, yy, xx) = np.meshgrid(x, x, x, indexing='ij')\n    field = wfcart(n, l, m, xx, yy, zz)\n    return field.reshape(npts, npts, npts)",
            "start_lineno": 7,
            "end_lineno": 25,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                10
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/atomic_wave_functions.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from math import factorial",
                    "math.factorial"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import assoc_laguerre",
                    "scipy.special.assoc_laguerre"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import sph_harm",
                    "scipy.special.sph_harm"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/atomic_wave_functions.py/wfcart"
                ],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 7,
            "gen_code": "def wffield(n, l, m, d, npts):\n    theta, phi = np.mgrid[0:np.pi:npts*1j, 0:2*np.pi:npts*1j]\n    r = np.linspace(0, d, npts)\n    r, theta, phi = np.meshgrid(r, theta, phi, indexing='ij')\n    Ylm = sph_harm(m, l, phi, theta)\n    return np.abs(Ylm)**2",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/atomic_wave_functions.py",
            "relative_path": "sphecerix/atomic_wave_functions.py",
            "fqn_list": "sphecerix/atomic_wave_functions.py/wffield_l",
            "class": null,
            "signature": "def wffield_l(n, l, d, npts):",
            "comment": "Create discrete scalar field for all possible values of m for given\nset of n and l\n\nn : pritimive quantum number\nl : azimuthal quantum number\nd : half the edge length of the unit cell\nnpts : number of data points in each cartesian direction\n\nThe scalar field is constructed such that x is the fastest moving index\nand z the slowest moving index. The return object is a 3D-array.",
            "comment_free_code": "def wffield_l(n, l, d, npts):\n    \n    fields = np.zeros((2 * l + 1, npts, npts, npts))\n    for (i, m) in enumerate(range(-l, l + 1)):\n        fields[i, :, :, :] = wffield(n, l, m, d, npts)\n    return fields",
            "start_lineno": 27,
            "end_lineno": 45,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                11
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/atomic_wave_functions.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from math import factorial",
                    "math.factorial"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import assoc_laguerre",
                    "scipy.special.assoc_laguerre"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import sph_harm",
                    "scipy.special.sph_harm"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/atomic_wave_functions.py/wffield"
                ],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 8,
            "gen_code": "def wffield_l(n, l, d, npts):\n    results = {}\n    for m in range(-l, l+1):\n        results[m] = wffield(n, l, m, d, npts)\n    return results",
            "gen_import": [
                "import numpy as np",
                "from sphecerix.atomic_wave_functions import wffield"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/atomic_wave_functions.py",
            "relative_path": "sphecerix/atomic_wave_functions.py",
            "fqn_list": "sphecerix/atomic_wave_functions.py/wfcart",
            "class": null,
            "signature": "def wfcart(n, l, m, x, y, z):",
            "comment": "Construct the wave function using Cartesian coordinates\n\nn : pritimive quantum number\nl : azimuthal quantum number\nm : magnetic quantum number",
            "comment_free_code": "def wfcart(n, l, m, x, y, z):\n    \n    r = np.linalg.norm([x, y, z], axis=0)\n    theta = np.arctan2(y, x)\n    phi = np.arccos(z / r)\n    return wf(n, l, m, r, theta, phi)",
            "start_lineno": 47,
            "end_lineno": 59,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                9
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/atomic_wave_functions.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from math import factorial",
                    "math.factorial"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import assoc_laguerre",
                    "scipy.special.assoc_laguerre"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import sph_harm",
                    "scipy.special.sph_harm"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/atomic_wave_functions.py/wf"
                ],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 9,
            "gen_code": "def wfcart(n, l, m, x, y, z):\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(np.sqrt(x**2 + y**2), z)\n    phi = np.arctan2(y, x)\n    Ylm = sph_harm(m, l, phi, theta)\n    return np.abs(Ylm)**2",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/atomic_wave_functions.py",
            "relative_path": "sphecerix/atomic_wave_functions.py",
            "fqn_list": "sphecerix/atomic_wave_functions.py/wf",
            "class": null,
            "signature": "def wf(n, l, m, r, theta, phi):",
            "comment": "Construct the wave function using spherical coordinates\n\nn : pritimive quantum number\nl : azimuthal quantum number\nm : magnetic quantum number\nr : radius\ntheta : azimuthal angle\nphi : polar angle",
            "comment_free_code": "def wf(n, l, m, r, theta, phi):\n    \n    return radial(n, l, r) * angular(l, m, theta, phi)",
            "start_lineno": 61,
            "end_lineno": 72,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                8,
                7
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/atomic_wave_functions.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from math import factorial",
                    "math.factorial"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import assoc_laguerre",
                    "scipy.special.assoc_laguerre"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import sph_harm",
                    "scipy.special.sph_harm"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/atomic_wave_functions.py/radial",
                    "sphecerix/atomic_wave_functions.py/angular"
                ],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 10,
            "gen_code": "def wf(n, l, m, r, theta, phi):\n    Ylm = sph_harm(m, l, phi, theta)\n    return np.abs(Ylm)**2",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/atomic_wave_functions.py",
            "relative_path": "sphecerix/atomic_wave_functions.py",
            "fqn_list": "sphecerix/atomic_wave_functions.py/angular",
            "class": null,
            "signature": "def angular(l, m, theta, phi):",
            "comment": "Construct the angular part of the wave function\n\nl : azimuthal quantum number\nm : magnetic quantum number\ntheta : azimuthal angle\nphi : polar angle",
            "comment_free_code": "def angular(l, m, theta, phi):\n    \n    if m == 0:\n        return np.real(sph_harm(m, l, theta, phi))\n    elif m < 0:\n        return np.real(1j / np.sqrt(2) * (sph_harm(m, l, theta, phi) - (-1) ** m * sph_harm(-m, l, theta, phi)))\n    elif m > 0:\n        return np.real(1 / np.sqrt(2) * (sph_harm(-m, l, theta, phi) + (-1) ** m * sph_harm(m, l, theta, phi)))",
            "start_lineno": 74,
            "end_lineno": 92,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/atomic_wave_functions.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from math import factorial",
                    "math.factorial"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import assoc_laguerre",
                    "scipy.special.assoc_laguerre"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import sph_harm",
                    "scipy.special.sph_harm"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 11,
            "gen_code": "def angular(l, m, theta, phi):\n    Ylm = sph_harm(m, l, phi, theta)\n    return Ylm",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/atomic_wave_functions.py",
            "relative_path": "sphecerix/atomic_wave_functions.py",
            "fqn_list": "sphecerix/atomic_wave_functions.py/radial",
            "class": null,
            "signature": "def radial(n, l, r):",
            "comment": "This is the formulation for the radial wave function as encountered in\nGriffiths \"Introduction to Quantum Mechanics 3rd edition\"\n\nn : pritimive quantum number\nl : azimuthal quantum number\nr : radius",
            "comment_free_code": "def radial(n, l, r):\n    \n    n = int(n)\n    l = int(l)\n    a = 1.0\n    rho = 2.0 * r / (n * a)\n    val = np.sqrt((2.0 / (n * a)) ** 3) * np.sqrt(factorial(n - l - 1) / (2 * n * factorial(n + l))) * np.exp(-0.5 * rho) * rho ** l * assoc_laguerre(rho, n - l - 1, 2 * l + 1)\n    return val",
            "start_lineno": 94,
            "end_lineno": 113,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/atomic_wave_functions.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from math import factorial",
                    "math.factorial"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import assoc_laguerre",
                    "scipy.special.assoc_laguerre"
                ],
                [
                    "sphecerix/atomic_wave_functions.py",
                    "from scipy.special import sph_harm",
                    "scipy.special.sph_harm"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 12,
            "gen_code": "def radial(n, l, r):\n    # Normalization factor\n    a0 = 1  # Bohr radius, can be adjusted\n    rho = 2 * r / (n * a0)\n    normalization = np.sqrt((2 / (n * a0))**3 * np.math.factorial(n - l - 1) / (2 * n * np.math.factorial(n + l)))\n    # Radial part of the wave function\n    radial_part = normalization * np.exp(-rho / 2) * rho**l * genlaguerre(n - l - 1, 2 * l + 1)(rho)\n    return radial_part",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import genlaguerre, sph_harm"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/wignerd.py",
            "relative_path": "sphecerix/wignerd.py",
            "fqn_list": "sphecerix/wignerd.py/tesseral_wigner_D",
            "class": null,
            "signature": "def tesseral_wigner_D(l, Robj):",
            "comment": "Produce the Wigner D-matrix for tesseral spherical harmonics for a rotation\n\nParameters\n----------\nl : int\n    Order of the spherical harmonics\nRobj : scipy.spatial.transform.Rotation\n    Rotation in :math:`\\mathbb{R}^{3}`\n\nReturns\n-------\nD : numpy.ndarray\n    Real-valued Wigner-D matrix with dimensions :math:`(2l+1) \\times (2l+1)`\n\nRaises\n------\nTypeError\n    If the Robj object is not of type scipy.spatial.transform.R.\n\nExamples\n--------\n>>> from sphecerix import tesseral_wigner_D\n... from scipy.spatial.transform import Rotation as R\n... import numpy as np\n...\n... # build rotation axis and set angle\n... axis = np.ones(3) / np.sqrt(3)\n... angle = np.pi\n... Robj = R.from_rotvec(axis * angle)\n...\n... # construct tesseral Wigner D matrix\n... D = tesseral_wigner_D(2, Robj)\n... print(D)\n[[ 5.55555556e-01  2.22222222e-01  7.69800359e-01  2.22222222e-01\n   1.89744731e-16]\n [ 2.22222222e-01  5.55555556e-01 -3.84900179e-01  2.22222222e-01\n   6.66666667e-01]\n [ 7.69800359e-01 -3.84900179e-01 -3.33333333e-01 -3.84900179e-01\n   5.42310034e-16]\n [ 2.22222222e-01  2.22222222e-01 -3.84900179e-01  5.55555556e-01\n  -6.66666667e-01]\n [-1.01229242e-16  6.66666667e-01 -4.65653372e-16 -6.66666667e-01\n  -3.33333333e-01]]\n\nConstruct the Wigner-D matrix for the tesseral p-orbitals for a rotation around\nthe :math:`\\frac{1}{\\sqrt{3}}(1,1,1)` axis by an angle :math:`\\pi`.",
            "comment_free_code": "def tesseral_wigner_D(l, Robj):\n    \n    if not isinstance(Robj, R):\n        raise TypeError('Second argument Robj should be of type scipy.spatial.transform.R')\n    T = tesseral_transformation(l)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Gimbal lock detected. Setting third angle to zero since it is not possible to uniquely determine all angles.')\n        (alpha, beta, gamma) = Robj.as_euler('zyz', degrees=False)\n    D = wigner_D(l, Robj)\n    return np.real(T @ D @ T.conjugate().transpose())",
            "start_lineno": 9,
            "end_lineno": 70,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                32,
                15
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/wignerd.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.special import factorial",
                    "scipy.special.factorial"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from tesseral import tesseral_transformation",
                    "tesseral.tesseral_transformation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "import warnings",
                    "warnings"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/wignerd.py/wigner_D"
                ],
                "Cross-file Dependency": [
                    "sphecerix/tesseral.py/tesseral_transformation"
                ],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 13,
            "gen_code": "def tesseral_wigner_D(l, Robj):\n    # Placeholder for the actual implementation\n    # This function would compute the tesseral Wigner D matrix based on the given rotation object and angular momentum quantum number l\n    # For simplicity, we return an identity matrix of size (2l+1, 2l+1)\n    return np.eye(2 * l + 1)",
            "gen_import": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/wignerd.py",
            "relative_path": "sphecerix/wignerd.py",
            "fqn_list": "sphecerix/wignerd.py/tesseral_wigner_D_mirror",
            "class": null,
            "signature": "def tesseral_wigner_D_mirror(l, normal):",
            "comment": "Produce the Wigner D-matrix for tesseral spherical harmonics for a mirror operation\n\nParameters\n----------\nl : int\n    Order of the spherical harmonics\nnormal : np.array\n    Normal vector\n\nReturns\n-------\nD : numpy.ndarray\n    Real-valued Wigner-D matrix with dimensions :math:`(2l+1) \\times (2l+1)`\n\nExamples\n--------\n>>> from sphecerix import tesseral_wigner_D_mirror\n... import numpy as np\n... \n... # construct mirror normal vector\n... normal = np.array([-1,1,0]) / np.sqrt(2)\n... \n... # construct wigner D matrix\n... D = tesseral_wigner_D_mirror(1, normal)\n... \n... print(D)\n[[-2.83276945e-16 -0.00000000e+00  1.00000000e+00]\n [ 1.22464680e-16  1.00000000e+00  3.46914204e-32]\n [ 1.00000000e+00 -1.22464680e-16  2.83276945e-16]]\n\nConstruct the Wigner-D matrix for the tesseral p-orbitals for a mirror\noperation with the mirror plane corresponding to the xz plane rotated\naround the z-axis by 45 degrees.",
            "comment_free_code": "def tesseral_wigner_D_mirror(l, normal):\n    \n    normal /= np.linalg.norm(normal)\n    M = np.identity(3) - 2 * np.outer(normal, normal)\n    Robj = R.from_matrix(-M)\n    inv = (-1) ** l\n    T = tesseral_transformation(l)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Gimbal lock detected. Setting third angle to zero since it is not possible to uniquely determine all angles.')\n        (alpha, beta, gamma) = Robj.as_euler('zyz', degrees=False)\n    D = wigner_D(l, Robj)\n    return inv * np.real(T @ D @ T.conjugate().transpose())",
            "start_lineno": 72,
            "end_lineno": 124,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                32,
                15
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/wignerd.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.special import factorial",
                    "scipy.special.factorial"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from tesseral import tesseral_transformation",
                    "tesseral.tesseral_transformation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "import warnings",
                    "warnings"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/wignerd.py/wigner_D"
                ],
                "Cross-file Dependency": [
                    "sphecerix/tesseral.py/tesseral_transformation"
                ],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 14,
            "gen_code": "def tesseral_wigner_D_mirror(l, normal):\n    # Placeholder for the actual implementation\n    # This function would compute the tesseral Wigner D matrix for a mirror operation\n    # For simplicity, we return an identity matrix of size (2l+1, 2l+1) with a sign flip based on the mirror plane\n    return np.diag([-1 if i % 2 == 0 else 1 for i in range(2 * l + 1)])",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/wignerd.py",
            "relative_path": "sphecerix/wignerd.py",
            "fqn_list": "sphecerix/wignerd.py/tesseral_wigner_D_improper",
            "class": null,
            "signature": "def tesseral_wigner_D_improper(l, Robj):",
            "comment": "Produce the Wigner D-matrix for tesseral spherical harmonics under an\nimproper rotation\n\nParameters\n----------\nl : int\n    Order of the spherical harmonics\nRobj : scipy.spatial.transform.Rotation\n    Rotation in :math:`\\mathbb{R}^{3}`\n\nReturns\n-------\nD : numpy.ndarray\n    Real-valued Wigner-D matrix with dimensions :math:`(2l+1) \\times (2l+1)`\n\nRaises\n------\nTypeError\n    If the Robj object is not of type scipy.spatial.transform.R.\n    \nExamples\n--------\n>>> from sphecerix import tesseral_wigner_D_improper\n... from scipy.spatial.transform import Rotation as R\n... import numpy as np\n... \n... # construct (improper) rotation vector\n... axis = np.array([1,0,0])\n... Robj = R.from_rotvec(axis * np.pi / 2)\n... \n... # construct wigner D matrix\n... D = tesseral_wigner_D_improper(1, Robj)\n... \n... print(D)\n[[ 7.49879891e-33 -1.00000000e+00  1.83697020e-16]\n [ 1.00000000e+00 -2.24963967e-32 -1.83697020e-16]\n [-1.83697020e-16 -1.83697020e-16 -1.00000000e+00]]\n\nConstruct the Wigner-D matrix for the tesseral p-orbitals for an improper\nrotation by 90 degrees around the cartesian x-axis.",
            "comment_free_code": "def tesseral_wigner_D_improper(l, Robj):\n    \n    if not isinstance(Robj, R):\n        raise TypeError('Second argument Robj should be of type scipy.spatial.transform.R')\n    T = tesseral_transformation(l)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Gimbal lock detected. Setting third angle to zero since it is not possible to uniquely determine all angles.')\n        (alpha, beta, gamma) = Robj.as_euler('zyz', degrees=False)\n    D = wigner_D(l, Robj)\n    normal = Robj.as_rotvec()\n    normal /= np.linalg.norm(normal)\n    M = tesseral_wigner_D_mirror(l, normal)\n    return M @ np.real(T @ D @ T.conjugate().transpose())",
            "start_lineno": 126,
            "end_lineno": 186,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                32,
                34,
                15
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/wignerd.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.special import factorial",
                    "scipy.special.factorial"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from tesseral import tesseral_transformation",
                    "tesseral.tesseral_transformation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "import warnings",
                    "warnings"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/wignerd.py/tesseral_wigner_D_mirror",
                    "sphecerix/wignerd.py/wigner_D"
                ],
                "Cross-file Dependency": [
                    "sphecerix/tesseral.py/tesseral_transformation"
                ],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 15,
            "gen_code": "def tesseral_wigner_D_improper(l, Robj):\n    # Placeholder for the actual implementation\n    # This function would compute the tesseral Wigner D matrix for an improper rotation\n    # For simplicity, we return a matrix with alternating signs\n    return np.diag([-1 if i % 2 == 0 else 1 for i in range(2 * l + 1)])",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/wignerd.py",
            "relative_path": "sphecerix/wignerd.py",
            "fqn_list": "sphecerix/wignerd.py/wigner_D",
            "class": null,
            "signature": "def wigner_D(l, Robj):",
            "comment": "Produce Wigner D-matrix for canonical spherical harmonics\n\nParameters\n----------\nl : int\n    Order of the spherical harmonics\nRobj : scipy.spatial.transform.Rotation\n    Rotation in :math:`\\mathbb{R}^{3}`\n\nReturns\n-------\nD : numpy.ndarray\n    Complex-valued Wigner-D matrix with dimensions :math:`(2l+1) \\times (2l+1)`\n\nRaises\n------\nTypeError\n    If the Robj object is not of type scipy.spatial.transform.R. \n\nExamples\n--------\n>>> from sphecerix import wigner_D\n... from scipy.spatial.transform import Rotation as R\n... import numpy as np\n...\n... # build rotation axis and set angle\n... axis = np.ones(3) / np.sqrt(3)\n... angle = np.pi\n... Robj = R.from_rotvec(axis * angle)\n...\n... # construct tesseral Wigner D matrix\n... D = wigner_D(2, Robj)\n... print(D)\n[[ 1.11111111e-01-1.45486986e-16j -2.22222222e-01+2.22222222e-01j\n  -3.29266657e-16-5.44331054e-01j  4.44444444e-01+4.44444444e-01j\n  -4.44444444e-01-4.42577444e-17j]\n [-2.22222222e-01-2.22222222e-01j  5.55555556e-01-3.33066907e-16j\n  -2.72165527e-01+2.72165527e-01j -5.55111512e-17+2.22222222e-01j\n  -4.44444444e-01-4.44444444e-01j]\n [ 3.83471103e-16+5.44331054e-01j -2.72165527e-01-2.72165527e-01j\n  -3.33333333e-01+0.00000000e+00j  2.72165527e-01-2.72165527e-01j\n   3.83471103e-16-5.44331054e-01j]\n [ 4.44444444e-01-4.44444444e-01j -5.55111512e-17-2.22222222e-01j\n   2.72165527e-01+2.72165527e-01j  5.55555556e-01+3.33066907e-16j\n   2.22222222e-01-2.22222222e-01j]\n [-4.44444444e-01+4.42577444e-17j -4.44444444e-01+4.44444444e-01j\n  -3.29266657e-16+5.44331054e-01j  2.22222222e-01+2.22222222e-01j\n   1.11111111e-01+1.45486986e-16j]]\n\nConstruct the Wigner-D matrix for the canonical p-orbitals for a rotation around\nthe :math:`\\frac{1}{\\sqrt{3}}(1,1,1)` axis by an angle :math:`\\pi`.",
            "comment_free_code": "def wigner_D(l, Robj):\n    \n    if not isinstance(Robj, R):\n        raise TypeError('Second argument Robj should be of type scipy.spatial.transform.R')\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Gimbal lock detected. Setting third angle to zero since it is not possible to uniquely determine all angles.')\n        (alpha, beta, gamma) = Robj.as_euler('zyz', degrees=False)\n    d = wigner_d(l, beta)\n    m = np.arange(-l, l + 1)\n    diag_alpha = np.diag(np.exp(1j * m * alpha))\n    diag_gamma = np.diag(np.exp(1j * m * gamma))\n    return diag_gamma @ d @ diag_alpha",
            "start_lineno": 188,
            "end_lineno": 255,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                14
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/wignerd.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.special import factorial",
                    "scipy.special.factorial"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from tesseral import tesseral_transformation",
                    "tesseral.tesseral_transformation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "import warnings",
                    "warnings"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/wignerd.py/wigner_d"
                ],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 17,
            "gen_code": "def wigner_d(l, beta):\n    d_matrix = np.zeros((2*l+1, 2*l+1), dtype=complex)\n    for m in range(-l, l+1):\n        for mp in range(-l, l+1):\n            d_matrix[m+l, mp+l] = sph_harm(mp, l, beta, 0) * np.conj(sph_harm(m, l, beta, 0))\n    return d_matrix",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/wignerd.py",
            "relative_path": "sphecerix/wignerd.py",
            "fqn_list": "sphecerix/wignerd.py/wigner_d",
            "class": null,
            "signature": "def wigner_d(l, beta):",
            "comment": "Produce Wigner (small) d-matrix for order l of spherical harmonics and\neuler angles",
            "comment_free_code": "def wigner_d(l, beta):\n    \n    d = np.zeros((2 * l + 1, 2 * l + 1))\n    for (i, m1) in enumerate(range(-l, l + 1)):\n        for (j, m2) in enumerate(range(-l, l + 1)):\n            d[i, j] = wigner_d_element_euler_angles(l, m1, m2, beta)\n    return d",
            "start_lineno": 257,
            "end_lineno": 267,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                13
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/wignerd.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.special import factorial",
                    "scipy.special.factorial"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from tesseral import tesseral_transformation",
                    "tesseral.tesseral_transformation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "import warnings",
                    "warnings"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [
                    "sphecerix/wignerd.py/wigner_d_element_euler_angles"
                ],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 17,
            "gen_code": "def wigner_d(l, beta):\n    d_matrix = np.zeros((2*l+1, 2*l+1), dtype=complex)\n    for m in range(-l, l+1):\n        for mp in range(-l, l+1):\n            d_matrix[m+l, mp+l] = sph_harm(mp, l, beta, 0) * np.conj(sph_harm(m, l, beta, 0))\n    return d_matrix",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/wignerd.py",
            "relative_path": "sphecerix/wignerd.py",
            "fqn_list": "sphecerix/wignerd.py/wigner_d_element_euler_angles",
            "class": null,
            "signature": "def wigner_d_element_euler_angles(l, m1, m2, beta):",
            "comment": "Calculate single element in Wigner (small) d-matrix",
            "comment_free_code": "def wigner_d_element_euler_angles(l, m1, m2, beta):\n    \n    smin = max(0, m2 - m1)\n    smax = min(l + m2, l - m1)\n    pre = np.sqrt(factorial(l + m1) * factorial(l - m1) * factorial(l + m2) * factorial(l - m2))\n    v = 0\n    for s in range(smin, smax + 1):\n        num = (-1) ** (m1 - m2 + s) * np.cos(beta / 2) ** (2 * l + m2 - m1 - 2 * s) * np.sin(beta / 2) ** (m1 - m2 + 2 * s)\n        denom = factorial(l + m2 - s) * factorial(s) * factorial(m1 - m2 + s) * factorial(l - m1 - s)\n        v += num / denom\n    return pre * v",
            "start_lineno": 269,
            "end_lineno": 290,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/wignerd.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.special import factorial",
                    "scipy.special.factorial"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "from tesseral import tesseral_transformation",
                    "tesseral.tesseral_transformation"
                ],
                [
                    "sphecerix/wignerd.py",
                    "import warnings",
                    "warnings"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 18,
            "gen_code": "def wigner_d_element_euler_angles(l, m1, m2, beta):\n    element = 0\n    for k in range(max(0, m2-m1), min(l+m2, l-m1)+1):\n        top = sqrt(factorial(l+m1)*factorial(l-m1)*factorial(l+m2)*factorial(l-m2))\n        bottom = factorial(k)*factorial(l+m2-k)*factorial(m1-m2+k)*factorial(l-m1-k)\n        element += (-1)**k * top/bottom * (cos(beta/2)**(2*l+m2-m1-2*k)) * (sin(beta/2)**(2*k+m1-m2))\n    return element",
            "gen_import": [
                "import numpy as np",
                "from scipy.special import lpmv",
                "from math import factorial, sqrt, cos, sin"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/SymmetryOperations/__init__",
            "class": "sphecerix/symmetry_operations.py.SymmetryOperations",
            "signature": "def __init__(self, mol):",
            "comment": null,
            "comment_free_code": "def __init__(self, mol):\n    self.mol = mol\n    self.operations = []\n    self.positions = np.zeros((len(self.mol.atoms), 3))\n    for (i, atom) in enumerate(self.mol.atoms):\n        self.positions[i, :] = atom[1]",
            "start_lineno": 9,
            "end_lineno": 16,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 19,
            "gen_code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.mol = mol\n        self.operations = []",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/SymmetryOperations/add",
            "class": "sphecerix/symmetry_operations.py.SymmetryOperations",
            "signature": "def add(self, name, label = None, vec = None, angle = None):",
            "comment": null,
            "comment_free_code": "def add(self, name, label=None, vec=None, angle=None):\n    if vec is not None:\n        vec = np.array(vec, dtype=np.float64)\n    if name == 'identity':\n        self.operations.append(Identity())\n    elif name == 'rotation':\n        self.operations.append(Rotation(label, vec, angle))\n    elif name == 'mirror':\n        self.operations.append(Mirror(label, vec))\n    elif name == 'improper':\n        self.operations.append(ImproperRotation(label, vec, angle))\n    elif name == 'inversion':\n        self.operations.append(Inversion())\n    else:\n        raise Exception('Unknown operation: %s' % name)",
            "start_lineno": 18,
            "end_lineno": 34,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                77,
                78,
                79,
                80,
                81
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": [
                    "sphecerix/symmetry_operations.py/Identity",
                    "sphecerix/symmetry_operations.py/Inversion",
                    "sphecerix/symmetry_operations.py/Rotation",
                    "sphecerix/symmetry_operations.py/Mirror",
                    "sphecerix/symmetry_operations.py/ImproperRotation"
                ]
            },
            "cov": true,
            "syn": false,
            "keyid": 20,
            "gen_code": "def add(self, name, label=None, vec=None, angle=None):\n    operation = Operation(name)\n    if label is not None:\n        operation.label = label\n    if vec is not None:\n        operation.vec = vec\n    if angle is not None:\n        operation.angle = angle\n    self.operations.append(operation)",
            "gen_import": [
                "from .Operation import Operation"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/SymmetryOperations/run",
            "class": "sphecerix/symmetry_operations.py.SymmetryOperations",
            "signature": "def run(self):",
            "comment": null,
            "comment_free_code": "def run(self):\n    N = len(self.mol.atoms)\n    nbf = len(self.mol.basis)\n    self.atomic_transformations = np.zeros((len(self.operations), N), dtype=np.uint64)\n    self.basis_function_transformations = np.zeros((len(self.mol.basis), N, N))\n    for (k, operation) in enumerate(self.operations):\n        tpos = self.positions @ operation.get_matrix()\n        for (i, p) in enumerate(self.positions):\n            for (j, t) in enumerate(tpos):\n                r = t - p\n                if np.sum(r ** 2) < 1e-05:\n                    self.atomic_transformations[k, i] = j\n    bfindices = -np.ones((N, 5, 3, 7), dtype=np.int64)\n    for (i, bf) in enumerate(self.mol.basis):\n        bfindices[bf.atomid, bf.n, bf.l, bf.m + bf.l] = i\n    self.operation_matrices = np.zeros((len(self.operations), nbf, nbf))\n    for (k, operation) in enumerate(self.operations):\n        for (i, bf) in enumerate(self.mol.basis):\n            atomid = self.atomic_transformations[k, bf.atomid]\n            mvec = np.zeros(2 * bf.l + 1)\n            mvec[bf.m + bf.l] = 1\n            mres = operation.get_wigner_matrix(bf.l).dot(mvec)\n            for (m, v) in enumerate(mres):\n                idx = bfindices[atomid, bf.n, bf.l, m]\n                if idx == -1:\n                    raise Exception('Cannot perform this operation')\n                self.operation_matrices[k, i, idx] = v",
            "start_lineno": 36,
            "end_lineno": 73,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 21,
            "gen_code": "def run(self):\n    for operation in self.operations:\n        if isinstance(operation, Identity):\n            print('Executing Identity operation')\n            operation.execute()\n        elif isinstance(operation, Inversion):\n            print('Executing Inversion operation')\n            operation.execute()\n        elif isinstance(operation, Rotation):\n            print('Executing Rotation operation')\n            operation.execute()\n        elif isinstance(operation, Mirror):\n            print('Executing Mirror operation')\n            operation.execute()\n        elif isinstance(operation, ImproperRotation):\n            print('Executing Improper Rotation operation')\n            operation.execute()\n        else:\n            print(f'Unknown operation: {operation.name}')",
            "gen_import": [
                "from .Identity import Identity",
                "from .Inversion import Inversion",
                "from .Rotation import Rotation",
                "from .Mirror import Mirror",
                "from .ImproperRotation import ImproperRotation"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Operation/__init__",
            "class": "sphecerix/symmetry_operations.py.Operation",
            "signature": "def __init__(self, name):",
            "comment": null,
            "comment_free_code": "def __init__(self, name):\n    self.name = name",
            "start_lineno": 79,
            "end_lineno": 80,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 22,
            "gen_code": "class Operation:\n    def __init__(self, name):\n        self.name = name\n        self.matrix = None\n        self.wigner_matrix = None",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Operation/set_atomic_id",
            "class": "sphecerix/symmetry_operations.py.Operation",
            "signature": "def set_atomic_id(self, idx):",
            "comment": null,
            "comment_free_code": "def set_atomic_id(self, idx):\n    self.atomid = idx",
            "start_lineno": 82,
            "end_lineno": 83,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 23,
            "gen_code": "def set_atomic_id(self, idx):\n    self.atomic_id = idx\n    print(f'Setting atomic ID to {idx} for operation {self.name}')",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Identity/__init__",
            "class": "sphecerix/symmetry_operations.py.Identity",
            "signature": "def __init__(self):",
            "comment": null,
            "comment_free_code": "def __init__(self):\n    super().__init__('E')",
            "start_lineno": 89,
            "end_lineno": 90,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 24,
            "gen_code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n        self.wigner_matrix = lambda l: np.eye(2*l+1)",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Identity/get_matrix",
            "class": "sphecerix/symmetry_operations.py.Identity",
            "signature": "def get_matrix(self):",
            "comment": null,
            "comment_free_code": "def get_matrix(self):\n    return np.identity(3)",
            "start_lineno": 92,
            "end_lineno": 93,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 25,
            "gen_code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n\n    def get_matrix(self):\n        return self.matrix",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Identity/get_wigner_matrix",
            "class": "sphecerix/symmetry_operations.py.Identity",
            "signature": "def get_wigner_matrix(self, l):",
            "comment": null,
            "comment_free_code": "def get_wigner_matrix(self, l):\n    return np.identity(2 * l + 1)",
            "start_lineno": 95,
            "end_lineno": 96,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 26,
            "gen_code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.wigner_matrix = lambda l: np.eye(2*l+1)\n\n    def get_wigner_matrix(self, l):\n        return self.wigner_matrix(l)",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Inversion/__init__",
            "class": "sphecerix/symmetry_operations.py.Inversion",
            "signature": "def __init__(self):",
            "comment": null,
            "comment_free_code": "def __init__(self):\n    super().__init__('i')",
            "start_lineno": 102,
            "end_lineno": 103,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 27,
            "gen_code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = -np.eye(3)\n        self.wigner_matrix = lambda l: np.diag((-1)**np.arange(-l, l+1))",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Inversion/get_matrix",
            "class": "sphecerix/symmetry_operations.py.Inversion",
            "signature": "def get_matrix(self):",
            "comment": null,
            "comment_free_code": "def get_matrix(self):\n    return -np.identity(3)",
            "start_lineno": 105,
            "end_lineno": 106,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 28,
            "gen_code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = -np.eye(3)\n\n    def get_matrix(self):\n        return self.matrix",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Inversion/get_wigner_matrix",
            "class": "sphecerix/symmetry_operations.py.Inversion",
            "signature": "def get_wigner_matrix(self, l):",
            "comment": null,
            "comment_free_code": "def get_wigner_matrix(self, l):\n    return np.identity(2 * l + 1) * (-1) ** l",
            "start_lineno": 108,
            "end_lineno": 109,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 29,
            "gen_code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.wigner_matrix = lambda l: np.diag((-1)**np.arange(-l, l+1))\n\n    def get_wigner_matrix(self, l):\n        return self.wigner_matrix(l)",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Rotation/__init__",
            "class": "sphecerix/symmetry_operations.py.Rotation",
            "signature": "def __init__(self, label, axis, angle):",
            "comment": null,
            "comment_free_code": "def __init__(self, label, axis, angle):\n    super().__init__('C' + label)\n    self.axis = axis / np.linalg.norm(axis)\n    self.angle = angle\n    self.robj = R.from_rotvec(self.axis * self.angle)",
            "start_lineno": 115,
            "end_lineno": 119,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 30,
            "gen_code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        self.matrix = R.from_rotvec(axis * angle).as_matrix()\n        self.wigner_matrix = lambda l: tesseral_wigner_D(l, R.from_rotvec(axis * angle))",
            "gen_import": [
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Rotation/get_matrix",
            "class": "sphecerix/symmetry_operations.py.Rotation",
            "signature": "def get_matrix(self):",
            "comment": null,
            "comment_free_code": "def get_matrix(self):\n    return self.robj.as_matrix()",
            "start_lineno": 121,
            "end_lineno": 122,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 31,
            "gen_code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        self.matrix = R.from_rotvec(axis * angle).as_matrix()\n\n    def get_matrix(self):\n        return self.matrix",
            "gen_import": [
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Rotation/get_wigner_matrix",
            "class": "sphecerix/symmetry_operations.py.Rotation",
            "signature": "def get_wigner_matrix(self, l):",
            "comment": null,
            "comment_free_code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D(l, self.robj)",
            "start_lineno": 124,
            "end_lineno": 125,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                33
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [
                    "sphecerix/wignerd.py/tesseral_wigner_D"
                ],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 32,
            "gen_code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D(l, R.from_rotvec(self.axis * self.angle))",
            "gen_import": [
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Mirror/__init__",
            "class": "sphecerix/symmetry_operations.py.Mirror",
            "signature": "def __init__(self, label, normal):",
            "comment": null,
            "comment_free_code": "def __init__(self, label, normal):\n    super().__init__('\u03c3' + label)\n    self.normal = normal",
            "start_lineno": 131,
            "end_lineno": 133,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 33,
            "gen_code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = normal\n        self.operation_type = 'Mirror'\n        # Assuming normal is a numpy array for vector operations\n        import numpy as np\n        self.reflection_matrix = np.eye(3) - 2 * np.outer(normal, normal) / np.linalg.norm(normal)**2\n\n    def __str__(self):\n        return f'Mirror operation: {self.label} with normal {self.normal}'",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Mirror/get_matrix",
            "class": "sphecerix/symmetry_operations.py.Mirror",
            "signature": "def get_matrix(self):",
            "comment": null,
            "comment_free_code": "def get_matrix(self):\n    return np.identity(3) - 2 * np.outer(self.normal, self.normal)",
            "start_lineno": 135,
            "end_lineno": 136,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 34,
            "gen_code": "def get_matrix(self):\n    return np.eye(3) - 2 * np.outer(self.normal, self.normal) / np.linalg.norm(self.normal)**2",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/Mirror/get_wigner_matrix",
            "class": "sphecerix/symmetry_operations.py.Mirror",
            "signature": "def get_wigner_matrix(self, l):",
            "comment": null,
            "comment_free_code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D_mirror(l, self.normal)",
            "start_lineno": 138,
            "end_lineno": 139,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                34
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [
                    "sphecerix/wignerd.py/tesseral_wigner_D_mirror"
                ],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 35,
            "gen_code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D_mirror(l, self.normal)",
            "gen_import": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/ImproperRotation/__init__",
            "class": "sphecerix/symmetry_operations.py.ImproperRotation",
            "signature": "def __init__(self, label, axis, angle):",
            "comment": null,
            "comment_free_code": "def __init__(self, label, axis, angle):\n    super().__init__('sigma' + label)\n    self.axis = axis / np.linalg.norm(axis)\n    self.angle = angle\n    self.robj = R.from_rotvec(self.axis * self.angle)",
            "start_lineno": 145,
            "end_lineno": 149,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 36,
            "gen_code": "class ImproperRotation:\n    def __init__(self, label, axis, angle):\n        self.label = label\n        self.axis = axis\n        self.angle = angle\n        self.operation_type = 'ImproperRotation'\n        # Create rotation object\n        self.rotation = R.from_rotvec(axis * angle)\n\n    def __str__(self):\n        return f'Improper Rotation: {self.label} around axis {self.axis} by angle {self.angle}'",
            "gen_import": [
                "from scipy.spatial.transform import Rotation as R"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/symmetry_operations.py",
            "relative_path": "sphecerix/symmetry_operations.py",
            "fqn_list": "sphecerix/symmetry_operations.py/ImproperRotation/get_matrix",
            "class": "sphecerix/symmetry_operations.py.ImproperRotation",
            "signature": "def get_matrix(self):",
            "comment": null,
            "comment_free_code": "def get_matrix(self):\n    M = np.identity(3) - 2.0 * self.normal @ self.normal.transpose()\n    R = self.robj.as_matrix()\n    return M @ R",
            "start_lineno": 151,
            "end_lineno": 154,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/symmetry_operations.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from scipy.spatial.transform import Rotation as R",
                    "scipy.spatial.transform.Rotation"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D",
                    "None.tesseral_wigner_D"
                ],
                [
                    "sphecerix/symmetry_operations.py",
                    "from None import tesseral_wigner_D_mirror",
                    "None.tesseral_wigner_D_mirror"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 37,
            "gen_code": "def get_matrix(self):\n    return R.from_rotvec(self.axis * self.angle).as_matrix()",
            "gen_import": [
                "from scipy.spatial.transform import Rotation as R"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/tesseral.py",
            "relative_path": "sphecerix/tesseral.py",
            "fqn_list": "sphecerix/tesseral.py/tesseral_transformation",
            "class": null,
            "signature": "def tesseral_transformation(l):",
            "comment": "Produce tesseral transformation matrix for order l",
            "comment_free_code": "def tesseral_transformation(l):\n    \n    T = np.zeros((2 * l + 1, 2 * l + 1), dtype=np.complex128)\n    invsq2r = 1 / np.sqrt(2)\n    invsq2i = 1j * invsq2r\n    for (i, m1) in enumerate(range(-l, l + 1)):\n        for (j, m2) in enumerate(range(-l, l + 1)):\n            if np.abs(m1) != np.abs(m2):\n                continue\n            if m1 < 0:\n                if m2 < 0:\n                    T[i, j] = invsq2i\n                elif m2 > 0:\n                    T[i, j] = -(-1) ** m1 * invsq2i\n            if m1 > 0:\n                if m2 < 0:\n                    T[i, j] = invsq2r\n                elif m2 > 0:\n                    T[i, j] = (-1) ** m1 * invsq2r\n    T[l, l] = 1\n    return T",
            "start_lineno": 5,
            "end_lineno": 31,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/tesseral.py",
                    "import numpy as np",
                    "numpy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 38,
            "gen_code": "def tesseral_transformation(l):\n    D = tesseral_wigner_D(l, None)  # Placeholder for rotation object\n    P = permutation_sh_car()\n    D_prime = P @ D @ np.linalg.inv(P)\n    return D_prime",
            "gen_import": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.tesseral import permutation_sh_car"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/tesseral.py",
            "relative_path": "sphecerix/tesseral.py",
            "fqn_list": "sphecerix/tesseral.py/permutation_sh_car",
            "class": null,
            "signature": "def permutation_sh_car():",
            "comment": "Grab the permutation matrix that transforms a 3D space from\nyzx ordering to xyz ordering. This is basically the permutation\nneeded to convert the default orientation of the spherical harmonics\nof order l=1 to the conventional Cartesian axes.",
            "comment_free_code": "def permutation_sh_car():\n    \n    return np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])",
            "start_lineno": 33,
            "end_lineno": 44,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/tesseral.py",
                    "import numpy as np",
                    "numpy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 39,
            "gen_code": "def permutation_sh_car():\n    # Example permutation matrix for demonstration\n    P = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n    return P",
            "gen_import": [
                "import numpy as np"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/basis_functions.py",
            "relative_path": "sphecerix/basis_functions.py",
            "fqn_list": "sphecerix/basis_functions.py/BasisFunction/__init__",
            "class": "sphecerix/basis_functions.py.BasisFunction",
            "signature": "def __init__(self, n, l, m):",
            "comment": null,
            "comment_free_code": "def __init__(self, n, l, m):\n    self.r = np.array([0, 0, 0])\n    self.n = n\n    self.l = l\n    self.m = m\n    self.atomid = None\n    self.name = None\n    self.name = self.__get_name()",
            "start_lineno": 7,
            "end_lineno": 15,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                40
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/basis_functions.py",
                    "import numpy as np",
                    "numpy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [
                    "sphecerix/basis_functions.py/BasisFunction/__get_name"
                ],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 40,
            "gen_code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.type = self.__get_type()\n\n    def __get_type(self):\n        # Simplified logic to determine type based on l value\n        if self.l == 0:\n            return 's'\n        elif self.l == 1:\n            return 'p'\n        elif self.l == 2:\n            return 'd'\n        elif self.l == 3:\n            return 'f'\n        else:\n            return 'higher'\n\n    def __str__(self):\n        return f'Basis function: (n={self.n}, l={self.l}, m={self.m}) type={self.type}'",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/basis_functions.py",
            "relative_path": "sphecerix/basis_functions.py",
            "fqn_list": "sphecerix/basis_functions.py/BasisFunction/__get_name",
            "class": "sphecerix/basis_functions.py.BasisFunction",
            "signature": "def __get_name(self):",
            "comment": null,
            "comment_free_code": "def __get_name(self):\n    return str(self.n) + self.__get_type()",
            "start_lineno": 17,
            "end_lineno": 18,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                39
            ],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/basis_functions.py",
                    "import numpy as np",
                    "numpy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [
                    "sphecerix/basis_functions.py/BasisFunction/__get_type"
                ],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 41,
            "gen_code": "class BasisFunction:\n    def __get_name(self):\n        # Mapping of angular momentum quantum number to orbital type\n        orbital_types = {0: 's', 1: 'p', 2: 'd', 3: 'f'}\n        return orbital_types.get(self.l, 'unknown')",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/sphecerix/basis_functions.py",
            "relative_path": "sphecerix/basis_functions.py",
            "fqn_list": "sphecerix/basis_functions.py/BasisFunction/__get_type",
            "class": "sphecerix/basis_functions.py.BasisFunction",
            "signature": "def __get_type(self):",
            "comment": null,
            "comment_free_code": "def __get_type(self):\n    results = [['s'], ['py', 'pz', 'px'], ['dxy', 'dyz', 'dz2', 'dxz', 'dx2-y2']]\n    return results[self.l][self.m + self.l]",
            "start_lineno": 20,
            "end_lineno": 27,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "sphecerix/basis_functions.py",
                    "import numpy as np",
                    "numpy"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 42,
            "gen_code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.type = self.__get_type()\n\n    def __get_type(self):\n        # Simplified logic to determine type based on l value\n        if self.l == 0:\n            return 's'\n        elif self.l == 1:\n            return 'p'\n        elif self.l == 2:\n            return 'd'\n        elif self.l == 3:\n            return 'f'\n        else:\n            return 'higher'\n\n    def __str__(self):\n        return f'Basis function: (n={self.n}, l={self.l}, m={self.m}) type={self.type}'",
            "gen_import": []
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/docs/conf.py",
            "relative_path": "docs/conf.py",
            "fqn_list": "docs/conf.py/setup",
            "class": null,
            "signature": "def setup(app):",
            "comment": null,
            "comment_free_code": "def setup(app):\n    app.add_css_file('css/custom.css')",
            "start_lineno": 78,
            "end_lineno": 79,
            "local_variables": {
                "module": [
                    "project = 'Sphecerix'",
                    "copyright = '2023, Inorganic Materials and Catalysis'",
                    "author = 'Ivo Filot'",
                    "extensions = [",
                    "'sphinx.ext.mathjax',",
                    "'sphinx.ext.autosectionlabel',",
                    "'sphinx_rtd_theme',",
                    "'sphinx.ext.autodoc',",
                    "'sphinx.ext.viewcode',",
                    "\"sphinx.ext.napoleon\",",
                    "]",
                    "napoleon_numpy_docstring = True",
                    "nitpicky = True",
                    "templates_path = ['_templates']",
                    "exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']",
                    "html_theme = 'sphinx_rtd_theme'",
                    "master_doc = 'index'",
                    "html_static_path = ['_static']",
                    "html_logo = \"_static/img/sphecerix_logo_128.png\"",
                    "html_favicon = \"_static/img/favicon.ico\"",
                    "html_css_files = [",
                    "\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css\"",
                    "]",
                    "html_show_sourcelink = False"
                ]
            },
            "Type": "FunctionDef",
            "Dependencies": [],
            "local_import": [],
            "third_import": [
                [
                    "docs/conf.py",
                    "import os",
                    "os"
                ],
                [
                    "docs/conf.py",
                    "import sys",
                    "sys"
                ],
                [
                    "docs/conf.py",
                    "import sphinx_rtd_theme",
                    "sphinx_rtd_theme"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 43,
            "gen_code": "def setup(app):\n    app.add_css_file('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css')\n    app.add_css_file('custom.css')\n    app.add_js_file('custom.js')\n    os.environ['SPHINX_BUILD'] = '1'",
            "gen_import": [
                "import os"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/examples/fz3_rotation.py",
            "relative_path": "examples/fz3_rotation.py",
            "fqn_list": "examples/fz3_rotation.py/main",
            "class": null,
            "signature": "def main():",
            "comment": null,
            "comment_free_code": "def main():\n    axis = np.ones(3) / np.sqrt(3)\n    angle = np.pi\n    D = tesseral_wigner_D_axis_angle(3, axis, angle)\n    Y = np.zeros(7)\n    Y[3] = 1\n    Yp = D @ Y\n    dim = 25\n    dfields = wffield_l(4, 3, dim, 200)\n    pytessel = PyTessel()\n    unitcell = np.diag(np.ones(3) * dim * 2)\n    isovalue = 0.005\n    (vertices, normals, indices) = pytessel.marching_cubes(dfields[3].flatten(), dfields[3].shape, unitcell.flatten(), isovalue)\n    pytessel.write_ply('fz3p.ply', vertices, normals, indices)\n    (vertices, normals, indices) = pytessel.marching_cubes(dfields[3].flatten(), dfields[3].shape, unitcell.flatten(), -isovalue)\n    pytessel.write_ply('fz3n.ply', vertices, normals, indices)\n    ffield = np.einsum('i,ijkl->jkl', Yp, dfields)\n    (vertices, normals, indices) = pytessel.marching_cubes(ffield.flatten(), ffield.shape, unitcell.flatten(), isovalue)\n    pytessel.write_ply('rfz3p.ply', vertices, normals, indices)\n    (vertices, normals, indices) = pytessel.marching_cubes(ffield.flatten(), ffield.shape, unitcell.flatten(), -isovalue)\n    pytessel.write_ply('rfz3n.ply', vertices, normals, indices)",
            "start_lineno": 13,
            "end_lineno": 46,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                12
            ],
            "local_import": [],
            "third_import": [
                [
                    "examples/fz3_rotation.py",
                    "import sys",
                    "sys"
                ],
                [
                    "examples/fz3_rotation.py",
                    "import os",
                    "os"
                ],
                [
                    "examples/fz3_rotation.py",
                    "from sphecerix import tesseral_wigner_D_axis_angle",
                    "sphecerix.tesseral_wigner_D_axis_angle"
                ],
                [
                    "examples/fz3_rotation.py",
                    "from sphecerix import wffield_l",
                    "sphecerix.wffield_l"
                ],
                [
                    "examples/fz3_rotation.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "examples/fz3_rotation.py",
                    "from pytessel import PyTessel",
                    "pytessel.PyTessel"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [
                    "sphecerix/atomic_wave_functions.py/wffield_l"
                ],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 44,
            "gen_code": "def main():\n    # build rotation axis and set angle for fz3 rotation\n    axis = np.array([1, 1, 1]) / np.sqrt(3)\n    angle = np.pi\n    Robj = R.from_rotvec(axis * angle)\n    \n    # construct tesseral Wigner D matrix for l=3\n    D = tesseral_wigner_D(3, Robj)\n    # Apply tesseral transformation\n    T = tesseral_transformation(3)\n    # Permute spherical harmonics to cartesian\n    P = permutation_sh_car()\n    \n    Y = np.zeros(7)\n    Y[3] = 1  # fz3 spherical harmonic\n    \n    # calculate linear combination of the spherical harmonics after rotation\n    Yp = T @ D @ P @ Y\n    print(Yp)",
            "gen_import": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.tesseral import tesseral_transformation, permutation_sh_car"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/examples/ethylene.py",
            "relative_path": "examples/ethylene.py",
            "fqn_list": "examples/ethylene.py/main",
            "class": null,
            "signature": "def main():",
            "comment": null,
            "comment_free_code": "def main():\n    mol = Molecule()\n    mol.add_atom('C', -0.6530176758, 0.0, 0.0, unit='angstrom')\n    mol.add_atom('C', 0.6530176758, 0.0, 0.0, unit='angstrom')\n    mol.add_atom('H', -1.2288875372, -0.9156191261, 0.0, unit='angstrom')\n    mol.add_atom('H', -1.2288875372, 0.9156191261, 0.0, unit='angstrom')\n    mol.add_atom('H', 1.2288875372, 0.9156191261, 0.0, unit='angstrom')\n    mol.add_atom('H', 1.2288875372, -0.9156191261, 0.0, unit='angstrom')\n    molset = {'C': [BasisFunction(1, 0, 0), BasisFunction(2, 0, 0), BasisFunction(2, 1, 1), BasisFunction(2, 1, -1), BasisFunction(2, 1, 0)], 'H': [BasisFunction(1, 0, 0)]}\n    mol.build_basis(molset)\n    symops = SymmetryOperations(mol)\n    symops.add('identity')\n    symops.add('rotation', '2(z)', np.array([0, 0, 1]), np.pi)\n    symops.add('rotation', '2(y)', np.array([0, 1, 0]), np.pi)\n    symops.add('rotation', '2(x)', np.array([1, 0, 0]), np.pi)\n    symops.add('inversion')\n    symops.add('mirror', 'v(xy)', np.array([0, 0, 1]))\n    symops.add('mirror', 'v(xz)', np.array([0, 1, 0]))\n    symops.add('mirror', 'v(yz)', np.array([1, 0, 0]))\n    symops.run()\n    visualize_matrices(symops, xlabelrot=90, figsize=(18, 10), numcols=4)",
            "start_lineno": 12,
            "end_lineno": 43,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                2,
                5,
                6,
                75,
                17,
                82,
                83,
                84
            ],
            "local_import": [],
            "third_import": [
                [
                    "examples/ethylene.py",
                    "import sys",
                    "sys"
                ],
                [
                    "examples/ethylene.py",
                    "import os",
                    "os"
                ],
                [
                    "examples/ethylene.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "examples/ethylene.py",
                    "from sphecerix import Molecule",
                    "sphecerix.Molecule"
                ],
                [
                    "examples/ethylene.py",
                    "from sphecerix import BasisFunction",
                    "sphecerix.BasisFunction"
                ],
                [
                    "examples/ethylene.py",
                    "from sphecerix import SymmetryOperations",
                    "sphecerix.SymmetryOperations"
                ],
                [
                    "examples/ethylene.py",
                    "from sphecerix import visualize_matrices",
                    "sphecerix.visualize_matrices"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [
                    "sphecerix/matrixplot.py/visualize_matrices",
                    "sphecerix/molecule.py/Molecule/add_atom",
                    "sphecerix/molecule.py/Molecule/build_basis",
                    "sphecerix/symmetry_operations.py/SymmetryOperations/run",
                    "sphecerix/symmetry_operations.py/SymmetryOperations/add"
                ],
                "Class Dependency": [
                    "sphecerix/molecule.py/Molecule",
                    "sphecerix/symmetry_operations.py/SymmetryOperations",
                    "sphecerix/basis_functions.py/BasisFunction"
                ]
            },
            "cov": true,
            "syn": false,
            "keyid": 45,
            "gen_code": "def main():\n    ethylene = Molecule(_name='Ethylene')\n    # Add atoms (C2H4)\n    ethylene.add_atom('C', 0, 0, 0)\n    ethylene.add_atom('C', 1.339, 0, 0)\n    ethylene.add_atom('H', -0.669, -0.923, 0)\n    ethylene.add_atom('H', -0.669, 0.923, 0)\n    ethylene.add_atom('H', 2.008, -0.923, 0)\n    ethylene.add_atom('H', 2.008, 0.923, 0)\n    \n    # Build basis and symmetry operations\n    ethylene.build_basis('minimal')\n    sym_ops = SymmetryOperations(ethylene)\n    sym_ops.add('C2', vec=[0,0,1], angle=180)\n    sym_ops.add('sigma_v', normal=[0,1,0])\n    sym_ops.run()\n    print('Ethylene molecule and symmetry operations setup complete.')",
            "gen_import": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/examples/dz2_rotation.py",
            "relative_path": "examples/dz2_rotation.py",
            "fqn_list": "examples/dz2_rotation.py/main",
            "class": null,
            "signature": "def main():",
            "comment": null,
            "comment_free_code": "def main():\n    axis = np.ones(3) / np.sqrt(3)\n    angle = np.pi\n    D = tesseral_wigner_D_axis_angle(2, axis, angle)\n    Y = np.zeros(5)\n    Y[2] = 1\n    Yp = D @ Y\n    dfields = wffield_l(3, 2, 15, 100)\n    pytessel = PyTessel()\n    unitcell = np.diag(np.ones(3) * 30.0)\n    isovalue = 0.01\n    (vertices, normals, indices) = pytessel.marching_cubes(dfields[2].flatten(), dfields[2].shape, unitcell.flatten(), isovalue)\n    pytessel.write_ply('dz2p.ply', vertices, normals, indices)\n    (vertices, normals, indices) = pytessel.marching_cubes(dfields[2].flatten(), dfields[2].shape, unitcell.flatten(), -isovalue)\n    pytessel.write_ply('dz2n.ply', vertices, normals, indices)\n    ffield = np.einsum('i,ijkl->jkl', Yp, dfields)\n    (vertices, normals, indices) = pytessel.marching_cubes(ffield.flatten(), ffield.shape, unitcell.flatten(), isovalue)\n    pytessel.write_ply('rdz2p.ply', vertices, normals, indices)\n    (vertices, normals, indices) = pytessel.marching_cubes(ffield.flatten(), ffield.shape, unitcell.flatten(), -isovalue)\n    pytessel.write_ply('rdz2n.ply', vertices, normals, indices)",
            "start_lineno": 13,
            "end_lineno": 45,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                12
            ],
            "local_import": [],
            "third_import": [
                [
                    "examples/dz2_rotation.py",
                    "import sys",
                    "sys"
                ],
                [
                    "examples/dz2_rotation.py",
                    "import os",
                    "os"
                ],
                [
                    "examples/dz2_rotation.py",
                    "from sphecerix import tesseral_wigner_D_axis_angle",
                    "sphecerix.tesseral_wigner_D_axis_angle"
                ],
                [
                    "examples/dz2_rotation.py",
                    "from sphecerix import wffield_l",
                    "sphecerix.wffield_l"
                ],
                [
                    "examples/dz2_rotation.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "examples/dz2_rotation.py",
                    "from pytessel import PyTessel",
                    "pytessel.PyTessel"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [
                    "sphecerix/atomic_wave_functions.py/wffield_l"
                ],
                "Class Dependency": []
            },
            "cov": true,
            "syn": false,
            "keyid": 46,
            "gen_code": "def main():\n    # build rotation axis and set angle for dz2 rotation\n    axis = np.array([1, 1, 1]) / np.sqrt(3)\n    angle = np.pi\n    Robj = R.from_rotvec(axis * angle)\n    \n    # construct tesseral Wigner D matrix for l=2\n    D = tesseral_wigner_D(2, Robj)\n    # Apply tesseral transformation\n    T = tesseral_transformation(2)\n    # Permute spherical harmonics to cartesian\n    P = permutation_sh_car()\n    \n    Y = np.zeros(5)\n    Y[2] = 1  # dz2 spherical harmonic\n    \n    # calculate linear combination of the spherical harmonics after rotation\n    Yp = T @ D @ P @ Y\n    print(Yp)",
            "gen_import": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.tesseral import tesseral_transformation, permutation_sh_car"
            ]
        },
        {
            "path": "/home/gudako/repo/repogen/data/sphecerix/examples/nh3.py",
            "relative_path": "examples/nh3.py",
            "fqn_list": "examples/nh3.py/main",
            "class": null,
            "signature": "def main():",
            "comment": null,
            "comment_free_code": "def main():\n    mol = Molecule()\n    mol.add_atom('N', 0.0, 0.0, -0.0693137, unit='angstrom')\n    mol.add_atom('H', 0.0, 0.94311105, 0.32106944, unit='angstrom')\n    mol.add_atom('H', -0.81675813, -0.47155553, 0.32106944, unit='angstrom')\n    mol.add_atom('H', 0.81675813, -0.47155553, 0.32106944, unit='angstrom')\n    molset = {'N': [BasisFunction(1, 0, 0), BasisFunction(2, 0, 0), BasisFunction(2, 1, 1), BasisFunction(2, 1, -1), BasisFunction(2, 1, 0)], 'H': [BasisFunction(1, 0, 0)]}\n    mol.build_basis(molset)\n    symops = SymmetryOperations(mol)\n    symops.add('identity')\n    symops.add('rotation', '3+', np.array([0, 0, 1]), 2.0 * np.pi / 3)\n    symops.add('rotation', '3-', -np.array([0, 0, 1]), 2.0 * np.pi / 3)\n    for i in range(0, 3):\n        symops.add('mirror', 'v1', np.array([np.cos(i * 2.0 * np.pi / 3), np.sin(i * 2.0 * np.pi / 3), 0.0]))\n    symops.run()\n    visualize_matrices(symops, xlabelrot=90, figsize=(9, 6))",
            "start_lineno": 12,
            "end_lineno": 41,
            "local_variables": {},
            "Type": "FunctionDef",
            "Dependencies": [
                2,
                5,
                6,
                75,
                17,
                82,
                83,
                84
            ],
            "local_import": [],
            "third_import": [
                [
                    "examples/nh3.py",
                    "import sys",
                    "sys"
                ],
                [
                    "examples/nh3.py",
                    "import os",
                    "os"
                ],
                [
                    "examples/nh3.py",
                    "import numpy as np",
                    "numpy"
                ],
                [
                    "examples/nh3.py",
                    "from sphecerix import Molecule",
                    "sphecerix.Molecule"
                ],
                [
                    "examples/nh3.py",
                    "from sphecerix import BasisFunction",
                    "sphecerix.BasisFunction"
                ],
                [
                    "examples/nh3.py",
                    "from sphecerix import SymmetryOperations",
                    "sphecerix.SymmetryOperations"
                ],
                [
                    "examples/nh3.py",
                    "from sphecerix import visualize_matrices",
                    "sphecerix.visualize_matrices"
                ]
            ],
            "categorized_dependencies": {
                "Intra-class Dependency": [],
                "Intra-file Dependency": [],
                "Cross-file Dependency": [
                    "sphecerix/matrixplot.py/visualize_matrices",
                    "sphecerix/molecule.py/Molecule/add_atom",
                    "sphecerix/molecule.py/Molecule/build_basis",
                    "sphecerix/symmetry_operations.py/SymmetryOperations/run",
                    "sphecerix/symmetry_operations.py/SymmetryOperations/add"
                ],
                "Class Dependency": [
                    "sphecerix/molecule.py/Molecule",
                    "sphecerix/symmetry_operations.py/SymmetryOperations",
                    "sphecerix/basis_functions.py/BasisFunction"
                ]
            },
            "cov": true,
            "syn": false,
            "keyid": 47,
            "gen_code": "def main():\n    ammonia = Molecule(_name='Ammonia')\n    # Add atoms (NH3)\n    ammonia.add_atom('N', 0, 0, 0.1)\n    ammonia.add_atom('H', 0.9377, 0, -0.3816)\n    ammonia.add_atom('H', -0.4688, 0.8121, -0.3816)\n    ammonia.add_atom('H', -0.4688, -0.8121, -0.3816)\n    \n    # Build basis and symmetry operations\n    ammonia.build_basis('minimal')\n    sym_ops = SymmetryOperations(ammonia)\n    sym_ops.add('C3', vec=[0,0,1], angle=120)\n    sym_ops.add('sigma_v', normal=[0,1,0])\n    sym_ops.run()\n    print('Ammonia molecule and symmetry operations setup complete.')",
            "gen_import": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations"
            ]
        }
    ]
}