{
    "implementation": [
        {
            "key_id": 19,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/__init__",
            "imports": [],
            "code": "class SymmetryOperations:\n    def __init__(self, mol):\n        self.mol = mol\n        self.operations = []"
        },
        {
            "key_id": 22,
            "fqn": "sphecerix/symmetry_operations.py/Operation/__init__",
            "imports": [],
            "code": "class Operation:\n    def __init__(self, name):\n        self.name = name\n        self.matrix = None\n        self.wigner_matrix = None"
        },
        {
            "key_id": 24,
            "fqn": "sphecerix/symmetry_operations.py/Identity/__init__",
            "imports": [],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n        self.wigner_matrix = lambda l: np.eye(2*l+1)"
        },
        {
            "key_id": 27,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/__init__",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = -np.eye(3)\n        self.wigner_matrix = lambda l: np.diag((-1)**np.arange(-l, l+1))"
        },
        {
            "key_id": 30,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/__init__",
            "imports": [
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ],
            "code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        self.matrix = R.from_rotvec(axis * angle).as_matrix()\n        self.wigner_matrix = lambda l: tesseral_wigner_D(l, R.from_rotvec(axis * angle))"
        },
        {
            "key_id": 33,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/__init__",
            "imports": [],
            "code": "class Mirror:\n    def __init__(self, label, normal):\n        self.label = label\n        self.normal = normal\n        self.operation_type = 'Mirror'\n        # Assuming normal is a numpy array for vector operations\n        import numpy as np\n        self.reflection_matrix = np.eye(3) - 2 * np.outer(normal, normal) / np.linalg.norm(normal)**2\n\n    def __str__(self):\n        return f'Mirror operation: {self.label} with normal {self.normal}'"
        },
        {
            "key_id": 36,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/__init__",
            "imports": [
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "class ImproperRotation:\n    def __init__(self, label, axis, angle):\n        self.label = label\n        self.axis = axis\n        self.angle = angle\n        self.operation_type = 'ImproperRotation'\n        # Create rotation object\n        self.rotation = R.from_rotvec(axis * angle)\n\n    def __str__(self):\n        return f'Improper Rotation: {self.label} around axis {self.axis} by angle {self.angle}'"
        },
        {
            "key_id": 3,
            "fqn": "sphecerix/molecule.py/Molecule/__init__",
            "imports": [],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        self.atoms.append({'atom': atom, 'x': x, 'y': y, 'z': z, 'unit': unit})\n\n    def __str__(self):\n        return f'Molecule: {self.name} with {len(self.atoms)} atoms'"
        },
        {
            "key_id": 40,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__init__",
            "imports": [],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.type = self.__get_type()\n\n    def __get_type(self):\n        # Simplified logic to determine type based on l value\n        if self.l == 0:\n            return 's'\n        elif self.l == 1:\n            return 'p'\n        elif self.l == 2:\n            return 'd'\n        elif self.l == 3:\n            return 'f'\n        else:\n            return 'higher'\n\n    def __str__(self):\n        return f'Basis function: (n={self.n}, l={self.l}, m={self.m}) type={self.type}'"
        },
        {
            "key_id": 7,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wffield(n, l, m, d, npts):\n    theta, phi = np.mgrid[0:np.pi:npts*1j, 0:2*np.pi:npts*1j]\n    r = np.linspace(0, d, npts)\n    r, theta, phi = np.meshgrid(r, theta, phi, indexing='ij')\n    Ylm = sph_harm(m, l, phi, theta)\n    return np.abs(Ylm)**2"
        },
        {
            "key_id": 8,
            "fqn": "sphecerix/atomic_wave_functions.py/wffield_l",
            "imports": [
                "import numpy as np",
                "from sphecerix.atomic_wave_functions import wffield"
            ],
            "code": "def wffield_l(n, l, d, npts):\n    results = {}\n    for m in range(-l, l+1):\n        results[m] = wffield(n, l, m, d, npts)\n    return results"
        },
        {
            "key_id": 9,
            "fqn": "sphecerix/atomic_wave_functions.py/wfcart",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wfcart(n, l, m, x, y, z):\n    r = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(np.sqrt(x**2 + y**2), z)\n    phi = np.arctan2(y, x)\n    Ylm = sph_harm(m, l, phi, theta)\n    return np.abs(Ylm)**2"
        },
        {
            "key_id": 10,
            "fqn": "sphecerix/atomic_wave_functions.py/wf",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wf(n, l, m, r, theta, phi):\n    Ylm = sph_harm(m, l, phi, theta)\n    return np.abs(Ylm)**2"
        },
        {
            "key_id": 11,
            "fqn": "sphecerix/atomic_wave_functions.py/angular",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def angular(l, m, theta, phi):\n    Ylm = sph_harm(m, l, phi, theta)\n    return Ylm"
        },
        {
            "key_id": 12,
            "fqn": "sphecerix/atomic_wave_functions.py/radial",
            "imports": [
                "import numpy as np",
                "from scipy.special import genlaguerre, sph_harm"
            ],
            "code": "def radial(n, l, r):\n    # Normalization factor\n    a0 = 1  # Bohr radius, can be adjusted\n    rho = 2 * r / (n * a0)\n    normalization = np.sqrt((2 / (n * a0))**3 * np.math.factorial(n - l - 1) / (2 * n * np.math.factorial(n + l)))\n    # Radial part of the wave function\n    radial_part = normalization * np.exp(-rho / 2) * rho**l * genlaguerre(n - l - 1, 2 * l + 1)(rho)\n    return radial_part"
        },
        {
            "key_id": 13,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "def tesseral_wigner_D(l, Robj):\n    # Placeholder for the actual implementation\n    # This function would compute the tesseral Wigner D matrix based on the given rotation object and angular momentum quantum number l\n    # For simplicity, we return an identity matrix of size (2l+1, 2l+1)\n    return np.eye(2 * l + 1)"
        },
        {
            "key_id": 14,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_mirror",
            "imports": [
                "import numpy as np"
            ],
            "code": "def tesseral_wigner_D_mirror(l, normal):\n    # Placeholder for the actual implementation\n    # This function would compute the tesseral Wigner D matrix for a mirror operation\n    # For simplicity, we return an identity matrix of size (2l+1, 2l+1) with a sign flip based on the mirror plane\n    return np.diag([-1 if i % 2 == 0 else 1 for i in range(2 * l + 1)])"
        },
        {
            "key_id": 15,
            "fqn": "sphecerix/wignerd.py/tesseral_wigner_D_improper",
            "imports": [
                "import numpy as np"
            ],
            "code": "def tesseral_wigner_D_improper(l, Robj):\n    # Placeholder for the actual implementation\n    # This function would compute the tesseral Wigner D matrix for an improper rotation\n    # For simplicity, we return a matrix with alternating signs\n    return np.diag([-1 if i % 2 == 0 else 1 for i in range(2 * l + 1)])"
        },
        {
            "key_id": 16,
            "fqn": "sphecerix/wignerd.py/wigner_D",
            "imports": [
                "import numpy as np"
            ],
            "code": "def wigner_D(l, Robj):\n    # Placeholder for the actual implementation\n    # This function would compute the Wigner D matrix based on the given rotation object and angular momentum quantum number l\n    # For simplicity, we return an identity matrix of size (2l+1, 2l+1)\n    return np.eye(2 * l + 1)"
        },
        {
            "key_id": 17,
            "fqn": "sphecerix/wignerd.py/wigner_d",
            "imports": [
                "import numpy as np",
                "from scipy.special import sph_harm"
            ],
            "code": "def wigner_d(l, beta):\n    d_matrix = np.zeros((2*l+1, 2*l+1), dtype=complex)\n    for m in range(-l, l+1):\n        for mp in range(-l, l+1):\n            d_matrix[m+l, mp+l] = sph_harm(mp, l, beta, 0) * np.conj(sph_harm(m, l, beta, 0))\n    return d_matrix"
        },
        {
            "key_id": 18,
            "fqn": "sphecerix/wignerd.py/wigner_d_element_euler_angles",
            "imports": [
                "import numpy as np",
                "from scipy.special import lpmv",
                "from math import factorial, sqrt, cos, sin"
            ],
            "code": "def wigner_d_element_euler_angles(l, m1, m2, beta):\n    element = 0\n    for k in range(max(0, m2-m1), min(l+m2, l-m1)+1):\n        top = sqrt(factorial(l+m1)*factorial(l-m1)*factorial(l+m2)*factorial(l-m2))\n        bottom = factorial(k)*factorial(l+m2-k)*factorial(m1-m2+k)*factorial(l-m1-k)\n        element += (-1)**k * top/bottom * (cos(beta/2)**(2*l+m2-m1-2*k)) * (sin(beta/2)**(2*k+m1-m2))\n    return element"
        },
        {
            "key_id": 20,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/add",
            "imports": [
                "from .Operation import Operation"
            ],
            "code": "def add(self, name, label=None, vec=None, angle=None):\n    operation = Operation(name)\n    if label is not None:\n        operation.label = label\n    if vec is not None:\n        operation.vec = vec\n    if angle is not None:\n        operation.angle = angle\n    self.operations.append(operation)"
        },
        {
            "key_id": 21,
            "fqn": "sphecerix/symmetry_operations.py/SymmetryOperations/run",
            "imports": [
                "from .Identity import Identity",
                "from .Inversion import Inversion",
                "from .Rotation import Rotation",
                "from .Mirror import Mirror",
                "from .ImproperRotation import ImproperRotation"
            ],
            "code": "def run(self):\n    for operation in self.operations:\n        if isinstance(operation, Identity):\n            print('Executing Identity operation')\n            operation.execute()\n        elif isinstance(operation, Inversion):\n            print('Executing Inversion operation')\n            operation.execute()\n        elif isinstance(operation, Rotation):\n            print('Executing Rotation operation')\n            operation.execute()\n        elif isinstance(operation, Mirror):\n            print('Executing Mirror operation')\n            operation.execute()\n        elif isinstance(operation, ImproperRotation):\n            print('Executing Improper Rotation operation')\n            operation.execute()\n        else:\n            print(f'Unknown operation: {operation.name}')"
        },
        {
            "key_id": 23,
            "fqn": "sphecerix/symmetry_operations.py/Operation/set_atomic_id",
            "imports": [],
            "code": "def set_atomic_id(self, idx):\n    self.atomic_id = idx\n    print(f'Setting atomic ID to {idx} for operation {self.name}')"
        },
        {
            "key_id": 25,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.matrix = np.eye(3)\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 26,
            "fqn": "sphecerix/symmetry_operations.py/Identity/get_wigner_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Identity(Operation):\n    def __init__(self):\n        super().__init__('Identity')\n        self.wigner_matrix = lambda l: np.eye(2*l+1)\n\n    def get_wigner_matrix(self, l):\n        return self.wigner_matrix(l)"
        },
        {
            "key_id": 28,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.matrix = -np.eye(3)\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 29,
            "fqn": "sphecerix/symmetry_operations.py/Inversion/get_wigner_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "class Inversion(Operation):\n    def __init__(self):\n        super().__init__('Inversion')\n        self.wigner_matrix = lambda l: np.diag((-1)**np.arange(-l, l+1))\n\n    def get_wigner_matrix(self, l):\n        return self.wigner_matrix(l)"
        },
        {
            "key_id": 31,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_matrix",
            "imports": [
                "from scipy.spatial.transform import Rotation as R",
                "import numpy as np"
            ],
            "code": "class Rotation(Operation):\n    def __init__(self, label, axis, angle):\n        super().__init__(label)\n        self.axis = axis\n        self.angle = angle\n        self.matrix = R.from_rotvec(axis * angle).as_matrix()\n\n    def get_matrix(self):\n        return self.matrix"
        },
        {
            "key_id": 32,
            "fqn": "sphecerix/symmetry_operations.py/Rotation/get_wigner_matrix",
            "imports": [
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D"
            ],
            "code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D(l, R.from_rotvec(self.axis * self.angle))"
        },
        {
            "key_id": 34,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_matrix",
            "imports": [
                "import numpy as np"
            ],
            "code": "def get_matrix(self):\n    return np.eye(3) - 2 * np.outer(self.normal, self.normal) / np.linalg.norm(self.normal)**2"
        },
        {
            "key_id": 35,
            "fqn": "sphecerix/symmetry_operations.py/Mirror/get_wigner_matrix",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D_mirror"
            ],
            "code": "def get_wigner_matrix(self, l):\n    return tesseral_wigner_D_mirror(l, self.normal)"
        },
        {
            "key_id": 37,
            "fqn": "sphecerix/symmetry_operations.py/ImproperRotation/get_matrix",
            "imports": [
                "from scipy.spatial.transform import Rotation as R"
            ],
            "code": "def get_matrix(self):\n    return R.from_rotvec(self.axis * self.angle).as_matrix()"
        },
        {
            "key_id": 4,
            "fqn": "sphecerix/molecule.py/Molecule/__str__",
            "imports": [],
            "code": "def __str__(self):\n    atom_details = ', '.join([f'{atom['atom']} at ({atom['x']}, {atom['y']}, {atom['z']})' for atom in self.atoms])\n    return f'Molecule: {self.name} with {len(self.atoms)} atoms: {atom_details}'"
        },
        {
            "key_id": 5,
            "fqn": "sphecerix/molecule.py/Molecule/add_atom",
            "imports": [],
            "code": "class Molecule:\n    def __init__(self, _name='unknown'):\n        self.name = _name\n        self.atoms = []\n        self.basis_functions = []\n\n    def add_atom(self, atom, x, y, z, unit='bohr'):\n        self.atoms.append({'atom': atom, 'x': x, 'y': y, 'z': z, 'unit': unit})\n\n    def __str__(self):\n        return f'Molecule: {self.name} with {len(self.atoms)} atoms'"
        },
        {
            "key_id": 6,
            "fqn": "sphecerix/molecule.py/Molecule/build_basis",
            "imports": [
                "from sphecerix.atomic_wave_functions import wffield, wffield_l, wfcart, wf, angular, radial",
                "from sphecerix.basis_functions import BasisFunction"
            ],
            "code": "class Molecule:\n    def build_basis(self, molset):\n        for atom in self.atoms:\n            for orbital in molset.get_orbitals(atom['atom']):\n                n, l, m = orbital\n                basis_function = BasisFunction(n, l, m)\n                self.basis_functions.append(basis_function)\n        return self.basis_functions"
        },
        {
            "key_id": 38,
            "fqn": "sphecerix/tesseral.py/tesseral_transformation",
            "imports": [
                "import numpy as np",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.tesseral import permutation_sh_car"
            ],
            "code": "def tesseral_transformation(l):\n    D = tesseral_wigner_D(l, None)  # Placeholder for rotation object\n    P = permutation_sh_car()\n    D_prime = P @ D @ np.linalg.inv(P)\n    return D_prime"
        },
        {
            "key_id": 39,
            "fqn": "sphecerix/tesseral.py/permutation_sh_car",
            "imports": [
                "import numpy as np"
            ],
            "code": "def permutation_sh_car():\n    # Example permutation matrix for demonstration\n    P = np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]])\n    return P"
        },
        {
            "key_id": 41,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_name",
            "imports": [],
            "code": "class BasisFunction:\n    def __get_name(self):\n        # Mapping of angular momentum quantum number to orbital type\n        orbital_types = {0: 's', 1: 'p', 2: 'd', 3: 'f'}\n        return orbital_types.get(self.l, 'unknown')"
        },
        {
            "key_id": 42,
            "fqn": "sphecerix/basis_functions.py/BasisFunction/__get_type",
            "imports": [],
            "code": "class BasisFunction:\n    def __init__(self, n, l, m):\n        self.n = n\n        self.l = l\n        self.m = m\n        self.type = self.__get_type()\n\n    def __get_type(self):\n        # Simplified logic to determine type based on l value\n        if self.l == 0:\n            return 's'\n        elif self.l == 1:\n            return 'p'\n        elif self.l == 2:\n            return 'd'\n        elif self.l == 3:\n            return 'f'\n        else:\n            return 'higher'\n\n    def __str__(self):\n        return f'Basis function: (n={self.n}, l={self.l}, m={self.m}) type={self.type}'"
        },
        {
            "key_id": 0,
            "fqn": "sphecerix/matrixplot.py/visualize_matrices",
            "imports": [
                "import matplotlib.pyplot as plt"
            ],
            "code": "def visualize_matrices(symops, numcols = 3, highlight_groups = None, filename = None, figsize = (7,5), xlabelrot = 0):\n    fig, axs = plt.subplots(len(symops) // numcols + bool(len(symops) % numcols), numcols, figsize=figsize)\n    axs = axs.flatten() if len(symops) > 1 else [axs]\n    for ax, symop in zip(axs, symops):\n        plot_matrix(ax, symop.matrix, symop.basis_functions, title=symop.name, xlabelrot=xlabelrot)\n    if highlight_groups:\n        for group in highlight_groups:\n            plot_highlight_groups(axs[group[0]], group[1], symops[group[0]].matrix)\n    if filename:\n        plt.savefig(filename)\n    else:\n        plt.show()"
        },
        {
            "key_id": 1,
            "fqn": "sphecerix/matrixplot.py/plot_highlight_groups",
            "imports": [],
            "code": "def plot_highlight_groups(axh, groups, mat):\n    for group in groups:\n        axh.plot(mat[group], 'ro')\n    axh.set_title('Highlighted Groups')"
        },
        {
            "key_id": 2,
            "fqn": "sphecerix/matrixplot.py/plot_matrix",
            "imports": [],
            "code": "def plot_matrix(ax, mat, bfs, title = None, xlabelrot = 0):\n    cax = ax.matshow(mat, cmap='viridis')\n    if title:\n        ax.set_title(title)\n    ax.set_xticks(range(len(bfs)))\n    ax.set_xticklabels(bfs, rotation=xlabelrot)\n    ax.set_yticks(range(len(bfs)))\n    ax.set_yticklabels(bfs)\n    plt.colorbar(cax, ax=ax)"
        },
        {
            "key_id": 43,
            "fqn": "docs/conf.py/setup",
            "imports": [
                "import os"
            ],
            "code": "def setup(app):\n    app.add_css_file('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css')\n    app.add_css_file('custom.css')\n    app.add_js_file('custom.js')\n    os.environ['SPHINX_BUILD'] = '1'"
        },
        {
            "key_id": 44,
            "fqn": "examples/fz3_rotation.py/main",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.tesseral import tesseral_transformation, permutation_sh_car"
            ],
            "code": "def main():\n    # build rotation axis and set angle for fz3 rotation\n    axis = np.array([1, 1, 1]) / np.sqrt(3)\n    angle = np.pi\n    Robj = R.from_rotvec(axis * angle)\n    \n    # construct tesseral Wigner D matrix for l=3\n    D = tesseral_wigner_D(3, Robj)\n    # Apply tesseral transformation\n    T = tesseral_transformation(3)\n    # Permute spherical harmonics to cartesian\n    P = permutation_sh_car()\n    \n    Y = np.zeros(7)\n    Y[3] = 1  # fz3 spherical harmonic\n    \n    # calculate linear combination of the spherical harmonics after rotation\n    Yp = T @ D @ P @ Y\n    print(Yp)"
        },
        {
            "key_id": 45,
            "fqn": "examples/ethylene.py/main",
            "imports": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations"
            ],
            "code": "def main():\n    ethylene = Molecule(_name='Ethylene')\n    # Add atoms (C2H4)\n    ethylene.add_atom('C', 0, 0, 0)\n    ethylene.add_atom('C', 1.339, 0, 0)\n    ethylene.add_atom('H', -0.669, -0.923, 0)\n    ethylene.add_atom('H', -0.669, 0.923, 0)\n    ethylene.add_atom('H', 2.008, -0.923, 0)\n    ethylene.add_atom('H', 2.008, 0.923, 0)\n    \n    # Build basis and symmetry operations\n    ethylene.build_basis('minimal')\n    sym_ops = SymmetryOperations(ethylene)\n    sym_ops.add('C2', vec=[0,0,1], angle=180)\n    sym_ops.add('sigma_v', normal=[0,1,0])\n    sym_ops.run()\n    print('Ethylene molecule and symmetry operations setup complete.')"
        },
        {
            "key_id": 46,
            "fqn": "examples/dz2_rotation.py/main",
            "imports": [
                "import numpy as np",
                "from scipy.spatial.transform import Rotation as R",
                "from sphecerix.wignerd import tesseral_wigner_D",
                "from sphecerix.tesseral import tesseral_transformation, permutation_sh_car"
            ],
            "code": "def main():\n    # build rotation axis and set angle for dz2 rotation\n    axis = np.array([1, 1, 1]) / np.sqrt(3)\n    angle = np.pi\n    Robj = R.from_rotvec(axis * angle)\n    \n    # construct tesseral Wigner D matrix for l=2\n    D = tesseral_wigner_D(2, Robj)\n    # Apply tesseral transformation\n    T = tesseral_transformation(2)\n    # Permute spherical harmonics to cartesian\n    P = permutation_sh_car()\n    \n    Y = np.zeros(5)\n    Y[2] = 1  # dz2 spherical harmonic\n    \n    # calculate linear combination of the spherical harmonics after rotation\n    Yp = T @ D @ P @ Y\n    print(Yp)"
        },
        {
            "key_id": 47,
            "fqn": "examples/nh3.py/main",
            "imports": [
                "from sphecerix.molecule import Molecule",
                "from sphecerix.symmetry_operations import SymmetryOperations"
            ],
            "code": "def main():\n    ammonia = Molecule(_name='Ammonia')\n    # Add atoms (NH3)\n    ammonia.add_atom('N', 0, 0, 0.1)\n    ammonia.add_atom('H', 0.9377, 0, -0.3816)\n    ammonia.add_atom('H', -0.4688, 0.8121, -0.3816)\n    ammonia.add_atom('H', -0.4688, -0.8121, -0.3816)\n    \n    # Build basis and symmetry operations\n    ammonia.build_basis('minimal')\n    sym_ops = SymmetryOperations(ammonia)\n    sym_ops.add('C3', vec=[0,0,1], angle=120)\n    sym_ops.add('sigma_v', normal=[0,1,0])\n    sym_ops.run()\n    print('Ammonia molecule and symmetry operations setup complete.')"
        }
    ]
}