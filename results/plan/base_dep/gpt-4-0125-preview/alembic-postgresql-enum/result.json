{
    "implementation": [
        {
            "key_id": 41,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/__init__",
            "imports": [
                "from typing import List",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference"
            ],
            "code": "def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n    self.schema = schema\n    self.name = name\n    self.old_values = old_values\n    self.new_values = new_values\n    self.affected_columns = affected_columns\n    self.operation_name = 'change_enum_variants'"
        },
        {
            "key_id": 48,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/__init__",
            "imports": [
                "from typing import Iterable"
            ],
            "code": "def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n    self.schema = schema\n    self.name = name\n    self.enum_values = list(enum_values)"
        },
        {
            "key_id": 10,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_array_enum_type_to_new",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from typing import List, Tuple",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference"
            ],
            "code": "def cast_old_array_enum_type_to_new(connection: Connection, table_reference: TableReference, enum_type_name: str, enum_values_to_rename: List[Tuple[str, str]]):\n    query = f\"SELECT unnest(enum_range(NULL::{enum_type_name}))\"\n    existing_values = connection.execute(query).fetchall()\n    existing_values = [value[0] for value in existing_values]\n    for old_value, new_value in enum_values_to_rename:\n        if old_value in existing_values:\n            alter_query = f\"ALTER TYPE {enum_type_name} RENAME VALUE '{old_value}' TO '{new_value}'\"\n            connection.execute(alter_query)"
        },
        {
            "key_id": 11,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/cast_old_enum_type_to_new",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from typing import List, Tuple",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference"
            ],
            "code": "def cast_old_enum_type_to_new(connection: Connection, table_reference: TableReference, enum_type_name: str, enum_values_to_rename: List[Tuple[str, str]]):\n    query = f\"SELECT unnest(enum_range(NULL::{enum_type_name}))\"\n    existing_values = connection.execute(query).fetchall()\n    existing_values = [value[0] for value in existing_values]\n    for old_value, new_value in enum_values_to_rename:\n        if old_value in existing_values:\n            alter_query = f\"ALTER TYPE {enum_type_name} RENAME VALUE '{old_value}' TO '{new_value}'\"\n            connection.execute(alter_query)"
        },
        {
            "key_id": 12,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/drop_type",
            "imports": [
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def drop_type(connection: Connection, schema: str, type_name: str):\n    query = f\"DROP TYPE IF EXISTS {schema}.{type_name}\"\n    connection.execute(query)"
        },
        {
            "key_id": 13,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/rename_type",
            "imports": [
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def rename_type(connection: Connection, schema: str, type_name: str, new_type_name: str):\n    query = f\"ALTER TYPE {schema}.{type_name} RENAME TO {new_type_name}\"\n    connection.execute(query)"
        },
        {
            "key_id": 14,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/create_type",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from typing import List"
            ],
            "code": "def create_type(connection: Connection, schema: str, type_name: str, enum_values: List[str]):\n    values_str = ', '.join(f\"'{value}'\" for value in enum_values)\n    query = f\"CREATE TYPE {schema}.{type_name} AS ENUM ({values_str})\"\n    connection.execute(query)"
        },
        {
            "key_id": 15,
            "fqn": "alembic_postgresql_enum/sql_commands/enum_type.py/get_all_enums",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def get_all_enums(connection, schema: str):\n    query = text(\n        \"SELECT t.typname AS enumtype, e.enumlabel AS enumlabel\"\n        \" FROM pg_type t\"\n        \" JOIN pg_enum e ON t.oid = e.enumtypid\"\n        \" JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\"\n        \" WHERE n.nspname = :schema;\"\n    )\n    result = connection.execute(query, {'schema': schema}).fetchall()\n    enums = {}\n    for row in result:\n        if row['enumtype'] in enums:\n            enums[row['enumtype']].append(row['enumlabel'])\n        else:\n            enums[row['enumtype']] = [row['enumlabel']]\n    return enums"
        },
        {
            "key_id": 16,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/get_column_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def get_column_default(connection, table_schema: str, table_name: str, column_name: str) -> str or None:\n    query = text(\n        \"SELECT column_default FROM information_schema.columns\"\n        \" WHERE table_schema = :schema AND table_name = :table AND column_name = :column;\"\n    )\n    result = connection.execute(query, {'schema': table_schema, 'table': table_name, 'column': column_name}).fetchone()\n    return result['column_default'] if result else None"
        },
        {
            "key_id": 17,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/drop_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def drop_default(connection, table_name_with_schema: str, column_name: str):\n    query = text(\n        \"ALTER TABLE \" + table_name_with_schema +\n        \" ALTER COLUMN \" + column_name + \" DROP DEFAULT;\"\n    )\n    connection.execute(query)"
        },
        {
            "key_id": 18,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/set_default",
            "imports": [
                "from sqlalchemy import text"
            ],
            "code": "def set_default(connection, table_name_with_schema: str, column_name: str, default_value: str):\n    query = text(\n        \"ALTER TABLE \" + table_name_with_schema +\n        \" ALTER COLUMN \" + column_name + \" SET DEFAULT '\" + default_value + \"';\"\n    )\n    connection.execute(query)"
        },
        {
            "key_id": 19,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/rename_default_if_required",
            "imports": [
                "import re"
            ],
            "code": "def rename_default_if_required(schema: str, default_value: str, enum_name: str, enum_values_to_rename: list):\n    for old_value, new_value in enum_values_to_rename:\n        if old_value in default_value:\n            default_value = re.sub(r'\\b' + old_value + r'\\b', new_value, default_value)\n    return default_value"
        },
        {
            "key_id": 20,
            "fqn": "alembic_postgresql_enum/sql_commands/column_default.py/_replace_strings_in_quotes",
            "imports": [
                "from typing import List, Tuple"
            ],
            "code": "def _replace_strings_in_quotes(old_default: str, enum_values_to_rename: List[Tuple[str, str]]) -> str:\n    for old_value, new_value in enum_values_to_rename:\n        old_default = old_default.replace(f\"'{old_value}'\", f\"'{new_value}'\")\n    return old_default"
        },
        {
            "key_id": 21,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_create_comparison_operator",
            "imports": [
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def _create_comparison_operator(connection: Connection, schema: str, enum_name: str, old_enum_name: str, enum_values_to_rename: List[Tuple[str, str]], operator: str, comparison_function_name: str):\n    # Assuming the existence of a utility function to create comparison operators\n    # This is a placeholder implementation\n    print(f'Creating comparison operator {comparison_function_name} for enum {enum_name} in schema {schema}')"
        },
        {
            "key_id": 22,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/create_comparison_operators",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from typing import List, Tuple"
            ],
            "code": "def create_comparison_operators(connection: Connection, schema: str, enum_name: str, old_enum_name: str, enum_values_to_rename: List[Tuple[str, str]]):\n    for operator, function_name in OPERATORS_TO_CREATE:\n        _create_comparison_operator(connection, schema, enum_name, old_enum_name, enum_values_to_rename, operator, function_name)"
        },
        {
            "key_id": 23,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/_drop_comparison_operator",
            "imports": [
                "from sqlalchemy.engine import Connection"
            ],
            "code": "def _drop_comparison_operator(connection: Connection, schema: str, enum_name: str, old_enum_name: str, comparison_function_name: str):\n    # Assuming the existence of a utility function to drop comparison operators\n    # This is a placeholder implementation\n    print(f'Dropping comparison operator {comparison_function_name} for enum {enum_name} in schema {schema}')"
        },
        {
            "key_id": 24,
            "fqn": "alembic_postgresql_enum/sql_commands/comparison_operators.py/drop_comparison_operators",
            "imports": [
                "from sqlalchemy.engine import Connection",
                "from typing import List, Tuple"
            ],
            "code": "def drop_comparison_operators(connection: Connection, schema: str, enum_name: str, old_enum_name: str):\n    for operator, function_name in OPERATORS_TO_CREATE:\n        _drop_comparison_operator(connection, schema, enum_name, old_enum_name, function_name)"
        },
        {
            "key_id": 25,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/ColumnType/__repr__",
            "imports": [
                "from enum import Enum"
            ],
            "code": "class ColumnType(Enum):\n    COMMON = 'common'\n    ARRAY = 'array'\n\n    def __repr__(self):\n        return f'<ColumnType.{self.name}>'"
        },
        {
            "key_id": 26,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/__repr__",
            "imports": [
                "from dataclasses import dataclass"
            ],
            "code": "@dataclass\nclass TableReference:\n    schema: str\n    table_name: str\n    column_name: str\n    column_type: 'ColumnType'\n\n    def __repr__(self):\n        return f'<TableReference schema={self.schema}, table_name={self.table_name}, column_name={self.column_name}, column_type={self.column_type}>'"
        },
        {
            "key_id": 27,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/is_column_type_import_needed",
            "imports": [],
            "code": "def is_column_type_import_needed(self) -> bool:\n        return self.column_type == ColumnType.ARRAY"
        },
        {
            "key_id": 28,
            "fqn": "alembic_postgresql_enum/get_enum_data/types.py/TableReference/table_name_with_schema",
            "imports": [],
            "code": "def table_name_with_schema(self) -> str:\n        return f'{self.schema}.{self.table_name}' if self.schema else self.table_name"
        },
        {
            "key_id": 29,
            "fqn": "alembic_postgresql_enum/get_enum_data/defined_enums.py/_remove_schema_prefix",
            "imports": [],
            "code": "def _remove_schema_prefix(enum_name: str, schema: str) -> str:\n        if enum_name.startswith(f'{schema}.'):\n            return enum_name[len(schema)+1:]\n        return enum_name"
        },
        {
            "key_id": 30,
            "fqn": "alembic_postgresql_enum/get_enum_data/defined_enums.py/get_defined_enums",
            "imports": [
                "from typing import Dict, List, Tuple",
                "from alembic_postgresql_enum.sql_commands.enum_type import get_all_enums"
            ],
            "code": "def get_defined_enums(connection, schema: str) -> Dict[str, List[str]]:\n    defined_enums = get_all_enums(connection, schema)\n    return {enum_name: values for enum_name, values in defined_enums}"
        },
        {
            "key_id": 31,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_enum_values",
            "imports": [
                "from sqlalchemy import Enum"
            ],
            "code": "def get_enum_values(enum_type: Enum) -> Tuple[str, ...]:\n    return enum_type.enums"
        },
        {
            "key_id": 32,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/column_type_is_enum",
            "imports": [
                "from sqlalchemy.types import Enum"
            ],
            "code": "def column_type_is_enum(column_type) -> bool:\n    return isinstance(column_type, Enum)"
        },
        {
            "key_id": 33,
            "fqn": "alembic_postgresql_enum/get_enum_data/declared_enums.py/get_declared_enums",
            "imports": [
                "from typing import Union, List, Optional",
                "from sqlalchemy.schema import MetaData",
                "from alembic.operations import ops as UpgradeOps",
                "from alembic_postgresql_enum.get_enum_data.declared_enums import get_enum_values, column_type_is_enum",
                "from alembic_postgresql_enum.sql_commands.column_default import get_column_default",
                "from alembic_postgresql_enum.get_enum_data.types import DeclaredEnumValues, ColumnType, TableReference"
            ],
            "code": "def get_declared_enums(metadata: Union[MetaData, List[MetaData]], schema: str, default_schema: str, connection, upgrade_ops: Optional[UpgradeOps] = None) -> DeclaredEnumValues:\n    declared_enums = {}\n    for meta in (metadata if isinstance(metadata, list) else [metadata]):\n        for table in meta.tables.values():\n            for column in table.columns:\n                if column_type_is_enum(column.type):\n                    enum_values = get_enum_values(column.type)\n                    declared_enums[(schema, table.name, column.name)] = enum_values\n    return declared_enums"
        },
        {
            "key_id": 34,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_add_column_op",
            "imports": [
                "from typing import Tuple, Optional",
                "from alembic.operations.ops import AddColumnOp",
                "from alembic_postgresql_enum.get_enum_data.get_default_from_alembic_ops import _get_default_from_column"
            ],
            "code": "def _get_default_from_add_column_op(op: AddColumnOp, default_schema: str) -> Tuple[Tuple[str, str, str], Optional[str]]:\n    column_location = (default_schema, op.table_name, op.column.name)\n    default = _get_default_from_column(op.column, default_schema)\n    return column_location, default"
        },
        {
            "key_id": 36,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_column",
            "imports": [
                "from typing import Tuple, Optional",
                "from sqlalchemy import Column"
            ],
            "code": "def _get_default_from_column(column: Column, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:\n    schema = column.table.schema or default_schema\n    table_name = column.table.name\n    column_name = column.name\n    default = column.default.arg if column.default is not None else None\n    return ((schema, table_name, column_name), default)"
        },
        {
            "key_id": 35,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/_get_default_from_alter_column_op",
            "imports": [
                "from typing import Tuple, Optional",
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.get_enum_data.get_default_from_alembic_ops import _get_default_from_column"
            ],
            "code": "def _get_default_from_alter_column_op(op: ops.AlterColumnOp, default_schema: str) -> Tuple[ColumnLocation, Optional[str]]:\n    column = op.to_column()\n    return _get_default_from_column(column, default_schema)"
        },
        {
            "key_id": 37,
            "fqn": "alembic_postgresql_enum/get_enum_data/get_default_from_alembic_ops.py/get_just_added_defaults",
            "imports": [
                "from typing import Dict, Tuple, Optional",
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.get_enum_data.get_default_from_alembic_ops import _get_default_from_add_column_op, _get_default_from_alter_column_op"
            ],
            "code": "def get_just_added_defaults(upgrade_ops: Optional[UpgradeOps], default_schema: str) -> Dict[ColumnLocation, Optional[str]]:\n    defaults = {}\n    for op in upgrade_ops.ops:\n        if isinstance(op, ops.AddColumnOp):\n            loc, default = _get_default_from_add_column_op(op, default_schema)\n            if default is not None:\n                defaults[loc] = default\n        elif isinstance(op, ops.AlterColumnOp) and op.modify_default is not None:\n            loc, default = _get_default_from_alter_column_op(op, default_schema)\n            if default is not None:\n                defaults[loc] = default\n    return defaults"
        },
        {
            "key_id": 38,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_creation.py/create_new_enums",
            "imports": [
                "import logging",
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.operations.create_enum import CreateEnumOp"
            ],
            "code": "def create_new_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, schema: str, upgrade_ops: UpgradeOps):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    for enum_name, enum_values in declared_enums.items():\n        if enum_name not in defined_enums:\n            log.info(f\"Creating new enum: {enum_name} with values: {enum_values}\")\n            upgrade_ops.ops.append(CreateEnumOp(schema=schema, name=enum_name, enum_values=enum_values))"
        },
        {
            "key_id": 39,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_alteration.py/sync_changed_enums",
            "imports": [
                "import logging",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference"
            ],
            "code": "def sync_changed_enums(defined_enums: EnumNamesToValues, declared_enums: EnumNamesToValues, table_references: EnumNamesToTableReferences, schema: str, upgrade_ops: UpgradeOps):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    for enum_name, new_values in declared_enums.items():\n        old_values = defined_enums.get(enum_name)\n        if old_values and set(old_values) != set(new_values):\n            log.info(f\"Syncing enum: {enum_name} from {old_values} to {new_values}\")\n            affected_columns = [(tr.schema, tr.table_name, tr.column_name) for tr in table_references[enum_name]]\n            upgrade_ops.ops.append(SyncEnumValuesOp(schema=schema, name=enum_name, old_values=old_values, new_values=new_values, affected_columns=affected_columns))"
        },
        {
            "key_id": 40,
            "fqn": "alembic_postgresql_enum/detection_of_changes/enum_deletion.py/drop_unused_enums",
            "imports": [
                "from alembic.operations import Ops",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp",
                "from typing import List",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "from alembic_postgresql_enum.get_enum_data.defined_enums import EnumNamesToValues",
                "from alembic_postgresql_enum.get_enum_data.declared_enums import DeclaredEnumValues",
                "import logging"
            ],
            "code": "def drop_unused_enums(defined_enums: EnumNamesToValues, declared_enums: DeclaredEnumValues, schema: str, upgrade_ops: Ops):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    unused_enums = defined_enums.keys() - declared_enums.keys()\n    for enum_name in unused_enums:\n        enum_values = defined_enums[enum_name]\n        affected_columns = []  # No columns should be affected as the enum is unused\n        upgrade_ops.add_operation(SyncEnumValuesOp(schema=schema, name=enum_name, old_values=enum_values, new_values=[], affected_columns=affected_columns))"
        },
        {
            "key_id": 42,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/reverse",
            "imports": [
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "from typing import List",
                "import logging"
            ],
            "code": "def reverse(self):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    return SyncEnumValuesOp(schema=self.schema, name=self.name, old_values=self.new_values, new_values=self.old_values, affected_columns=self.affected_columns)"
        },
        {
            "key_id": 43,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/_set_enum_values",
            "imports": [
                "from alembic_postgresql_enum.get_enum_data.types import TableReference",
                "from alembic_postgresql_enum.sql_commands.enum_type import cast_old_enum_type_to_new, drop_type, rename_type, create_type",
                "from alembic_postgresql_enum.sql_commands.column_default import drop_default, set_default, rename_default_if_required",
                "from alembic_postgresql_enum.sql_commands.comparison_operators import create_comparison_operators, drop_comparison_operators",
                "from sqlalchemy.engine import Connection",
                "from typing import List, Tuple",
                "import logging"
            ],
            "code": "def _set_enum_values(cls, connection: Connection, enum_schema: str, enum_name: str, new_values: List[str], affected_columns: List[TableReference], enum_values_to_rename: List[Tuple[str, str]]):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    # Drop comparison operators for the old enum\n    drop_comparison_operators(connection, enum_schema, enum_name)\n    # Rename the old enum type\n    old_enum_name = f'{enum_name}_old'\n    rename_type(connection, enum_schema, enum_name, old_enum_name)\n    # Create new enum type with updated values\n    create_type(connection, enum_schema, enum_name, new_values)\n    # Cast old enum type to new enum type on affected columns\n    for table_reference in affected_columns:\n        cast_old_enum_type_to_new(connection, table_reference, enum_name, enum_values_to_rename)\n    # Drop the old enum type\n    drop_type(connection, enum_schema, old_enum_name)\n    # Recreate comparison operators for the new enum\n    create_comparison_operators(connection, enum_schema, enum_name, old_enum_name, enum_values_to_rename)"
        },
        {
            "key_id": 44,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/sync_enum_values",
            "imports": [
                "from alembic.operations import Operations",
                "from alembic_postgresql_enum.get_enum_data.types import ColumnType, TableReference",
                "from alembic_postgresql_enum.connection import get_connection",
                "from alembic_postgresql_enum.sql_commands.column_default import get_column_default",
                "from typing import Iterable, Tuple",
                "import logging"
            ],
            "code": "def sync_enum_values(cls, operations: Operations, enum_schema: str, enum_name: str, new_values: List[str], affected_columns: List[Tuple[str, str]], enum_values_to_rename: Iterable[Tuple[str, str]] = tuple()):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    with get_connection(operations) as connection:\n        # Get current default values for columns that will be affected\n        for table_name, column_name in affected_columns:\n            default_value = get_column_default(connection, enum_schema, table_name, column_name)\n            if default_value is not None:\n                # If there's a default value, ensure it's updated to match the new enum values\n                _set_enum_values(cls, connection, enum_schema, enum_name, new_values, [TableReference(table_name, column_name, ColumnType.ENUM)], list(enum_values_to_rename))"
        },
        {
            "key_id": 45,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/to_diff_tuple",
            "imports": [
                "import logging"
            ],
            "code": "def to_diff_tuple(self) -> Tuple[Any, ...]:\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    return ('enum_values_changed', self.schema, self.name, self.old_values, self.new_values)"
        },
        {
            "key_id": 46,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/SyncEnumValuesOp/is_column_type_import_needed",
            "imports": [
                "from alembic_postgresql_enum.get_enum_data.declared_enums import column_type_is_enum",
                "from alembic_postgresql_enum.get_enum_data.types import TableReference"
            ],
            "code": "def __init__(self, schema: str, name: str, old_values: List[str], new_values: List[str], affected_columns: List[TableReference]):\n    self.schema = schema\n    self.name = name\n    self.old_values = old_values\n    self.new_values = new_values\n    self.affected_columns = affected_columns\n    self.operation_name = 'change_enum_variants'\n\ndef is_column_type_import_needed(self) -> bool:\n    return any(column_type_is_enum(column.column_type) for column in self.affected_columns)"
        },
        {
            "key_id": 47,
            "fqn": "alembic_postgresql_enum/operations/sync_enum_values.py/render_sync_enum_value_op",
            "imports": [
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.operations.sync_enum_values import SyncEnumValuesOp"
            ],
            "code": "def render_sync_enum_value_op(autogen_context: AutogenContext, op: SyncEnumValuesOp):\n    args = [repr(arg) for arg in (op.schema, op.name, op.old_values, op.new_values, op.affected_columns)]\n    return f'SyncEnumValuesOp({', '.join(args)})'"
        },
        {
            "key_id": 49,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/operation_name",
            "imports": [],
            "code": "def __init__(self, schema: str, name: str, enum_values: Iterable[str]):\n    self.schema = schema\n    self.name = name\n    self.enum_values = list(enum_values)\n\ndef operation_name(self) -> str:\n    return self.operation_name"
        },
        {
            "key_id": 50,
            "fqn": "alembic_postgresql_enum/operations/enum_lifecycle_base.py/EnumLifecycleOp/to_diff_tuple",
            "imports": [],
            "code": "def to_diff_tuple(self) -> Tuple[Any, ...]:\n    return ('EnumLifecycleOp', self.schema, self.name, self.enum_values, self.operation_name())"
        },
        {
            "key_id": 51,
            "fqn": "alembic_postgresql_enum/operations/create_enum.py/CreateEnumOp/reverse",
            "imports": [
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.operations.drop_enum import DropEnumOp"
            ],
            "code": "def reverse(self):\n    return DropEnumOp(self.schema, self.name, self.enum_values)"
        },
        {
            "key_id": 52,
            "fqn": "alembic_postgresql_enum/operations/create_enum.py/render_create_enum_op",
            "imports": [
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic_postgresql_enum.operations.create_enum import CreateEnumOp"
            ],
            "code": "def render_create_enum_op(autogen_context: AutogenContext, op: CreateEnumOp):\n    args = [repr(arg) for arg in (op.schema, op.name, op.enum_values)]\n    return f'CreateEnumOp({', '.join(args)})'"
        },
        {
            "key_id": 52,
            "fqn": "alembic_postgresql_enum/operations/create_enum.py/render_create_enum_op",
            "imports": [
                "from alembic.autogenerate import render_python_code",
                "from alembic.operations import ops"
            ],
            "code": "def render_create_enum_op(autogen_context, op):\n    if not isinstance(op, ops.CreateEnumOp):\n        raise TypeError('op must be an instance of CreateEnumOp')\n    args = [repr(op.schema), repr(op.name), list(map(repr, op.enum_values))]\n    return 'op.create_enum(%s)' % ', '.join(args)"
        },
        {
            "key_id": 53,
            "fqn": "alembic_postgresql_enum/operations/drop_enum.py/DropEnumOp/reverse",
            "imports": [
                "from alembic.operations import ops"
            ],
            "code": "def reverse(self):\n    return ops.CreateEnumOp(\n        schema=self.schema,\n        name=self.name,\n        enum_values=self.enum_values\n    )"
        },
        {
            "key_id": 54,
            "fqn": "alembic_postgresql_enum/operations/drop_enum.py/render_drop_enum_op",
            "imports": [
                "from alembic.autogenerate import render_python_code",
                "from alembic.operations import ops"
            ],
            "code": "def render_drop_enum_op(autogen_context, op):\n    if not isinstance(op, ops.DropEnumOp):\n        raise TypeError('op must be an instance of DropEnumOp')\n    args = [repr(op.schema), repr(op.name)]\n    return 'op.drop_enum(%s)' % ', '.join(args)"
        },
        {
            "key_id": 0,
            "fqn": "alembic_postgresql_enum/connection.py/get_connection",
            "imports": [
                "from contextlib import contextmanager",
                "from sqlalchemy import create_engine"
            ],
            "code": "def get_connection(operations):\n    @contextmanager\n    def connection_context():\n        engine = create_engine(operations.config.get_main_option('sqlalchemy.url'))\n        connection = engine.connect()\n        try:\n            yield connection\n        finally:\n            connection.close()\n    return connection_context()"
        },
        {
            "key_id": 1,
            "fqn": "alembic_postgresql_enum/compare_dispatch.py/compare_enums",
            "imports": [
                "from sqlalchemy import MetaData",
                "from alembic.operations import ops",
                "from alembic.autogenerate.api import AutogenContext",
                "from alembic_postgresql_enum.get_enum_data.defined_enums import get_defined_enums",
                "from alembic_postgresql_enum.get_enum_data.declared_enums import get_declared_enums"
            ],
            "code": "def compare_enums(autogen_context: AutogenContext, upgrade_ops: ops.UpgradeOps, schema_names):\n    metadata = MetaData()\n    metadata.reflect(autogen_context.connection, schema=schema_names)\n    defined_enums = get_defined_enums(autogen_context.connection, schema_names)\n    declared_enums = get_declared_enums(metadata, schema_names, autogen_context.dialect.default_schema_name, autogen_context.connection)\n    for schema, enum_name, enum_values in declared_enums.items():\n        if (schema, enum_name) not in defined_enums or set(defined_enums[(schema, enum_name)]) != set(enum_values):\n            upgrade_ops.ops.append(ops.AlterEnumOp(enum_name=enum_name, old_enum_values=defined_enums.get((schema, enum_name), []), new_enum_values=enum_values, schema=schema))"
        },
        {
            "key_id": 2,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/ReprWorkaround/__repr__",
            "imports": [
                "from sqlalchemy.dialects.postgresql import ENUM"
            ],
            "code": "class ReprWorkaround:\n    __module__ = 'sqlalchemy.dialects.postgresql'\n\n    def __repr__(self):\n        return f'<ReprWorkaround for {self.__class__.__name__}>'"
        },
        {
            "key_id": 3,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/get_replacement_type",
            "imports": [
                "from sqlalchemy.dialects.postgresql import ENUM"
            ],
            "code": "def get_replacement_type(column_type):\n    if isinstance(column_type, ENUM):\n        return ReprWorkaround()\n    return column_type"
        },
        {
            "key_id": 4,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/inject_repr_into_enums",
            "imports": [
                "from sqlalchemy import Column"
            ],
            "code": "def inject_repr_into_enums(column: Column):\n    column.type = get_replacement_type(column.type)"
        },
        {
            "key_id": 5,
            "fqn": "alembic_postgresql_enum/add_create_type_false.py/add_create_type_false",
            "imports": [
                "from alembic.operations import ops",
                "from sqlalchemy import MetaData, Table"
            ],
            "code": "def add_create_type_false(upgrade_ops: ops.UpgradeOps):\n    for op in upgrade_ops.ops:\n        if isinstance(op, ops.CreateTableOp):\n            for column in op.columns:\n                inject_repr_into_enums(column)\n        elif isinstance(op, ops.AddColumnOp):\n            inject_repr_into_enums(op.column)"
        },
        {
            "key_id": 6,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/PostgresUsingAlterColumnOp/reverse",
            "imports": [
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.add_postgres_using_to_text import _postgres_using_alter_column"
            ],
            "code": "class PostgresUsingAlterColumnOp:\n    def reverse(self):\n        return self"
        },
        {
            "key_id": 7,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/_postgres_using_alter_column",
            "imports": [
                "from alembic.autogenerate import api",
                "from alembic.operations import ops"
            ],
            "code": "def _postgres_using_alter_column(autogen_context: api.AutogenContext, op: ops.AlterColumnOp) -> str:\n    return f'USING {op.column_name}::text'"
        },
        {
            "key_id": 8,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_alter_operation",
            "imports": [
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.add_postgres_using_to_text import PostgresUsingAlterColumnOp"
            ],
            "code": "def add_postgres_using_to_alter_operation(op: ops.AlterColumnOp):\n    if isinstance(op, ops.AlterColumnOp) and 'postgresql_using' in op.kwargs:\n        op = PostgresUsingAlterColumnOp()\n    return op"
        },
        {
            "key_id": 9,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_text",
            "imports": [
                "from alembic.operations import ops"
            ],
            "code": "def add_postgres_using_to_text(upgrade_ops: ops.UpgradeOps):\n    for op in upgrade_ops.ops:\n        if isinstance(op, ops.AlterColumnOp):\n            op = add_postgres_using_to_alter_operation(op)"
        },
        {
            "key_id": 7,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/_postgres_using_alter_column",
            "imports": [
                "from alembic.operations import ops",
                "from alembic.autogenerate.api import AutogenContext",
                "import logging"
            ],
            "code": "def _postgres_using_alter_column(autogen_context: AutogenContext, op: ops.AlterColumnOp) -> str:\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    log.info(\"Applying USING for PostgreSQL ENUM alteration.\")\n    # Assuming the alteration involves an ENUM type change\n    if op.modify_type:\n        return f\"ALTER COLUMN {op.column_name} TYPE {op.modify_type.compile(autogen_context.dialect)} USING ({op.column_name}::text::{op.modify_type.compile(autogen_context.dialect)})\"\n    else:\n        return \"\""
        },
        {
            "key_id": 8,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_alter_operation",
            "imports": [
                "from alembic.operations import ops",
                "from alembic_postgresql_enum.add_postgres_using_to_text import PostgresUsingAlterColumnOp",
                "import logging"
            ],
            "code": "def add_postgres_using_to_alter_operation(op: ops.AlterColumnOp):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    if isinstance(op, PostgresUsingAlterColumnOp):\n        log.info(\"Postgres USING syntax already applied.\")\n    else:\n        log.info(\"Adding Postgres USING syntax to alter column operation.\")\n        return PostgresUsingAlterColumnOp.from_existing_alter_column_op(op)"
        },
        {
            "key_id": 9,
            "fqn": "alembic_postgresql_enum/add_postgres_using_to_text.py/add_postgres_using_to_text",
            "imports": [
                "from alembic.operations import ops as upgrade_ops",
                "from alembic_postgresql_enum.add_postgres_using_to_text import add_postgres_using_to_alter_operation",
                "import logging"
            ],
            "code": "def add_postgres_using_to_text(upgrade_ops: upgrade_ops.UpgradeOps):\n    log = logging.getLogger(f\"alembic.{__name__}\")\n    for op in upgrade_ops.ops:\n        if isinstance(op, upgrade_ops.AlterColumnOp):\n            add_postgres_using_to_alter_operation(op)\n        else:\n            log.info(\"Operation not applicable for Postgres USING syntax.\")"
        }
    ]
}